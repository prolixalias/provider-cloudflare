name: cloudflare/cloudflare
resources:
    cloudflare_access_rule:
        subCategory: ""
        name: cloudflare_access_rule
        title: cloudflare_access_rule Resource - Cloudflare
        examples:
            - name: example_access_rule
              manifest: |-
                {
                  "configuration": {
                    "target": "ip",
                    "value": "198.51.100.4"
                  },
                  "mode": "challenge",
                  "notes": "This rule is enabled because of an event that occurred on date X.",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            allowed_modes: (List of String) The available actions that a rule can apply to a matched request.
            configuration: (Attributes) The rule configuration. (see below for nested schema)
            created_on: (String) The timestamp of when the rule was created.
            email: (String) The contact email address of the user.
            id: (String) The unique identifier of the IP Access rule.
            mode: |-
                (String) The action to apply to a matched request.
                Available values: "block", "challenge", "whitelist", "js_challenge", "managed_challenge".
            modified_on: (String) The timestamp of when the rule was last modified.
            notes: (String) An informative summary of the rule, typically used as a reminder or explanation.
            scope: (Attributes) All zones owned by the user will have the rule applied. (see below for nested schema)
            target: |-
                (String) The configuration target. You must set the target to ip when specifying an IP address in the rule.
                Available values: "ip", "ip6", "ip_range", "asn", "country".
            type: |-
                (String) Defines the scope of the rule.
                Available values: "user", "organization".
            value: (String) The IP address to match. This address will be compared to the IP address of incoming requests.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_access_rule.example '<{accounts|zones}/{account_id|zone_id}>/<rule_id>'
    cloudflare_account:
        subCategory: ""
        name: cloudflare_account
        title: cloudflare_account Resource - Cloudflare
        examples:
            - name: example_account
              manifest: |-
                {
                  "name": "name",
                  "type": "standard",
                  "unit": {
                    "id": "f267e341f3dd4697bd3b9f71dd96247f"
                  }
                }
        argumentDocs:
            abuse_contact_email: (String) Sets an abuse contact email to notify for abuse reports.
            created_on: (String) Timestamp for the creation of the account
            enforce_twofactor: |-
                (Boolean) Indicates whether membership in this account requires that
                Two-Factor Authentication is enabled
            id: (String) Identifier
            managed_by: (Attributes) Parent container details (see below for nested schema)
            name: (String) Account name
            parent_org_id: (String) ID of the parent Organization, if one exists
            parent_org_name: (String) Name of the parent Organization, if one exists
            settings: (Attributes) Account settings (see below for nested schema)
            type: '(String) Available values: "standard", "enterprise".'
            unit: (Attributes) information related to the tenant unit, and optionally, an id of the unit to create the account on. see https://developers.cloudflare.com/tenant/how-to/manage-accounts/ (see below for nested schema)
        importStatements:
            - $ terraform import cloudflare_account.example '<account_id>'
    cloudflare_account_dns_settings:
        subCategory: ""
        name: cloudflare_account_dns_settings
        title: cloudflare_account_dns_settings Resource - Cloudflare
        examples:
            - name: example_account_dns_settings
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "zone_defaults": {
                    "flatten_all_cnames": false,
                    "foundation_dns": false,
                    "internal_dns": {
                      "reference_zone_id": "reference_zone_id"
                    },
                    "multi_provider": false,
                    "nameservers": {
                      "type": "cloudflare.standard"
                    },
                    "ns_ttl": 86400,
                    "secondary_overrides": false,
                    "soa": {
                      "expire": 604800,
                      "min_ttl": 1800,
                      "mname": "kristina.ns.cloudflare.com",
                      "refresh": 10000,
                      "retry": 2400,
                      "rname": "admin.example.com",
                      "ttl": 3600
                    },
                    "zone_mode": "dns_only"
                  }
                }
        argumentDocs:
            account_id: (String) Identifier.
            expire: (Number) Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
            flatten_all_cnames: (Boolean) Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
            foundation_dns: (Boolean) Whether to enable Foundation DNS Advanced Nameservers on the zone.
            internal_dns: (Attributes) Settings for this internal zone. (see below for nested schema)
            min_ttl: (Number) The time to live (TTL) for negative caching of records within the zone.
            mname: (String) The primary nameserver, which may be used for outbound zone transfers. If null, a Cloudflare-assigned value will be used.
            multi_provider: (Boolean) Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
            nameservers: (Attributes) Settings determining the nameservers through which the zone should be available. (see below for nested schema)
            ns_ttl: (Number) The time to live (TTL) of the zone's nameserver (NS) records.
            reference_zone_id: (String) The ID of the zone to fallback to.
            refresh: (Number) Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
            retry: (Number) Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
            rname: (String) The email address of the zone administrator, with the first label representing the local part of the email address.
            secondary_overrides: (Boolean) Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
            soa: (Attributes) Components of the zone's SOA record. (see below for nested schema)
            ttl: (Number) The time to live (TTL) of the SOA record itself.
            type: |-
                (String) Nameserver type
                Available values: "cloudflare.standard", "cloudflare.standard.random", "custom.account", "custom.tenant".
            zone_defaults: (Attributes) (see below for nested schema)
            zone_mode: |-
                (String) Whether the zone mode is a regular or CDN/DNS only zone.
                Available values: "standard", "cdn_only", "dns_only".
        importStatements: []
    cloudflare_account_dns_settings_internal_view:
        subCategory: ""
        name: cloudflare_account_dns_settings_internal_view
        title: cloudflare_account_dns_settings_internal_view Resource - Cloudflare
        examples:
            - name: example_account_dns_settings_internal_view
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "my view",
                  "zones": [
                    "372e67954025e0ba6aaa6d586b9e0b59"
                  ]
                }
        argumentDocs:
            account_id: (String) Identifier.
            created_time: (String) When the view was created.
            id: (String) Identifier.
            modified_time: (String) When the view was last modified.
            name: (String) The name of the view.
            zones: (Set of String) The list of zones linked to this view.
        importStatements:
            - $ terraform import cloudflare_account_dns_settings_internal_view.example '<account_id>/<view_id>'
    cloudflare_account_member:
        subCategory: ""
        name: cloudflare_account_member
        title: cloudflare_account_member Resource - Cloudflare
        examples:
            - name: example_account_member
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "email": "user@example.com",
                  "roles": [
                    "3536bcfad5faccb999b47003c79917fb"
                  ],
                  "status": "accepted"
                }
        argumentDocs:
            access: |-
                (String) Allow or deny operations against the resources.
                Available values: "allow", "deny".
            account_id: (String) Account identifier tag.
            email: (String) The contact email address of the user.
            first_name: (String) User's first name
            id: (String) Membership identifier tag.
            last_name: (String) User's last name
            permission_groups: (Attributes Set) A set of permission groups that are specified to the policy. (see below for nested schema)
            policies: (Attributes Set) Array of policies associated with this member. (see below for nested schema)
            resource_groups: (Attributes Set) A list of resource groups that the policy applies to. (see below for nested schema)
            roles: (Set of String) Set of roles associated with this member.
            status: '(String) Available values: "accepted", "pending".'
            two_factor_authentication_enabled: (Boolean) Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
            user: (Attributes) Details of the user associated to the membership. (see below for nested schema)
        importStatements:
            - $ terraform import cloudflare_account_member.example '<account_id>/<member_id>'
    cloudflare_account_subscription:
        subCategory: ""
        name: cloudflare_account_subscription
        title: cloudflare_account_subscription Resource - Cloudflare
        examples:
            - name: example_account_subscription
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "frequency": "monthly",
                  "rate_plan": {
                    "currency": "USD",
                    "externally_managed": false,
                    "id": "free",
                    "is_contract": false,
                    "public_name": "Business Plan",
                    "scope": "zone",
                    "sets": [
                      "string"
                    ]
                  }
                }
        argumentDocs:
            account_id: (String) Identifier
            currency: (String) The monetary unit in which pricing information is displayed.
            current_period_end: (String) The end of the current period and also when the next billing is due.
            current_period_start: (String) When the current billing period started. May match initial_period_start if this is the first period.
            externally_managed: (Boolean) Whether this rate plan is managed externally from Cloudflare.
            frequency: |-
                (String) How often the subscription is renewed automatically.
                Available values: "weekly", "monthly", "quarterly", "yearly".
            id: (String) Subscription identifier tag.
            is_contract: (Boolean) Whether a rate plan is enterprise-based (or newly adopted term contract).
            price: (Number) The price of the subscription that will be billed, in US dollars.
            public_name: (String) The full name of the rate plan.
            rate_plan: (Attributes) The rate plan applied to the subscription. (see below for nested schema)
            scope: (String) The scope that this rate plan applies to.
            sets: (List of String) The list of sets this rate plan applies to. Returns array of strings.
            state: |-
                (String) The state that the subscription is in.
                Available values: "Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired".
        importStatements:
            - $ terraform import cloudflare_account_subscription.example '<account_id>'
    cloudflare_account_token:
        subCategory: ""
        name: cloudflare_account_token
        title: cloudflare_account_token Resource - Cloudflare
        examples:
            - name: example_account_token
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "condition": {
                    "request_ip": {
                      "in": [
                        "123.123.123.0/24",
                        "2606:4700::/32"
                      ],
                      "not_in": [
                        "123.123.123.100/24",
                        "2606:4700:4700::/48"
                      ]
                    }
                  },
                  "expires_on": "2020-01-01T00:00:00Z",
                  "name": "readonly token",
                  "not_before": "2018-07-01T05:20:00Z",
                  "policies": [
                    {
                      "effect": "allow",
                      "permission_groups": [
                        {
                          "id": "c8fed203ed3043cba015a93ad1616f1f",
                          "meta": {
                            "key": "key",
                            "value": "value"
                          }
                        },
                        {
                          "id": "82e64a83756745bbbb1c9c2701bf816b",
                          "meta": {
                            "key": "key",
                            "value": "value"
                          }
                        }
                      ],
                      "resources": {
                        "foo": "string"
                      }
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Account identifier tag.
            condition: (Attributes) (see below for nested schema)
            effect: |-
                (String) Allow or deny operations against the resources.
                Available values: "allow", "deny".
            expires_on: (String) The expiration time on or after which the JWT MUST NOT be accepted for processing.
            id: (String) Token identifier tag.
            in: (List of String) List of IPv4/IPv6 CIDR addresses.
            issued_on: (String) The time on which the token was created.
            last_used_on: (String) Last time the token was used.
            modified_on: (String) Last time the token was modified.
            name: (String) Token name.
            not_before: (String) The time before which the token MUST NOT be accepted for processing.
            not_in: (List of String) List of IPv4/IPv6 CIDR addresses.
            permission_groups: (Attributes Set) A set of permission groups that are specified to the policy. (see below for nested schema)
            policies: (Attributes Set) Set of access policies assigned to the token. (see below for nested schema)
            request_ip: (Attributes) Client IP restrictions. (see below for nested schema)
            resources: (String) A json object representing the resources that are specified to the policy.
            status: |-
                (String) Status of the token.
                Available values: "active", "disabled", "expired".
            value: (String, Sensitive) The token value.
        importStatements:
            - $ terraform import cloudflare_account_token.example '<account_id>/<token_id>'
    cloudflare_address_map:
        subCategory: ""
        name: cloudflare_address_map
        title: cloudflare_address_map Resource - Cloudflare
        examples:
            - name: example_address_map
              manifest: |-
                {
                  "account_id": "258def64c72dae45f3e4c8516e2111f2",
                  "description": "My Ecommerce zones",
                  "enabled": true,
                  "ips": [
                    "192.0.2.1"
                  ],
                  "memberships": [
                    {
                      "identifier": "023e105f4ecef8ad9ca31a8372d0c353",
                      "kind": "zone"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Identifier of a Cloudflare account.
            can_delete: (Boolean) If set to false, then the Address Map cannot be deleted via API. This is true for Cloudflare-managed maps.
            can_modify_ips: (Boolean) If set to false, then the IPs on the Address Map cannot be modified via the API. This is true for Cloudflare-managed maps.
            created_at: (String)
            default_sni: (String) If you have legacy TLS clients which do not send the TLS server name indicator, then you can specify one default SNI on the map. If Cloudflare receives a TLS handshake from a client without an SNI, it will respond with the default SNI on those IPs. The default SNI can be any valid zone or subdomain owned by the account.
            description: (String) An optional description field which may be used to describe the types of IPs or zones on the map.
            enabled: (Boolean) Whether the Address Map is enabled or not. Cloudflare's DNS will not respond with IP addresses on an Address Map until the map is enabled.
            id: (String) Identifier of an Address Map.
            identifier: (String) The identifier for the membership (eg. a zone or account tag).
            ips: (List of String)
            kind: |-
                (String) The type of the membership.
                Available values: "zone", "account".
            memberships: (Attributes List) Zones and Accounts which will be assigned IPs on this Address Map. A zone membership will take priority over an account membership. (see below for nested schema)
            modified_at: (String)
        importStatements:
            - $ terraform import cloudflare_address_map.example '<account_id>/<address_map_id>'
    cloudflare_api_shield:
        subCategory: ""
        description: Manages API Shield configuration properties for a zone, specifically auth ID characteristics.
        name: cloudflare_api_shield
        title: cloudflare_api_shield Resource - Cloudflare
        examples:
            - name: header_example
              manifest: |-
                {
                  "auth_id_characteristics": [
                    {
                      "name": "authorization",
                      "type": "header"
                    }
                  ],
                  "zone_id": "0da42c8d2132a9ddaf714f9e7c920711"
                }
            - name: cookie_example
              manifest: |-
                {
                  "auth_id_characteristics": [
                    {
                      "name": "session_id",
                      "type": "cookie"
                    }
                  ],
                  "zone_id": "0da42c8d2132a9ddaf714f9e7c920711"
                }
            - name: jwt_example
              manifest: |-
                {
                  "auth_id_characteristics": [
                    {
                      "name": "d5902294-00c3-4aed-b517-57e752e9cd58:$.sub",
                      "type": "jwt"
                    }
                  ],
                  "zone_id": "0da42c8d2132a9ddaf714f9e7c920711"
                }
            - name: multiple_identifiers
              manifest: |-
                {
                  "auth_id_characteristics": [
                    {
                      "name": "x-api-key",
                      "type": "header"
                    },
                    {
                      "name": "session_token",
                      "type": "cookie"
                    }
                  ],
                  "zone_id": "0da42c8d2132a9ddaf714f9e7c920711"
                }
            - name: header_and_jwt
              manifest: |-
                {
                  "auth_id_characteristics": [
                    {
                      "name": "x-client-id",
                      "type": "header"
                    },
                    {
                      "name": "d5902294-00c3-4aed-b517-57e752e9cd58:$.email",
                      "type": "jwt"
                    }
                  ],
                  "zone_id": "0da42c8d2132a9ddaf714f9e7c920711"
                }
            - name: example_api_shield
              manifest: |-
                {
                  "auth_id_characteristics": [
                    {
                      "name": "authorization",
                      "type": "header"
                    }
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            auth_id_characteristics: (Attributes List) (see below for nested schema)
            id: (String) Identifier.
            json_path: is a RFC 9535 JSONPath expression that returns a singleton value (interpreted as a string)
            name: (String) The name of the characteristic field, i.e., the header or cookie name. When using type "jwt", this must be a claim location expressed as $(token_config_id):$(json_path), where token_config_id is the ID of the token configuration used in validating the JWT, and json_path is a RFC 9535 JSONPath expression.
            token_config_id: is the ID of the token configuration used in validating the JWT
            type: |-
                (String) The type of characteristic.
                Available values: "header", "cookie", "jwt".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_api_shield.example '<zone_id>'
    cloudflare_api_shield_discovery_operation:
        subCategory: ""
        name: cloudflare_api_shield_discovery_operation
        title: cloudflare_api_shield_discovery_operation Resource - Cloudflare
        examples:
            - name: example_api_shield_discovery_operation
              manifest: |-
                {
                  "operation_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                  "state": "review",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            id: (String) UUID.
            ignored: |-
                - Mark operation as ignored
                Available values: "review", "ignored".
            operation_id: (String) UUID.
            review: '- Mark operation as for review'
            state: (String) Mark state of operation in API Discovery
            zone_id: (String) Identifier.
        importStatements: []
    cloudflare_api_shield_operation:
        subCategory: ""
        name: cloudflare_api_shield_operation
        title: cloudflare_api_shield_operation Resource - Cloudflare
        examples:
            - name: example_api_shield_operation
              manifest: |-
                {
                  "endpoint": "/api/v1/users/{var1}",
                  "host": "www.example.com",
                  "method": "GET",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            active_schema: (Attributes) Schema active on endpoint. (see below for nested schema)
            api_routing: (Attributes) API Routing settings on endpoint. (see below for nested schema)
            auth_id_tokens: (Number) The total number of auth-ids seen across this calculation.
            confidence_intervals: (Attributes) (see below for nested schema)
            created_at: (String)
            data_points: (Number) The number of data points used for the threshold suggestion calculation.
            endpoint: '(String) The endpoint which can contain path parameter templates in curly braces, each will be replaced from left to right with {varN}, starting with {var1}, during insertion. This will further be Cloudflare-normalized upon insertion. See: https://developers.cloudflare.com/rules/normalization/how-it-works/.'
            features: (Attributes) (see below for nested schema)
            host: (String) RFC3986-compliant host.
            id: (String) UUID.
            is_learned: (Boolean) True if schema is Cloudflare-provided.
            last_updated: (String)
            learned_available: (Boolean) True if a Cloudflare-provided learned schema is available for this endpoint.
            lower: (Number) Lower bound for percentile estimate
            mean: (Number) Suggested threshold.
            method: |-
                (String) The HTTP method used to access the endpoint.
                Available values: "GET", "POST", "HEAD", "OPTIONS", "PUT", "DELETE", "CONNECT", "PATCH", "TRACE".
            mitigation_action: |-
                (String) Action taken on requests failing validation.
                Available values: "none", "log", "block".
            name: (String) Schema file name.
            operation_id: (String) UUID.
            p50: (Number) The p50 quantile of requests (in period_seconds).
            p90: (Attributes) Upper and lower bound for percentile estimate (see below for nested schema)
            p95: (Attributes) Upper and lower bound for percentile estimate (see below for nested schema)
            p99: (Attributes) Upper and lower bound for percentile estimate (see below for nested schema)
            parameter_schemas: (Attributes) (see below for nested schema)
            parameters: (List of String) An array containing the learned parameter schemas.
            period_seconds: (Number) The period over which this threshold is suggested.
            requests: (Number) The estimated number of requests covered by these calculations.
            responses: (String) An empty response object. This field is required to yield a valid operation schema.
            route: (String) Target route.
            schema_info: (Attributes) (see below for nested schema)
            suggested_threshold: (Attributes) (see below for nested schema)
            thresholds: (Attributes) (see below for nested schema)
            upper: (Number) Upper bound for percentile estimate
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_api_shield_operation.example '<zone_id>/<operation_id>'
    cloudflare_api_shield_operation_schema_validation_settings:
        subCategory: ""
        name: cloudflare_api_shield_operation_schema_validation_settings
        title: cloudflare_api_shield_operation_schema_validation_settings Resource - Cloudflare
        examples:
            - name: example_api_shield_operation_schema_validation_settings
              manifest: |-
                {
                  "mitigation_action": "block",
                  "operation_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            block: deny access to the site when request does not conform to schema for this operation
            id: (String) UUID.
            log: log request when request does not conform to schema for this operation
            mitigation_action: (String) When set, this applies a mitigation action to this operation
            none: will skip mitigation for this operation
            "null": |-
                indicates that no operation level mitigation is in place, see Zone Level Schema Validation Settings for mitigation action that will be applied
                Available values: "log", "block", "none".
            operation_id: (String) UUID.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_api_shield_operation_schema_validation_settings.example '<zone_id>/<operation_id>'
    cloudflare_api_shield_schema:
        subCategory: ""
        name: cloudflare_api_shield_schema
        title: cloudflare_api_shield_schema Resource - Cloudflare
        examples:
            - name: example_api_shield_schema
              manifest: |-
                {
                  "file": null,
                  "kind": "openapi_v3",
                  "name": "petstore schema",
                  "validation_enabled": "true",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            code: (Number) Code that identifies the event that occurred.
            created_at: (String)
            file: (String) Schema file bytes
            kind: |-
                (String) Kind of schema
                Available values: "openapi_v3".
            locations: (List of String) JSONPath location(s) in the schema where these events were encountered.  See https://goessner.net/articles/JsonPath/ for JSONPath specification.
            message: (String) Diagnostic message that describes the event.
            name: (String) Name of the schema
            schema: (Attributes) (see below for nested schema)
            schema_id: (String)
            source: (String) Source of the schema
            upload_details: (Attributes) (see below for nested schema)
            validation_enabled: |-
                (String) Flag whether schema is enabled for validation.
                Available values: "true", "false".
            warnings: (Attributes List) Diagnostic warning events that occurred during processing. These events are non-critical errors found within the schema. (see below for nested schema)
            zone_id: (String) Identifier.
        importStatements: []
    cloudflare_api_shield_schema_validation_settings:
        subCategory: ""
        name: cloudflare_api_shield_schema_validation_settings
        title: cloudflare_api_shield_schema_validation_settings Resource - Cloudflare
        examples:
            - name: example_api_shield_schema_validation_settings
              manifest: |-
                {
                  "validation_default_mitigation_action": "block",
                  "validation_override_mitigation_action": "none",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            block: '- deny access to the site when request does not conform to schema'
            id: (String) Identifier.
            log: '- log request when request does not conform to schema'
            none: will skip running schema validation entirely for the request
            none.zone_id: (String) Identifier.
            "null": indicates that no override is in place
            validation_default_mitigation_action: (String) The default mitigation action used when there is no mitigation action defined on the operation
            validation_override_mitigation_action: (String) When set, this overrides both zone level and operation level mitigation actions.
        importStatements:
            - $ terraform import cloudflare_api_shield_schema_validation_settings.example '<zone_id>'
    cloudflare_api_token:
        subCategory: ""
        name: cloudflare_api_token
        title: cloudflare_api_token Resource - Cloudflare
        examples:
            - name: example_api_token
              manifest: |-
                {
                  "condition": {
                    "request_ip": {
                      "in": [
                        "123.123.123.0/24",
                        "2606:4700::/32"
                      ],
                      "not_in": [
                        "123.123.123.100/24",
                        "2606:4700:4700::/48"
                      ]
                    }
                  },
                  "expires_on": "2020-01-01T00:00:00Z",
                  "name": "readonly token",
                  "not_before": "2018-07-01T05:20:00Z",
                  "policies": [
                    {
                      "effect": "allow",
                      "permission_groups": [
                        {
                          "id": "c8fed203ed3043cba015a93ad1616f1f",
                          "meta": {
                            "key": "key",
                            "value": "value"
                          }
                        },
                        {
                          "id": "82e64a83756745bbbb1c9c2701bf816b",
                          "meta": {
                            "key": "key",
                            "value": "value"
                          }
                        }
                      ],
                      "resources": {
                        "foo": "string"
                      }
                    }
                  ]
                }
        argumentDocs:
            condition: (Attributes) (see below for nested schema)
            effect: |-
                (String) Allow or deny operations against the resources.
                Available values: "allow", "deny".
            expires_on: (String) The expiration time on or after which the JWT MUST NOT be accepted for processing.
            id: (String) Token identifier tag.
            in: (List of String) List of IPv4/IPv6 CIDR addresses.
            issued_on: (String) The time on which the token was created.
            last_used_on: (String) Last time the token was used.
            modified_on: (String) Last time the token was modified.
            name: (String) Token name.
            not_before: (String) The time before which the token MUST NOT be accepted for processing.
            not_in: (List of String) List of IPv4/IPv6 CIDR addresses.
            permission_groups: (Attributes Set) A set of permission groups that are specified to the policy. (see below for nested schema)
            policies: (Attributes Set) Set of access policies assigned to the token. (see below for nested schema)
            request_ip: (Attributes) Client IP restrictions. (see below for nested schema)
            resources: (String) A json object representing the resources that are specified to the policy.
            status: |-
                (String) Status of the token.
                Available values: "active", "disabled", "expired".
            value: (String, Sensitive) The token value.
        importStatements:
            - $ terraform import cloudflare_api_token.example '<token_id>'
    cloudflare_argo_smart_routing:
        subCategory: ""
        name: cloudflare_argo_smart_routing
        title: cloudflare_argo_smart_routing Resource - Cloudflare
        examples:
            - name: example_argo_smart_routing
              manifest: |-
                {
                  "value": "on",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            editable: (Boolean) Specifies if the setting is editable.
            id: (String) Specifies the zone associated with the API call.
            modified_on: (String) Specifies the time when the setting was last modified.
            value: |-
                (String) Specifies the enablement value of Argo Smart Routing.
                Available values: "on", "off".
            zone_id: (String) Specifies the zone associated with the API call.
        importStatements:
            - $ terraform import cloudflare_argo_smart_routing.example '<zone_id>'
    cloudflare_argo_tiered_caching:
        subCategory: ""
        name: cloudflare_argo_tiered_caching
        title: cloudflare_argo_tiered_caching Resource - Cloudflare
        examples:
            - name: example_argo_tiered_caching
              manifest: |-
                {
                  "value": "on",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            editable: (Boolean) Whether the setting is editable.
            id: (String) Identifier.
            modified_on: (String) Last time this setting was modified.
            value: |-
                (String) Enables Tiered Caching.
                Available values: "on", "off".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_argo_tiered_caching.example '<zone_id>'
    cloudflare_authenticated_origin_pulls:
        subCategory: ""
        name: cloudflare_authenticated_origin_pulls
        title: cloudflare_authenticated_origin_pulls Resource - Cloudflare
        examples:
            - name: example_authenticated_origin_pulls
              manifest: |-
                {
                  "config": [
                    {
                      "cert_id": "2458ce5a-0c35-4c7f-82c7-8e9487d3ff60",
                      "enabled": true,
                      "hostname": "app.example.com"
                    }
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            cert_id: (String) Identifier.
            cert_status: |-
                (String) Status of the certificate or the association.
                Available values: "initializing", "pending_deployment", "pending_deletion", "active", "deleted", "deployment_timed_out", "deletion_timed_out".
            cert_updated_at: (String) The time when the certificate was updated.
            cert_uploaded_on: (String) The time when the certificate was uploaded.
            certificate: (String) The hostname certificate.
            config: (Attributes List) (see below for nested schema)
            created_at: (String) The time when the certificate was created.
            enabled: (Boolean) Indicates whether hostname-level authenticated origin pulls is enabled. A null value voids the association.
            expires_on: (String) The date when the certificate expires.
            hostname: (String) The hostname on the origin for which the client certificate uploaded will be used.
            id: (String) Identifier.
            issuer: (String) The certificate authority that issued the certificate.
            private_key: (String, Sensitive) The hostname certificate's private key.
            serial_number: (String) The serial number on the uploaded certificate.
            signature: (String) The type of hash used for the certificate.
            status: |-
                (String) Status of the certificate or the association.
                Available values: "initializing", "pending_deployment", "pending_deletion", "active", "deleted", "deployment_timed_out", "deletion_timed_out".
            updated_at: (String) The time when the certificate was updated.
            zone_id: (String) Identifier.
        importStatements: []
    cloudflare_authenticated_origin_pulls_certificate:
        subCategory: ""
        name: cloudflare_authenticated_origin_pulls_certificate
        title: cloudflare_authenticated_origin_pulls_certificate Resource - Cloudflare
        examples:
            - name: example_authenticated_origin_pulls_certificate
              manifest: |-
                {
                  "certificate": "  -----BEGIN CERTIFICATE-----\n  MIIDtTCCAp2gAwIBAgIJAMHAwfXZ5/PWMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n  BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX\n  aWRnaXRzIFB0eSBMdGQwHhcNMTYwODI0MTY0MzAxWhcNMTYxMTIyMTY0MzAxWjBF\n  MQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50\n  ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n  CgKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmGdtcGbg/1\n  CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKnabIRuGvB\n  KwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpidtnKX/a+5\n  0GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+pyFxIXjbEI\n  dZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pEewooaeO2\n  izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABo4GnMIGkMB0GA1UdDgQWBBT/LbE4\n  9rWf288N6sJA5BRb6FJIGDB1BgNVHSMEbjBsgBT/LbE49rWf288N6sJA5BRb6FJI\n  GKFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV\n  BAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAMHAwfXZ5/PWMAwGA1UdEwQF\n  MAMBAf8wDQYJKoZIhvcNAQELBQADggEBAHHFwl0tH0quUYZYO0dZYt4R7SJ0pCm2\n  2satiyzHl4OnXcHDpekAo7/a09c6Lz6AU83cKy/+x3/djYHXWba7HpEu0dR3ugQP\n  Mlr4zrhd9xKZ0KZKiYmtJH+ak4OM4L3FbT0owUZPyjLSlhMtJVcoRp5CJsjAMBUG\n  SvD8RX+T01wzox/Qb+lnnNnOlaWpqu8eoOenybxKp1a9ULzIVvN/LAcc+14vioFq\n  2swRWtmocBAs8QR9n4uvbpiYvS8eYueDCWMM4fvFfBhaDZ3N9IbtySh3SpFdQDhw\n  YbjM2rxXiyLGxB4Bol7QTv4zHif7Zt89FReT/NBy4rzaskDJY5L6xmY=\n  -----END CERTIFICATE-----\n\n",
                  "private_key": "  -----BEGIN RSA PRIVATE KEY-----\n  MIIEowIBAAKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmG\n  dtcGbg/1CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKn\n  abIRuGvBKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpid\n  tnKX/a+50GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+py\n  FxIXjbEIdZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pE\n  ewooaeO2izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABAoIBACbhTYXBZYKmYPCb\n  HBR1IBlCQA2nLGf0qRuJNJZg5iEzXows/6tc8YymZkQE7nolapWsQ+upk2y5Xdp/\n  axiuprIs9JzkYK8Ox0r+dlwCG1kSW+UAbX0bQ/qUqlsTvU6muVuMP8vZYHxJ3wmb\n  +ufRBKztPTQ/rYWaYQcgC0RWI20HTFBMxlTAyNxYNWzX7RKFkGVVyB9RsAtmcc8g\n  +j4OdosbfNoJPS0HeIfNpAznDfHKdxDk2Yc1tV6RHBrC1ynyLE9+TaflIAdo2MVv\n  KLMLq51GqYKtgJFIlBRPQqKoyXdz3fGvXrTkf/WY9QNq0J1Vk5ERePZ54mN8iZB7\n  9lwy/AkCgYEA6FXzosxswaJ2wQLeoYc7ceaweX/SwTvxHgXzRyJIIT0eJWgx13Wo\n  /WA3Iziimsjf6qE+SI/8laxPp2A86VMaIt3Z3mJN/CqSVGw8LK2AQst+OwdPyDMu\n  iacE8lj/IFGC8mwNUAb9CzGU3JpU4PxxGFjS/eMtGeRXCWkK4NE+G08CgYEA1Kp9\n  N2JrVlqUz+gAX+LPmE9OEMAS9WQSQsfCHGogIFDGGcNf7+uwBM7GAaSJIP01zcoe\n  VAgWdzXCv3FLhsaZoJ6RyLOLay5phbu1iaTr4UNYm5WtYTzMzqh8l1+MFFDl9xDB\n  vULuCIIrglM5MeS/qnSg1uMoH2oVPj9TVst/ir8CgYEAxrI7Ws9Zc4Bt70N1As+U\n  lySjaEVZCMkqvHJ6TCuVZFfQoE0r0whdLdRLU2PsLFP+q7qaeZQqgBaNSKeVcDYR\n  9B+nY/jOmQoPewPVsp/vQTCnE/R81spu0mp0YI6cIheT1Z9zAy322svcc43JaWB7\n  mEbeqyLOP4Z4qSOcmghZBSECgYACvR9Xs0DGn+wCsW4vze/2ei77MD4OQvepPIFX\n  dFZtlBy5ADcgE9z0cuVB6CiL8DbdK5kwY9pGNr8HUCI03iHkW6Zs+0L0YmihfEVe\n  PG19PSzK9CaDdhD9KFZSbLyVFmWfxOt50H7YRTTiPMgjyFpfi5j2q348yVT0tEQS\n  fhRqaQKBgAcWPokmJ7EbYQGeMbS7HC8eWO/RyamlnSffdCdSc7ue3zdVJxpAkQ8W\n  qu80pEIF6raIQfAf8MXiiZ7auFOSnHQTXUbhCpvDLKi0Mwq3G8Pl07l+2s6dQG6T\n  lv6XTQaMyf6n1yjzL+fzDrH3qXMxHMO/b13EePXpDMpY7HQpoLDi\n  -----END RSA PRIVATE KEY-----\n\n",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            certificate: (String) The zone's leaf certificate.
            certificate_id: (String) Identifier.
            enabled: (Boolean) Indicates whether zone-level authenticated origin pulls is enabled.
            expires_on: (String) When the certificate from the authority expires.
            id: (String) Identifier.
            issuer: (String) The certificate authority that issued the certificate.
            private_key: (String, Sensitive) The zone's private key.
            signature: (String) The type of hash used for the certificate.
            status: |-
                (String) Status of the certificate activation.
                Available values: "initializing", "pending_deployment", "pending_deletion", "active", "deleted", "deployment_timed_out", "deletion_timed_out".
            uploaded_on: (String) This is the time the certificate was uploaded.
            zone_id: (String) Identifier.
        importStatements: []
    cloudflare_authenticated_origin_pulls_settings:
        subCategory: ""
        name: cloudflare_authenticated_origin_pulls_settings
        title: cloudflare_authenticated_origin_pulls_settings Resource - Cloudflare
        examples:
            - name: example_authenticated_origin_pulls_settings
              manifest: |-
                {
                  "enabled": true,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            enabled: (Boolean) Indicates whether zone-level authenticated origin pulls is enabled.
            zone_id: (String) Identifier.
        importStatements: []
    cloudflare_bot_management:
        subCategory: ""
        name: cloudflare_bot_management
        title: cloudflare_bot_management Resource - Cloudflare
        examples:
            - name: example_bot_management
              manifest: |-
                {
                  "ai_bots_protection": "block",
                  "cf_robots_variant": "policy_only",
                  "crawler_protection": "enabled",
                  "enable_js": true,
                  "fight_mode": true,
                  "is_robots_txt_managed": false,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            ai_bots_protection: |-
                (String) Enable rule to block AI Scrapers and Crawlers. Please note the value only_on_ad_pages is currently not available for Enterprise customers.
                Available values: "block", "disabled", "only_on_ad_pages".
            auto_update_model: (Boolean) Automatically update to the newest bot detection models created by Cloudflare as they are released. Learn more.
            bm_cookie_enabled: (Boolean) Indicates that the bot management cookie can be placed on end user devices accessing the site. Defaults to true
            cf_robots_variant: |-
                (String) Specifies the Robots Access Control License variant to use.
                Available values: "off", "policy_only".
            crawler_protection: |-
                (String) Enable rule to punish AI Scrapers and Crawlers via a link maze.
                Available values: "enabled", "disabled".
            enable_js: (Boolean) Use lightweight, invisible JavaScript detections to improve Bot Management. Learn more about JavaScript Detections.
            fight_mode: (Boolean) Whether to enable Bot Fight Mode.
            id: (String) Identifier.
            is_robots_txt_managed: (Boolean) Enable cloudflare managed robots.txt. If an existing robots.txt is detected, then managed robots.txt will be prepended to the existing robots.txt.
            optimize_wordpress: (Boolean) Whether to optimize Super Bot Fight Mode protections for Wordpress.
            sbfm_definitely_automated: |-
                (String) Super Bot Fight Mode (SBFM) action to take on definitely automated requests.
                Available values: "allow", "block", "managed_challenge".
            sbfm_likely_automated: |-
                (String) Super Bot Fight Mode (SBFM) action to take on likely automated requests.
                Available values: "allow", "block", "managed_challenge".
            sbfm_static_resource_protection: |-
                (Boolean) Super Bot Fight Mode (SBFM) to enable static resource protection.
                Enable if static resources on your application need bot protection.
                Note: Static resource protection can also result in legitimate traffic being blocked.
            sbfm_verified_bots: |-
                (String) Super Bot Fight Mode (SBFM) action to take on verified bots requests.
                Available values: "allow", "block".
            stale_zone_configuration: (Attributes) A read-only field that shows which unauthorized settings are currently active on the zone. These settings typically result from upgrades or downgrades. (see below for nested schema)
            suppress_session_score: (Boolean) Whether to disable tracking the highest bot score for a session in the Bot Management cookie.
            using_latest_model: (Boolean) A read-only field that indicates whether the zone currently is running the latest ML model.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_bot_management.example '<zone_id>'
    cloudflare_byo_ip_prefix:
        subCategory: ""
        name: cloudflare_byo_ip_prefix
        title: cloudflare_byo_ip_prefix Resource - Cloudflare
        examples:
            - name: example_byo_ip_prefix
              manifest: |-
                {
                  "account_id": "258def64c72dae45f3e4c8516e2111f2",
                  "asn": 13335,
                  "cidr": "192.0.2.0/24",
                  "delegate_loa_creation": true,
                  "description": "Internal test prefix",
                  "loa_document_id": "d933b1530bc56c9953cf8ce166da8004"
                }
        argumentDocs:
            account_id: (String) Identifier of a Cloudflare account.
            advertised: (Boolean, Deprecated) Prefix advertisement status to the Internet. This field is only not 'null' if on demand is enabled.
            advertised_modified_at: (String, Deprecated) Last time the advertisement status was changed. This field is only not 'null' if on demand is enabled.
            approved: (String) Approval state of the prefix (P = pending, V = active).
            asn: (Number) Autonomous System Number (ASN) the prefix will be advertised under.
            cidr: (String) IP Prefix in Classless Inter-Domain Routing format.
            created_at: (String)
            delegate_loa_creation: (Boolean) Whether Cloudflare is allowed to generate the LOA document on behalf of the prefix owner.
            description: (String) Description of the prefix.
            id: (String) Identifier of an IP Prefix.
            irr_validation_state: (String) State of one kind of validation for an IP prefix.
            loa_document_id: (String) Identifier for the uploaded LOA document.
            modified_at: (String)
            on_demand_enabled: (Boolean, Deprecated) Whether advertisement of the prefix to the Internet may be dynamically enabled or disabled.
            on_demand_locked: (Boolean, Deprecated) Whether advertisement status of the prefix is locked, meaning it cannot be changed.
            ownership_validation_state: (String) State of one kind of validation for an IP prefix.
            ownership_validation_token: (String) Token provided to demonstrate ownership of the prefix.
            rpki_validation_state: (String) State of one kind of validation for an IP prefix.
        importStatements:
            - $ terraform import cloudflare_byo_ip_prefix.example '<account_id>/<prefix_id>'
    cloudflare_calls_sfu_app:
        subCategory: ""
        name: cloudflare_calls_sfu_app
        title: cloudflare_calls_sfu_app Resource - Cloudflare
        examples:
            - name: example_calls_sfu_app
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "production-realtime-app"
                }
        argumentDocs:
            account_id: (String) The account identifier tag.
            app_id: (String) A Cloudflare-generated unique identifier for a item.
            created: (String) The date and time the item was created.
            modified: (String) The date and time the item was last modified.
            name: (String) A short description of Calls app, not shown to end users.
            secret: (String, Sensitive) Bearer token
            uid: (String) A Cloudflare-generated unique identifier for a item.
        importStatements: []
    cloudflare_calls_turn_app:
        subCategory: ""
        name: cloudflare_calls_turn_app
        title: cloudflare_calls_turn_app Resource - Cloudflare
        examples:
            - name: example_calls_turn_app
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "my-turn-key"
                }
        argumentDocs:
            account_id: (String) The account identifier tag.
            created: (String) The date and time the item was created.
            key: (String, Sensitive) Bearer token
            key_id: (String) A Cloudflare-generated unique identifier for a item.
            modified: (String) The date and time the item was last modified.
            name: (String) A short description of a TURN key, not shown to end users.
            uid: (String) A Cloudflare-generated unique identifier for a item.
        importStatements: []
    cloudflare_certificate_pack:
        subCategory: ""
        name: cloudflare_certificate_pack
        title: cloudflare_certificate_pack Resource - Cloudflare
        examples:
            - name: example_certificate_pack
              manifest: |-
                {
                  "certificate_authority": "lets_encrypt",
                  "cloudflare_branding": false,
                  "hosts": [
                    "example.com",
                    "*.example.com",
                    "www.example.com"
                  ],
                  "type": "advanced",
                  "validation_method": "txt",
                  "validity_days": 14,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            bundle_method: (String) Certificate bundle method.
            certificate_authority: |-
                (String) Certificate Authority selected for the order.  For information on any certificate authority specific details or restrictions see this page for more details.
                Available values: "google", "lets_encrypt", "ssl_com".
            certificates: (Attributes List) Array of certificates in this pack. (see below for nested schema)
            cloudflare_branding: (Boolean) Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true.
            emails: (List of String) The set of email addresses that the certificate authority (CA) will use to complete domain validation.
            expires_on: (String) When the certificate from the authority expires.
            geo_restrictions: (Attributes) Specify the region where your private key can be held locally. (see below for nested schema)
            hosts: (Set of String) Comma separated list of valid host names for the certificate packs. Must contain the zone apex, may not contain more than 50 hosts, and may not be empty.
            http_body: (String) The content that the certificate authority (CA) will expect to find at the http_url during the domain validation.
            http_url: (String) The url that will be checked during domain validation.
            id: (String) Identifier.
            issuer: (String) The certificate authority that issued the certificate.
            label: '(String) Available values: "us", "eu", "highest_security".'
            message: (String) A domain validation error.
            modified_on: (String) When the certificate was last modified.
            primary_certificate: (String) Identifier of the primary certificate in a pack.
            priority: (Number) The order/priority in which the certificate will be used.
            signature: (String) The type of hash used for the certificate.
            status: |-
                (String) Status of certificate pack.
                Available values: "initializing", "pending_validation", "deleted", "pending_issuance", "pending_deployment", "pending_deletion", "pending_expiration", "expired", "active", "initializing_timed_out", "validation_timed_out", "issuance_timed_out", "deployment_timed_out", "deletion_timed_out", "pending_cleanup", "staging_deployment", "staging_active", "deactivating", "inactive", "backup_issued", "holding_deployment".
            txt_name: (String) The hostname that the certificate authority (CA) will check for a TXT record during domain validation .
            txt_value: (String) The TXT record that the certificate authority (CA) will check during domain validation.
            type: |-
                (String) Type of certificate pack.
                Available values: "advanced".
            uploaded_on: (String) When the certificate was uploaded to Cloudflare.
            validation_errors: (Attributes List) Domain validation errors that have been received by the certificate authority (CA). (see below for nested schema)
            validation_method: |-
                (String) Validation Method selected for the order.
                Available values: "txt", "http", "email".
            validation_records: (Attributes List) Certificates' validation records. (see below for nested schema)
            validity_days: |-
                (Number) Validity Days selected for the order.
                Available values: 14, 30, 90, 365.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_certificate_pack.example '<zone_id>/<certificate_pack_id>'
    cloudflare_cloud_connector_rules:
        subCategory: ""
        name: cloudflare_cloud_connector_rules
        title: cloudflare_cloud_connector_rules Resource - Cloudflare
        examples:
            - name: example_cloud_connector_rules
              manifest: |-
                {
                  "rules": [
                    {
                      "cloud_connector_rules_provider": "aws_s3",
                      "description": "Rule description",
                      "enabled": true,
                      "expression": "http.cookie eq \"a=b\"",
                      "id": "95c365e17e1b46599cd99e5b231fac4e",
                      "parameters": {
                        "host": "examplebucket.s3.eu-north-1.amazonaws.com"
                      }
                    }
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            description: (String)
            enabled: (Boolean)
            expression: (String)
            host: (String) Host to perform Cloud Connection to
            id: (String) Identifier.
            parameters: (Attributes) Parameters of Cloud Connector Rule (see below for nested schema)
            provider: |-
                (String) Cloud Provider type
                Available values: "aws_s3", "cloudflare_r2", "gcp_storage", "azure_storage".
            rules: (Attributes List) (see below for nested schema)
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_cloud_connector_rules.example '<zone_id>'
    cloudflare_cloudforce_one_request:
        subCategory: ""
        name: cloudflare_cloudforce_one_request
        title: cloudflare_cloudforce_one_request Resource - Cloudflare
        examples:
            - name: example_cloudforce_one_request
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "content": "What regions were most effected by the recent DoS?",
                  "priority": "routine",
                  "request_type": "Victomology",
                  "summary": "DoS attack",
                  "tlp": "clear"
                }
        argumentDocs:
            account_id: (String) Identifier.
            completed: (String)
            content: (String) Request content.
            created: (String)
            id: (String) UUID.
            message_tokens: (Number) Tokens for the request messages.
            priority: (String) Priority for analyzing the request.
            readable_id: (String) Readable Request ID.
            request: (String) Requested information from request.
            request_type: (String) Requested information from request.
            status: |-
                (String) Request Status.
                Available values: "open", "accepted", "reported", "approved", "completed", "declined".
            summary: (String) Brief description of the request.
            tlp: |-
                (String) The CISA defined Traffic Light Protocol (TLP).
                Available values: "clear", "amber", "amber-strict", "green", "red".
            tokens: (Number) Tokens for the request.
            updated: (String)
        importStatements:
            - $ terraform import cloudflare_cloudforce_one_request.example '<account_id>/<request_id>'
    cloudflare_cloudforce_one_request_asset:
        subCategory: ""
        name: cloudflare_cloudforce_one_request_asset
        title: cloudflare_cloudforce_one_request_asset Resource - Cloudflare
        examples:
            - name: example_cloudforce_one_request_asset
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "page": 0,
                  "per_page": 10,
                  "request_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415"
                }
        argumentDocs:
            account_id: (String) Identifier.
            created: (String) Defines the asset creation time.
            description: (String) Asset description.
            file_type: (String) Asset file type.
            id: (Number) Asset ID.
            name: (String) Asset name.
            page: (Number) Page number of results.
            per_page: (Number) Number of results per page.
            request_id: (String) UUID.
            source: (String) Asset file to upload.
        importStatements:
            - $ terraform import cloudflare_cloudforce_one_request_asset.example '<account_id>/<request_id>/<asset_id>'
    cloudflare_cloudforce_one_request_message:
        subCategory: ""
        name: cloudflare_cloudforce_one_request_message
        title: cloudflare_cloudforce_one_request_message Resource - Cloudflare
        examples:
            - name: example_cloudforce_one_request_message
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "content": "Can you elaborate on the type of DoS that occurred?",
                  "request_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415"
                }
        argumentDocs:
            account_id: (String) Identifier.
            author: (String) Author of message.
            content: (String) Content of message.
            created: (String) Defines the message creation time.
            id: (Number) Message ID.
            is_follow_on_request: (Boolean) Whether the message is a follow-on request.
            request_id: (String) UUID.
            updated: (String) Defines the message last updated time.
        importStatements:
            - $ terraform import cloudflare_cloudforce_one_request_message.example '<account_id>/<request_id>/<page>/<per_page>'
    cloudflare_cloudforce_one_request_priority:
        subCategory: ""
        name: cloudflare_cloudforce_one_request_priority
        title: cloudflare_cloudforce_one_request_priority Resource - Cloudflare
        examples:
            - name: example_cloudforce_one_request_priority
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "labels": [
                    "DoS",
                    "CVE"
                  ],
                  "priority": 1,
                  "requirement": "DoS attacks carried out by CVEs",
                  "tlp": "clear"
                }
        argumentDocs:
            account_id: (String) Identifier.
            completed: (String)
            content: (String) Request content.
            created: (String)
            id: (String) UUID.
            labels: (List of String) List of labels.
            message_tokens: (Number) Tokens for the request messages.
            priority: (Number) Priority.
            readable_id: (String) Readable Request ID.
            request: (String) Requested information from request.
            requirement: (String) Requirement.
            status: |-
                (String) Request Status.
                Available values: "open", "accepted", "reported", "approved", "completed", "declined".
            summary: (String) Brief description of the request.
            tlp: |-
                (String) The CISA defined Traffic Light Protocol (TLP).
                Available values: "clear", "amber", "amber-strict", "green", "red".
            tokens: (Number) Tokens for the request.
            updated: (String)
        importStatements:
            - $ terraform import cloudflare_cloudforce_one_request_priority.example '<account_id>/<priority_id>'
    cloudflare_connectivity_directory_service:
        subCategory: ""
        name: cloudflare_connectivity_directory_service
        title: cloudflare_connectivity_directory_service Resource - Cloudflare
        examples:
            - name: example_connectivity_directory_service
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "host": {
                    "hostname": "api.example.com",
                    "resolver_network": {
                      "resolver_ips": [
                        "string"
                      ],
                      "tunnel_id": "0191dce4-9ab4-7fce-b660-8e5dec5172da"
                    }
                  },
                  "http_port": 8080,
                  "https_port": 8443,
                  "name": "web-server",
                  "type": "http"
                }
        argumentDocs:
            account_id: (String) Account identifier
            created_at: (String)
            host: (Attributes) (see below for nested schema)
            hostname: (String)
            http_port: (Number)
            https_port: (Number)
            id: (String) The ID of this resource.
            ipv4: (String)
            ipv6: (String)
            name: (String)
            network: (Attributes) (see below for nested schema)
            resolver_ips: (List of String)
            resolver_network: (Attributes) (see below for nested schema)
            service_id: (String)
            tunnel_id: (String)
            type: '(String) Available values: "http".'
            updated_at: (String)
        importStatements:
            - $ terraform import cloudflare_connectivity_directory_service.example '<account_id>/<service_id>'
    cloudflare_content_scanning:
        subCategory: ""
        name: cloudflare_content_scanning
        title: cloudflare_content_scanning Resource - Cloudflare
        examples:
            - name: example_content_scanning
              manifest: |-
                {
                  "value": "enabled",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            modified: (String) Defines the last modification date (ISO 8601) of the Content Scanning status.
            value: |-
                (String) The status value for Content Scanning.
                Available values: "enabled", "disabled".
            zone_id: (String) Defines an identifier.
        importStatements: []
    cloudflare_content_scanning_expression:
        subCategory: ""
        name: cloudflare_content_scanning_expression
        title: cloudflare_content_scanning_expression Resource - Cloudflare
        examples:
            - name: example_content_scanning_expression
              manifest: |-
                {
                  "body": [
                    {
                      "payload": "lookup_json_string(http.request.body.raw, \"file\")"
                    }
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            body: (Attributes List) (see below for nested schema)
            id: (String) defines the unique ID for this custom scan expression.
            payload: (String) Defines the ruleset expression to use in matching content objects.
            zone_id: (String) Defines an identifier.
        importStatements: []
    cloudflare_custom_hostname:
        subCategory: ""
        name: cloudflare_custom_hostname
        title: cloudflare_custom_hostname Resource - Cloudflare
        examples:
            - name: example_custom_hostname
              manifest: |-
                {
                  "custom_metadata": {
                    "foo": "string"
                  },
                  "hostname": "app.example.com",
                  "ssl": {
                    "bundle_method": "ubiquitous",
                    "certificate_authority": "google",
                    "cloudflare_branding": false,
                    "custom_cert_bundle": [
                      {
                        "custom_certificate": "      -----BEGIN CERTIFICATE-----\n      MIIDdjCCAl6gAwIBAgIJAPnMg0Fs+/B0MA0GCSqGSIb3DQEBCwUAMFsx...\n      -----END CERTIFICATE-----\n\n",
                        "custom_key": "      -----BEGIN PRIVATE KEY-----\n      MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQC/SCB5...\n      -----END PRIVATE KEY-----\n\n"
                      }
                    ],
                    "custom_certificate": "-----BEGIN CERTIFICATE-----\\nMIIFJDCCBAygAwIBAgIQD0ifmj/Yi5NP/2gdUySbfzANBgkqhkiG9w0BAQsFADBN\\nMQswCQYDVQQGEwJVUzEVMBMGA1UEChMMRGlnaUNlcnQgSW5jMScwJQYDVQQDEx5E...SzSHfXp5lnu/3V08I72q1QNzOCgY1XeL4GKVcj4or6cT6tX6oJH7ePPmfrBfqI/O\\nOeH8gMJ+FuwtXYEPa4hBf38M5eU5xWG7\\n-----END CERTIFICATE-----\\n",
                    "custom_key": "    -----BEGIN RSA PRIVATE KEY-----\n    MIIEowIBAAKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmG\n    dtcGbg/1CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKn\n    abIRuGvBKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpid\n    tnKX/a+50GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+py\n    FxIXjbEIdZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pE\n    ewooaeO2izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABAoIBACbhTYXBZYKmYPCb\n    HBR1IBlCQA2nLGf0qRuJNJZg5iEzXows/6tc8YymZkQE7nolapWsQ+upk2y5Xdp/\n    axiuprIs9JzkYK8Ox0r+dlwCG1kSW+UAbX0bQ/qUqlsTvU6muVuMP8vZYHxJ3wmb\n    +ufRBKztPTQ/rYWaYQcgC0RWI20HTFBMxlTAyNxYNWzX7RKFkGVVyB9RsAtmcc8g\n    +j4OdosbfNoJPS0HeIfNpAznDfHKdxDk2Yc1tV6RHBrC1ynyLE9+TaflIAdo2MVv\n    KLMLq51GqYKtgJFIlBRPQqKoyXdz3fGvXrTkf/WY9QNq0J1Vk5ERePZ54mN8iZB7\n    9lwy/AkCgYEA6FXzosxswaJ2wQLeoYc7ceaweX/SwTvxHgXzRyJIIT0eJWgx13Wo\n    /WA3Iziimsjf6qE+SI/8laxPp2A86VMaIt3Z3mJN/CqSVGw8LK2AQst+OwdPyDMu\n    iacE8lj/IFGC8mwNUAb9CzGU3JpU4PxxGFjS/eMtGeRXCWkK4NE+G08CgYEA1Kp9\n    N2JrVlqUz+gAX+LPmE9OEMAS9WQSQsfCHGogIFDGGcNf7+uwBM7GAaSJIP01zcoe\n    VAgWdzXCv3FLhsaZoJ6RyLOLay5phbu1iaTr4UNYm5WtYTzMzqh8l1+MFFDl9xDB\n    vULuCIIrglM5MeS/qnSg1uMoH2oVPj9TVst/ir8CgYEAxrI7Ws9Zc4Bt70N1As+U\n    lySjaEVZCMkqvHJ6TCuVZFfQoE0r0whdLdRLU2PsLFP+q7qaeZQqgBaNSKeVcDYR\n    9B+nY/jOmQoPewPVsp/vQTCnE/R81spu0mp0YI6cIheT1Z9zAy322svcc43JaWB7\n    mEbeqyLOP4Z4qSOcmghZBSECgYACvR9Xs0DGn+wCsW4vze/2ei77MD4OQvepPIFX\n    dFZtlBy5ADcgE9z0cuVB6CiL8DbdK5kwY9pGNr8HUCI03iHkW6Zs+0L0YmihfEVe\n    PG19PSzK9CaDdhD9KFZSbLyVFmWfxOt50H7YRTTiPMgjyFpfi5j2q348yVT0tEQS\n    fhRqaQKBgAcWPokmJ7EbYQGeMbS7HC8eWO/RyamlnSffdCdSc7ue3zdVJxpAkQ8W\n    qu80pEIF6raIQfAf8MXiiZ7auFOSnHQTXUbhCpvDLKi0Mwq3G8Pl07l+2s6dQG6T\n    lv6XTQaMyf6n1yjzL+fzDrH3qXMxHMO/b13EePXpDMpY7HQpoLDi\n    -----END RSA PRIVATE KEY-----\n\n",
                    "method": "http",
                    "settings": {
                      "ciphers": [
                        "ECDHE-RSA-AES128-GCM-SHA256",
                        "AES128-SHA"
                      ],
                      "early_hints": "on",
                      "http2": "on",
                      "min_tls_version": "1.2",
                      "tls_1_3": "on"
                    },
                    "type": "dv",
                    "wildcard": false
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            bundle_method: |-
                (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
                Available values: "ubiquitous", "optimal", "force".
            certificate_authority: |-
                (String) The Certificate Authority that will issue the certificate
                Available values: "digicert", "google", "lets_encrypt", "ssl_com".
            ciphers: (List of String) An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
            cloudflare_branding: (Boolean) Whether or not to add Cloudflare Branding for the order.  This will add a subdomain of sni.cloudflaressl.com as the Common Name if set to true
            created_at: (String) This is the time the hostname was created.
            custom_cert_bundle: (Attributes List) Array of custom certificate and key pairs (1 or 2 pairs allowed) (see below for nested schema)
            custom_certificate: (String) If a custom uploaded certificate is used.
            custom_key: (String, Sensitive) The key for a custom uploaded certificate.
            custom_metadata: (Map of String) Unique key/value metadata for this hostname. These are per-hostname (customer) settings.
            custom_origin_server: (String) a valid hostname thats been added to your DNS zone as an A, AAAA, or CNAME record.
            custom_origin_sni: (String) A hostname that will be sent to your custom origin server as SNI for TLS handshake. This can be a valid subdomain of the zone or custom origin server name or the string ':request_host_header:' which will cause the host header in the request to be used as SNI. Not configurable with default/fallback origin server.
            early_hints: |-
                (String) Whether or not Early Hints is enabled.
                Available values: "on", "off".
            hostname: (String) The custom hostname that will point to your hostname via CNAME.
            http_body: (String) Token to be served.
            http_url: (String) The HTTP URL that will be checked during custom hostname verification and where the customer should host the token.
            http2: |-
                (String) Whether or not HTTP2 is enabled.
                Available values: "on", "off".
            id: (String) Identifier.
            method: |-
                (String) Domain control validation (DCV) method used for this hostname.
                Available values: "http", "txt", "email".
            min_tls_version: |-
                (String) The minimum TLS version supported.
                Available values: "1.0", "1.1", "1.2", "1.3".
            name: (String) DNS Name for record.
            ownership_verification: (Attributes) This is a record which can be placed to activate a hostname. (see below for nested schema)
            ownership_verification_http: (Attributes) This presents the token to be served by the given http url to activate a hostname. (see below for nested schema)
            settings: (Attributes) SSL specific settings. (see below for nested schema)
            ssl: (Attributes) SSL properties used when creating the custom hostname. (see below for nested schema)
            status: |-
                (String) Status of the hostname's activation.
                Available values: "active", "pending", "active_redeploying", "moved", "pending_deletion", "deleted", "pending_blocked", "pending_migration", "pending_provisioned", "test_pending", "test_active", "test_active_apex", "test_blocked", "test_failed", "provisioned", "blocked".
            tls_1_3: |-
                (String) Whether or not TLS 1.3 is enabled.
                Available values: "on", "off".
            type: |-
                (String) Level of validation to be used for this hostname. Domain validation (dv) must be used.
                Available values: "dv".
            value: (String) Content for the record.
            verification_errors: (List of String) These are errors that were encountered while trying to activate a hostname.
            wildcard: (Boolean) Indicates whether the certificate covers a wildcard.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_custom_hostname.example '<zone_id>/<custom_hostname_id>'
    cloudflare_custom_hostname_fallback_origin:
        subCategory: ""
        name: cloudflare_custom_hostname_fallback_origin
        title: cloudflare_custom_hostname_fallback_origin Resource - Cloudflare
        examples:
            - name: example_custom_hostname_fallback_origin
              manifest: |-
                {
                  "origin": "fallback.example.com",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            created_at: (String) This is the time the fallback origin was created.
            errors: (List of String) These are errors that were encountered while trying to activate a fallback origin.
            id: (String) Identifier.
            origin: (String) Your origin hostname that requests to your custom hostnames will be sent to.
            status: |-
                (String) Status of the fallback origin's activation.
                Available values: "initializing", "pending_deployment", "pending_deletion", "active", "deployment_timed_out", "deletion_timed_out".
            updated_at: (String) This is the time the fallback origin was updated.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_custom_hostname_fallback_origin.example '<zone_id>'
    cloudflare_custom_pages:
        subCategory: ""
        name: cloudflare_custom_pages
        title: cloudflare_custom_pages Resource - Cloudflare
        examples:
            - name: example_custom_pages
              manifest: |-
                {
                  "identifier": "ratelimit_block",
                  "state": "default",
                  "url": "http://www.example.com",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            created_on: (String)
            description: (String)
            id: |-
                (String) Error Page Types
                Available values: "1000_errors", "500_errors", "basic_challenge", "country_challenge", "ip_block", "managed_challenge", "ratelimit_block", "under_attack", "waf_block", "waf_challenge".
            identifier: |-
                (String) Error Page Types
                Available values: "1000_errors", "500_errors", "basic_challenge", "country_challenge", "ip_block", "managed_challenge", "ratelimit_block", "under_attack", "waf_block", "waf_challenge".
            modified_on: (String)
            preview_target: (String)
            required_tokens: (List of String)
            state: |-
                (String) The custom page state.
                Available values: "default", "customized".
            url: (String) The URL associated with the custom page.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_custom_pages.example '<{accounts|zones}/{account_id|zone_id}>/<identifier>'
    cloudflare_custom_ssl:
        subCategory: ""
        name: cloudflare_custom_ssl
        title: cloudflare_custom_ssl Resource - Cloudflare
        examples:
            - name: example_custom_ssl
              manifest: |-
                {
                  "bundle_method": "ubiquitous",
                  "certificate": "  -----BEGIN CERTIFICATE-----\n  MIIDtTCCAp2gAwIBAgIJAMHAwfXZ5/PWMA0GCSqGSIb3DQEBCwUAMEUxCzAJBgNV\n  BAYTAkFVMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX\n  aWRnaXRzIFB0eSBMdGQwHhcNMTYwODI0MTY0MzAxWhcNMTYxMTIyMTY0MzAxWjBF\n  MQswCQYDVQQGEwJBVTETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50\n  ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB\n  CgKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmGdtcGbg/1\n  CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKnabIRuGvB\n  KwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpidtnKX/a+5\n  0GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+pyFxIXjbEI\n  dZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pEewooaeO2\n  izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABo4GnMIGkMB0GA1UdDgQWBBT/LbE4\n  9rWf288N6sJA5BRb6FJIGDB1BgNVHSMEbjBsgBT/LbE49rWf288N6sJA5BRb6FJI\n  GKFJpEcwRTELMAkGA1UEBhMCQVUxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV\n  BAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAMHAwfXZ5/PWMAwGA1UdEwQF\n  MAMBAf8wDQYJKoZIhvcNAQELBQADggEBAHHFwl0tH0quUYZYO0dZYt4R7SJ0pCm2\n  2satiyzHl4OnXcHDpekAo7/a09c6Lz6AU83cKy/+x3/djYHXWba7HpEu0dR3ugQP\n  Mlr4zrhd9xKZ0KZKiYmtJH+ak4OM4L3FbT0owUZPyjLSlhMtJVcoRp5CJsjAMBUG\n  SvD8RX+T01wzox/Qb+lnnNnOlaWpqu8eoOenybxKp1a9ULzIVvN/LAcc+14vioFq\n  2swRWtmocBAs8QR9n4uvbpiYvS8eYueDCWMM4fvFfBhaDZ3N9IbtySh3SpFdQDhw\n  YbjM2rxXiyLGxB4Bol7QTv4zHif7Zt89FReT/NBy4rzaskDJY5L6xmY=\n  -----END CERTIFICATE-----\n\n",
                  "geo_restrictions": {
                    "label": "us"
                  },
                  "policy": "(country: US) or (region: EU)",
                  "private_key": "  -----BEGIN RSA PRIVATE KEY-----\n  MIIEowIBAAKCAQEAwQHoetcl9+5ikGzV6cMzWtWPJHqXT3wpbEkRU9Yz7lgvddmG\n  dtcGbg/1CGZu0jJGkMoppoUo4c3dts3iwqRYmBikUP77wwY2QGmDZw2FvkJCJlKn\n  abIRuGvBKwzESIXgKk2016aTP6/dAjEHyo6SeoK8lkIySUvK0fyOVlsiEsCmOpid\n  tnKX/a+50GjB79CJH4ER2lLVZnhePFR/zUOyPxZQQ4naHf7yu/b5jhO0f8fwt+py\n  FxIXjbEIdZliWRkRMtzrHOJIhrmJ2A1J7iOrirbbwillwjjNVUWPf3IJ3M12S9pE\n  ewooaeO2izNTERcG9HzAacbVRn2Y2SWIyT/18QIDAQABAoIBACbhTYXBZYKmYPCb\n  HBR1IBlCQA2nLGf0qRuJNJZg5iEzXows/6tc8YymZkQE7nolapWsQ+upk2y5Xdp/\n  axiuprIs9JzkYK8Ox0r+dlwCG1kSW+UAbX0bQ/qUqlsTvU6muVuMP8vZYHxJ3wmb\n  +ufRBKztPTQ/rYWaYQcgC0RWI20HTFBMxlTAyNxYNWzX7RKFkGVVyB9RsAtmcc8g\n  +j4OdosbfNoJPS0HeIfNpAznDfHKdxDk2Yc1tV6RHBrC1ynyLE9+TaflIAdo2MVv\n  KLMLq51GqYKtgJFIlBRPQqKoyXdz3fGvXrTkf/WY9QNq0J1Vk5ERePZ54mN8iZB7\n  9lwy/AkCgYEA6FXzosxswaJ2wQLeoYc7ceaweX/SwTvxHgXzRyJIIT0eJWgx13Wo\n  /WA3Iziimsjf6qE+SI/8laxPp2A86VMaIt3Z3mJN/CqSVGw8LK2AQst+OwdPyDMu\n  iacE8lj/IFGC8mwNUAb9CzGU3JpU4PxxGFjS/eMtGeRXCWkK4NE+G08CgYEA1Kp9\n  N2JrVlqUz+gAX+LPmE9OEMAS9WQSQsfCHGogIFDGGcNf7+uwBM7GAaSJIP01zcoe\n  VAgWdzXCv3FLhsaZoJ6RyLOLay5phbu1iaTr4UNYm5WtYTzMzqh8l1+MFFDl9xDB\n  vULuCIIrglM5MeS/qnSg1uMoH2oVPj9TVst/ir8CgYEAxrI7Ws9Zc4Bt70N1As+U\n  lySjaEVZCMkqvHJ6TCuVZFfQoE0r0whdLdRLU2PsLFP+q7qaeZQqgBaNSKeVcDYR\n  9B+nY/jOmQoPewPVsp/vQTCnE/R81spu0mp0YI6cIheT1Z9zAy322svcc43JaWB7\n  mEbeqyLOP4Z4qSOcmghZBSECgYACvR9Xs0DGn+wCsW4vze/2ei77MD4OQvepPIFX\n  dFZtlBy5ADcgE9z0cuVB6CiL8DbdK5kwY9pGNr8HUCI03iHkW6Zs+0L0YmihfEVe\n  PG19PSzK9CaDdhD9KFZSbLyVFmWfxOt50H7YRTTiPMgjyFpfi5j2q348yVT0tEQS\n  fhRqaQKBgAcWPokmJ7EbYQGeMbS7HC8eWO/RyamlnSffdCdSc7ue3zdVJxpAkQ8W\n  qu80pEIF6raIQfAf8MXiiZ7auFOSnHQTXUbhCpvDLKi0Mwq3G8Pl07l+2s6dQG6T\n  lv6XTQaMyf6n1yjzL+fzDrH3qXMxHMO/b13EePXpDMpY7HQpoLDi\n  -----END RSA PRIVATE KEY-----\n\n",
                  "type": "sni_custom",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            bundle_method: |-
                (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
                Available values: "ubiquitous", "optimal", "force".
            certificate: (String) The zone's SSL certificate or certificate and the intermediate(s).
            created_on: (String) When the Keyless SSL was created.
            enabled: (Boolean) Whether or not the Keyless SSL is on or off.
            expires_on: (String) When the certificate from the authority expires.
            geo_restrictions: (Attributes) Specify the region where your private key can be held locally for optimal TLS performance. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Options allow distribution to only to U.S. data centers, only to E.U. data centers, or only to highest security data centers. Default distribution is to all Cloudflare datacenters, for optimal performance. (see below for nested schema)
            host: (String) The keyless SSL name.
            hosts: (List of String)
            id: (String) Identifier.
            issuer: (String) The certificate authority that issued the certificate.
            keyless_server: (Attributes) (see below for nested schema)
            label: '(String) Available values: "us", "eu", "highest_security".'
            modified_on: (String) When the certificate was last modified.
            name: (String) The keyless SSL name.
            permissions: (List of String) Available permissions for the Keyless SSL for the current user requesting the item.
            policy: '(String) Specify the policy that determines the region where your private key will be held locally. HTTPS connections to any excluded data center will still be fully encrypted, but will incur some latency while Keyless SSL is used to complete the handshake with the nearest allowed data center. Any combination of countries, specified by their two letter country code (https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2#Officially_assigned_code_elements) can be chosen, such as ''country: IN'', as well as ''region: EU'' which refers to the EU region. If there are too few data centers satisfying the policy, it will be rejected.'
            port: (Number) The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
            priority: (Number) The order/priority in which the certificate will be used in a request. The higher priority will break ties across overlapping 'legacy_custom' certificates, but 'legacy_custom' certificates will always supercede 'sni_custom' certificates.
            private_ip: (String) Private IP of the Key Server Host
            private_key: (String, Sensitive) The zone's private key.
            signature: (String) The type of hash used for the certificate.
            status: |-
                (String) Status of the zone's custom SSL.
                Available values: "active", "expired", "deleted", "pending", "initializing".
            tunnel: (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
            type: |-
                (String) The type 'legacy_custom' enables support for legacy clients which do not include SNI in the TLS handshake.
                Available values: "legacy_custom", "sni_custom".
            uploaded_on: (String) When the certificate was uploaded to Cloudflare.
            vnet_id: (String) Cloudflare Tunnel Virtual Network ID
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_custom_ssl.example '<zone_id>/<custom_certificate_id>'
    cloudflare_d1_database:
        subCategory: ""
        name: cloudflare_d1_database
        title: cloudflare_d1_database Resource - Cloudflare
        examples:
            - name: example_d1_database
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "jurisdiction": "eu",
                  "name": "my-database",
                  "primary_location_hint": "wnam"
                }
        argumentDocs:
            account_id: (String) Account identifier tag.
            created_at: (String) Specifies the timestamp the resource was created as an ISO8601 string.
            file_size: (Number) The D1 database's size, in bytes.
            id: (String) D1 database identifier (UUID).
            jurisdiction: |-
                (String) Specify the location to restrict the D1 database to run and store data. If this option is present, the location hint is ignored.
                Available values: "eu", "fedramp".
            mode: |-
                (String) The read replication mode for the database. Use 'auto' to create replicas and allow D1 automatically place them around the world, or 'disabled' to not use any database replicas (it can take a few hours for all replicas to be deleted).
                Available values: "auto", "disabled".
            name: (String) D1 database name.
            num_tables: (Number)
            primary_location_hint: |-
                (String) Specify the region to create the D1 primary, if available. If this option is omitted, the D1 will be created as close as possible to the current user.
                Available values: "wnam", "enam", "weur", "eeur", "apac", "oc".
            read_replication: (Attributes) Configuration for D1 read replication. (see below for nested schema)
            uuid: (String) D1 database identifier (UUID).
            version: (String)
        importStatements:
            - $ terraform import cloudflare_d1_database.example '<account_id>/<database_id>'
    cloudflare_dns_firewall:
        subCategory: ""
        name: cloudflare_dns_firewall
        title: cloudflare_dns_firewall Resource - Cloudflare
        examples:
            - name: example_dns_firewall
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "attack_mitigation": {
                    "enabled": true,
                    "only_when_upstream_unhealthy": false
                  },
                  "deprecate_any_requests": true,
                  "ecs_fallback": false,
                  "maximum_cache_ttl": 900,
                  "minimum_cache_ttl": 60,
                  "name": "My Awesome DNS Firewall cluster",
                  "negative_cache_ttl": 900,
                  "ratelimit": 600,
                  "retries": 2,
                  "upstream_ips": [
                    "192.0.2.1",
                    "198.51.100.1",
                    "2001:DB8:100::CF"
                  ]
                }
        argumentDocs:
            account_id: (String) Identifier.
            attack_mitigation: (Attributes) Attack mitigation settings (see below for nested schema)
            deprecate_any_requests: (Boolean) Whether to refuse to answer queries for the ANY type
            dns_firewall_ips: (Set of String)
            ecs_fallback: (Boolean) Whether to forward client IP (resolver) subnet if no EDNS Client Subnet is sent
            enabled: (Boolean) When enabled, automatically mitigate random-prefix attacks to protect upstream DNS servers
            id: (String) Identifier.
            maximum_cache_ttl: |-
                (Number) By default, Cloudflare attempts to cache responses for as long as
                indicated by the TTL received from upstream nameservers. This setting
                sets an upper bound on this duration. For caching purposes, higher TTLs
                will be decreased to the maximum value defined by this setting.
            minimum_cache_ttl: |-
                (Number) By default, Cloudflare attempts to cache responses for as long as
                indicated by the TTL received from upstream nameservers. This setting
                sets a lower bound on this duration. For caching purposes, lower TTLs
                will be increased to the minimum value defined by this setting.
            modified_on: (String) Last modification of DNS Firewall cluster
            name: (String) DNS Firewall cluster name
            negative_cache_ttl: |-
                (Number) This setting controls how long DNS Firewall should cache negative
                responses (e.g., NXDOMAIN) from the upstream servers.
            only_when_upstream_unhealthy: (Boolean) Only mitigate attacks when upstream servers seem unhealthy
            ratelimit: (Number) Ratelimit in queries per second per datacenter (applies to DNS queries sent to the upstream nameservers configured on the cluster)
            retries: (Number) Number of retries for fetching DNS responses from upstream nameservers (not counting the initial attempt)
            upstream_ips: (Set of String)
        importStatements:
            - $ terraform import cloudflare_dns_firewall.example '<account_id>/<dns_firewall_id>'
    cloudflare_dns_record:
        subCategory: ""
        name: cloudflare_dns_record
        title: cloudflare_dns_record Resource - Cloudflare
        examples:
            - name: example_dns_record
              manifest: |-
                {
                  "comment": "Domain verification record",
                  "content": "198.51.100.4",
                  "name": "example.com",
                  "proxied": true,
                  "settings": {
                    "ipv4_only": true,
                    "ipv6_only": true
                  },
                  "tags": [
                    "owner:dns-team"
                  ],
                  "ttl": 3600,
                  "type": "A",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            algorithm: (Number) Algorithm.
            altitude: (Number) Altitude of location in meters.
            certificate: (String) Certificate.
            comment: (String) Comments or notes about the DNS record. This field has no effect on DNS responses.
            comment_modified_on: (String) When the record comment was last modified. Omitted if there is no comment.
            content: (String) A valid IPv4 address.
            created_on: (String) When the record was created.
            data: (Attributes) Components of a CAA record. (see below for nested schema)
            digest: (String) Digest.
            digest_type: (Number) Digest Type.
            fingerprint: (String) Fingerprint.
            flags: (Dynamic) Flags for the CAA record.
            flatten_cname: (Boolean) If enabled, causes the CNAME record to be resolved externally and the resulting address records (e.g., A and AAAA) to be returned instead of the CNAME record itself. This setting is unavailable for proxied records, since they are always flattened.
            id: (String) Identifier.
            ipv4_only: (Boolean) When enabled, only A records will be generated, and AAAA records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
            ipv6_only: (Boolean) When enabled, only AAAA records will be generated, and A records will not be created. This setting is intended for exceptional cases. Note that this option only applies to proxied records and it has no effect on whether Cloudflare communicates with the origin using IPv4 or IPv6.
            key_tag: (Number) Key Tag.
            lat_degrees: (Number) Degrees of latitude.
            lat_direction: |-
                (String) Latitude direction.
                Available values: "N", "S".
            lat_minutes: (Number) Minutes of latitude.
            lat_seconds: (Number) Seconds of latitude.
            long_degrees: (Number) Degrees of longitude.
            long_direction: |-
                (String) Longitude direction.
                Available values: "E", "W".
            long_minutes: (Number) Minutes of longitude.
            long_seconds: (Number) Seconds of longitude.
            matching_type: (Number) Matching Type.
            meta: (String) Extra Cloudflare-specific information about the record.
            modified_on: (String) When the record was last modified.
            name: (String) DNS record name (or @ for the zone apex) in Punycode.
            order: (Number) Order.
            port: (Number) The port of the service.
            precision_horz: (Number) Horizontal precision of location.
            precision_vert: (Number) Vertical precision of location.
            preference: (Number) Preference.
            priority: (Number) Required for MX, SRV and URI records; unused by other record types. Records with lower priorities are preferred.
            protocol: (Number) Protocol.
            proxiable: (Boolean) Whether the record can be proxied by Cloudflare or not.
            proxied: (Boolean) Whether the record is receiving the performance and security benefits of Cloudflare.
            public_key: (String) Public Key.
            regex: (String) Regex.
            replacement: (String) Replacement.
            selector: (Number) Selector.
            service: (String) Service.
            settings: (Attributes) Settings for the DNS record. (see below for nested schema)
            size: (Number) Size of location in meters.
            tag: '(String) Name of the property controlled by this record (e.g.: issue, issuewild, iodef).'
            tags: (Set of String) Custom tags for the DNS record. This field has no effect on DNS responses.
            tags_modified_on: (String) When the record tags were last modified. Omitted if there are no tags.
            target: (String) Target.
            ttl: (Number) Time To Live (TTL) of the DNS record in seconds. Setting to 1 means 'automatic'. Value must be between 60 and 86400, with the minimum reduced to 30 for Enterprise zones.
            type: |-
                (String) Record type.
                Available values: "A", "AAAA", "CNAME", "MX", "NS", "OPENPGPKEY", "PTR", "TXT", "CAA", "CERT", "DNSKEY", "DS", "HTTPS", "LOC", "NAPTR", "SMIMEA", "SRV", "SSHFP", "SVCB", "TLSA", "URI".
            usage: (Number) Usage.
            value: (String) Value of the record. This field's semantics depend on the chosen tag.
            weight: (Number) The record weight.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_dns_record.example '<zone_id>/<dns_record_id>'
    cloudflare_dns_zone_transfers_acl:
        subCategory: ""
        name: cloudflare_dns_zone_transfers_acl
        title: cloudflare_dns_zone_transfers_acl Resource - Cloudflare
        examples:
            - name: example_dns_zone_transfers_acl
              manifest: |-
                {
                  "account_id": "01a7362d577a6c3019a474fd6f485823",
                  "ip_range": "192.0.2.53/28",
                  "name": "my-acl-1"
                }
        argumentDocs:
            account_id: (String)
            id: (String) The ID of this resource.
            ip_range: (String) Allowed IPv4/IPv6 address range of primary or secondary nameservers. This will be applied for the entire account. The IP range is used to allow additional NOTIFY IPs for secondary zones and IPs Cloudflare allows AXFR/IXFR requests from for primary zones. CIDRs are limited to a maximum of /24 for IPv4 and /64 for IPv6 respectively.
            name: (String) The name of the acl.
        importStatements:
            - $ terraform import cloudflare_dns_zone_transfers_acl.example '<account_id>/<acl_id>'
    cloudflare_dns_zone_transfers_incoming:
        subCategory: ""
        name: cloudflare_dns_zone_transfers_incoming
        title: cloudflare_dns_zone_transfers_incoming Resource - Cloudflare
        examples:
            - name: example_dns_zone_transfers_incoming
              manifest: |-
                {
                  "auto_refresh_seconds": 86400,
                  "name": "www.example.com.",
                  "peers": [
                    "23ff594956f20c2a721606e94745a8aa",
                    "00920f38ce07c2e2f4df50b1f61d4194"
                  ],
                  "zone_id": "269d8f4853475ca241c4e730be286b20"
                }
        argumentDocs:
            auto_refresh_seconds: |-
                (Number) How often should a secondary zone auto refresh regardless of DNS NOTIFY.
                Not applicable for primary zones.
            checked_time: (String) The time for a specific event.
            created_time: (String) The time for a specific event.
            id: (String) The ID of this resource.
            modified_time: (String) The time for a specific event.
            name: (String) Zone name.
            peers: (Set of String) A list of peer tags.
            soa_serial: (Number) The serial number of the SOA for the given zone.
            zone_id: (String)
        importStatements:
            - $ terraform import cloudflare_dns_zone_transfers_incoming.example '<zone_id>'
    cloudflare_dns_zone_transfers_outgoing:
        subCategory: ""
        name: cloudflare_dns_zone_transfers_outgoing
        title: cloudflare_dns_zone_transfers_outgoing Resource - Cloudflare
        examples:
            - name: example_dns_zone_transfers_outgoing
              manifest: |-
                {
                  "name": "www.example.com.",
                  "peers": [
                    "23ff594956f20c2a721606e94745a8aa",
                    "00920f38ce07c2e2f4df50b1f61d4194"
                  ],
                  "zone_id": "269d8f4853475ca241c4e730be286b20"
                }
        argumentDocs:
            checked_time: (String) The time for a specific event.
            created_time: (String) The time for a specific event.
            id: (String) The ID of this resource.
            last_transferred_time: (String) The time for a specific event.
            name: (String) Zone name.
            peers: (Set of String) A list of peer tags.
            soa_serial: (Number) The serial number of the SOA for the given zone.
            zone_id: (String)
        importStatements:
            - $ terraform import cloudflare_dns_zone_transfers_outgoing.example '<zone_id>'
    cloudflare_dns_zone_transfers_peer:
        subCategory: ""
        name: cloudflare_dns_zone_transfers_peer
        title: cloudflare_dns_zone_transfers_peer Resource - Cloudflare
        examples:
            - name: example_dns_zone_transfers_peer
              manifest: |-
                {
                  "account_id": "01a7362d577a6c3019a474fd6f485823",
                  "name": "my-peer-1"
                }
        argumentDocs:
            account_id: (String)
            id: (String) The ID of this resource.
            ip: (String) IPv4/IPv6 address of primary or secondary nameserver, depending on what zone this peer is linked to. For primary zones this IP defines the IP of the secondary nameserver Cloudflare will NOTIFY upon zone changes. For secondary zones this IP defines the IP of the primary nameserver Cloudflare will send AXFR/IXFR requests to.
            ixfr_enable: (Boolean) Enable IXFR transfer protocol, default is AXFR. Only applicable to secondary zones.
            name: (String) The name of the peer.
            port: (Number) DNS port of primary or secondary nameserver, depending on what zone this peer is linked to.
            tsig_id: (String) TSIG authentication will be used for zone transfer if configured.
        importStatements:
            - $ terraform import cloudflare_dns_zone_transfers_peer.example '<account_id>/<peer_id>'
    cloudflare_dns_zone_transfers_tsig:
        subCategory: ""
        name: cloudflare_dns_zone_transfers_tsig
        title: cloudflare_dns_zone_transfers_tsig Resource - Cloudflare
        examples:
            - name: example_dns_zone_transfers_tsig
              manifest: |-
                {
                  "account_id": "01a7362d577a6c3019a474fd6f485823",
                  "algo": "hmac-sha512.",
                  "name": "tsig.customer.cf.",
                  "secret": "caf79a7804b04337c9c66ccd7bef9190a1e1679b5dd03d8aa10f7ad45e1a9dab92b417896c15d4d007c7c14194538d2a5d0feffdecc5a7f0e1c570cfa700837c"
                }
        argumentDocs:
            account_id: (String)
            algo: (String) TSIG algorithm.
            id: (String) The ID of this resource.
            name: (String) TSIG key name.
            secret: (String, Sensitive) TSIG secret.
        importStatements:
            - $ terraform import cloudflare_dns_zone_transfers_tsig.example '<account_id>/<tsig_id>'
    cloudflare_email_routing_address:
        subCategory: ""
        name: cloudflare_email_routing_address
        title: cloudflare_email_routing_address Resource - Cloudflare
        examples:
            - name: example_email_routing_address
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "email": "user@example.com"
                }
        argumentDocs:
            account_id: (String) Identifier.
            created: (String) The date and time the destination address has been created.
            email: (String) The contact email address of the user.
            id: (String) Destination address identifier.
            modified: (String) The date and time the destination address was last modified.
            tag: (String, Deprecated) Destination address tag. (Deprecated, replaced by destination address identifier)
            verified: (String) The date and time the destination address has been verified. Null means not verified yet.
        importStatements:
            - $ terraform import cloudflare_email_routing_address.example '<account_id>/<destination_address_identifier>'
    cloudflare_email_routing_catch_all:
        subCategory: ""
        name: cloudflare_email_routing_catch_all
        title: cloudflare_email_routing_catch_all Resource - Cloudflare
        examples:
            - name: example_email_routing_catch_all
              manifest: |-
                {
                  "actions": [
                    {
                      "type": "forward",
                      "value": [
                        "destinationaddress@example.net"
                      ]
                    }
                  ],
                  "enabled": true,
                  "matchers": [
                    {
                      "type": "all"
                    }
                  ],
                  "name": "Send to user@example.net rule.",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            actions: (Attributes List) List actions for the catch-all routing rule. (see below for nested schema)
            enabled: (Boolean) Routing rule status.
            id: (String) Identifier.
            matchers: (Attributes List) List of matchers for the catch-all routing rule. (see below for nested schema)
            name: (String) Routing rule name.
            tag: (String, Deprecated) Routing rule tag. (Deprecated, replaced by routing rule identifier)
            type: |-
                (String) Type of action for catch-all rule.
                Available values: "drop", "forward", "worker".
            value: (List of String)
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_email_routing_catch_all.example '<zone_id>'
    cloudflare_email_routing_dns:
        subCategory: ""
        name: cloudflare_email_routing_dns
        title: cloudflare_email_routing_dns Resource - Cloudflare
        examples:
            - name: example_email_routing_dns
              manifest: |-
                {
                  "name": "example.net",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            code: (Number)
            content: (String) DNS record content.
            created: (String) The date and time the settings have been created.
            documentation_url: (String)
            email_routing_dns_count: (Number) Total number of results for the requested service.
            enabled: (Boolean) State of the zone settings for Email Routing.
            errors: (Attributes List) (see below for nested schema)
            id: (String) Identifier.
            message: (String)
            messages: (Attributes List) (see below for nested schema)
            missing: (Attributes) List of records needed to enable an Email Routing zone. (see below for nested schema)
            modified: (String) The date and time the settings have been modified.
            name: (String) Domain of your zone.
            page: (Number) Current page within paginated list of results.
            per_page: (Number) Number of results per page of results.
            pointer: (String)
            priority: (Number) Required for MX, SRV and URI records. Unused by other record types. Records with lower priorities are preferred.
            record: (Attributes List) (see below for nested schema)
            result: (Attributes) (see below for nested schema)
            result_info: (Attributes) (see below for nested schema)
            skip_wizard: (Boolean) Flag to check if the user skipped the configuration wizard.
            source: (Attributes) (see below for nested schema)
            status: |-
                (String) Show the state of your account, and the type or configuration error.
                Available values: "ready", "unconfigured", "misconfigured", "misconfigured/locked", "unlocked".
            success: (Boolean) Whether the API call was successful.
            tag: (String, Deprecated) Email Routing settings tag. (Deprecated, replaced by Email Routing settings identifier)
            total_count: (Number) Total results available without any search parameters.
            ttl: (Number) Time to live, in seconds, of the DNS record. Must be between 60 and 86400, or 1 for 'automatic'.
            type: |-
                (String) DNS record type.
                Available values: "A", "AAAA", "CNAME", "HTTPS", "TXT", "SRV", "LOC", "MX", "NS", "CERT", "DNSKEY", "DS", "NAPTR", "SMIMEA", "SSHFP", "SVCB", "TLSA", "URI".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_email_routing_dns.example '<zone_id>'
    cloudflare_email_routing_rule:
        subCategory: ""
        name: cloudflare_email_routing_rule
        title: cloudflare_email_routing_rule Resource - Cloudflare
        examples:
            - name: example_email_routing_rule
              manifest: |-
                {
                  "actions": [
                    {
                      "type": "forward",
                      "value": [
                        "destinationaddress@example.net"
                      ]
                    }
                  ],
                  "enabled": true,
                  "matchers": [
                    {
                      "field": "to",
                      "type": "literal",
                      "value": "test@example.com"
                    }
                  ],
                  "name": "Send to user@example.net rule.",
                  "priority": 0,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            actions: (Attributes List) List actions patterns. (see below for nested schema)
            enabled: (Boolean) Routing rule status.
            field: |-
                (String) Field for type matcher.
                Available values: "to".
            id: (String) Routing rule identifier.
            matchers: (Attributes List) Matching patterns to forward to your actions. (see below for nested schema)
            name: (String) Routing rule name.
            priority: (Number) Priority of the routing rule.
            tag: (String, Deprecated) Routing rule tag. (Deprecated, replaced by routing rule identifier)
            type: |-
                (String) Type of supported action.
                Available values: "drop", "forward", "worker".
            value: (List of String)
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_email_routing_rule.example '<zone_id>/<rule_identifier>'
    cloudflare_email_routing_settings:
        subCategory: ""
        name: cloudflare_email_routing_settings
        title: cloudflare_email_routing_settings Resource - Cloudflare
        examples:
            - name: example_email_routing_settings
              manifest: |-
                {
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            created: (String) The date and time the settings have been created.
            enabled: (Boolean) State of the zone settings for Email Routing.
            id: (String) Email Routing settings identifier.
            modified: (String) The date and time the settings have been modified.
            name: (String) Domain of your zone.
            skip_wizard: (Boolean) Flag to check if the user skipped the configuration wizard.
            status: |-
                (String) Show the state of your account, and the type or configuration error.
                Available values: "ready", "unconfigured", "misconfigured", "misconfigured/locked", "unlocked".
            tag: (String, Deprecated) Email Routing settings tag. (Deprecated, replaced by Email Routing settings identifier)
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_email_routing_settings.example '<zone_id>'
    cloudflare_email_security_block_sender:
        subCategory: ""
        name: cloudflare_email_security_block_sender
        title: cloudflare_email_security_block_sender Resource - Cloudflare
        examples:
            - name: example_email_security_block_sender
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "comments": "block sender with email test@example.com",
                  "is_regex": false,
                  "pattern": "test@example.com",
                  "pattern_type": "EMAIL"
                }
        argumentDocs:
            account_id: (String) Account Identifier
            comments: (String)
            created_at: (String)
            id: (Number) The unique identifier for the allow policy.
            is_regex: (Boolean)
            last_modified: (String)
            pattern: (String)
            pattern_type: '(String) Available values: "EMAIL", "DOMAIN", "IP", "UNKNOWN".'
        importStatements:
            - $ terraform import cloudflare_email_security_block_sender.example '<account_id>/<pattern_id>'
    cloudflare_email_security_impersonation_registry:
        subCategory: ""
        name: cloudflare_email_security_impersonation_registry
        title: cloudflare_email_security_impersonation_registry Resource - Cloudflare
        examples:
            - name: example_email_security_impersonation_registry
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "email": "email",
                  "is_email_regex": true,
                  "name": "name"
                }
        argumentDocs:
            account_id: (String) Account Identifier
            comments: (String)
            created_at: (String)
            directory_id: (Number)
            directory_node_id: (Number)
            email: (String)
            external_directory_node_id: (String, Deprecated)
            id: (Number) The ID of this resource.
            is_email_regex: (Boolean)
            last_modified: (String)
            name: (String)
            provenance: (String)
        importStatements:
            - $ terraform import cloudflare_email_security_impersonation_registry.example '<account_id>/<display_name_id>'
    cloudflare_email_security_trusted_domains:
        subCategory: ""
        name: cloudflare_email_security_trusted_domains
        title: cloudflare_email_security_trusted_domains Resource - Cloudflare
        examples:
            - name: example_email_security_trusted_domains
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "comments": null,
                  "is_recent": true,
                  "is_regex": false,
                  "is_similarity": false,
                  "pattern": "example.com"
                }
        argumentDocs:
            account_id: (String) Account Identifier
            body: (Attributes List) (see below for nested schema)
            comments: (String)
            created_at: (String)
            id: (Number) The unique identifier for the trusted domain.
            is_recent: |-
                (Boolean) Select to prevent recently registered domains from triggering a
                Suspicious or Malicious disposition.
            is_regex: (Boolean)
            is_similarity: |-
                (Boolean) Select for partner or other approved domains that have similar
                spelling to your connected domains. Prevents listed domains from
                triggering a Spoof disposition.
            last_modified: (String)
            pattern: (String)
        importStatements:
            - $ terraform import cloudflare_email_security_trusted_domains.example '<account_id>/<trusted_domain_id>'
    cloudflare_filter:
        subCategory: ""
        name: cloudflare_filter
        title: cloudflare_filter Resource - Cloudflare
        examples:
            - name: example_filter
              manifest: |-
                {
                  "body": [
                    {
                      "description": "Restrict access from these browsers on this address range.",
                      "expression": "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.addr ne 172.16.22.155",
                      "paused": false,
                      "ref": "FIL-100"
                    }
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            body: (Attributes List) (see below for nested schema)
            description: (String) An informative summary of the filter.
            expression: (String) The filter expression. For more information, refer to Expressions.
            id: (String) The unique identifier of the filter.
            paused: (Boolean) When true, indicates that the filter is currently paused.
            ref: (String) A short reference tag. Allows you to select related filters.
            zone_id: (String) Defines an identifier.
        importStatements:
            - $ terraform import cloudflare_filter.example '<zone_id>/<filter_id>'
    cloudflare_firewall_rule:
        subCategory: ""
        name: cloudflare_firewall_rule
        title: cloudflare_firewall_rule Resource - Cloudflare
        examples:
            - name: example_firewall_rule
              manifest: |-
                {
                  "action": {
                    "mode": "challenge",
                    "response": {
                      "body": "\u003cerror\u003eThis request has been rate-limited.\u003c/error\u003e",
                      "content_type": "text/xml"
                    },
                    "timeout": 86400
                  },
                  "filter": {
                    "description": "Restrict access from these browsers on this address range.",
                    "expression": "(http.request.uri.path ~ \".*wp-login.php\" or http.request.uri.path ~ \".*xmlrpc.php\") and ip.addr ne 172.16.22.155",
                    "paused": false,
                    "ref": "FIL-100"
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            action: (Attributes) The action to perform when the threshold of matched traffic within the configured period is exceeded. (see below for nested schema)
            body: (String) The response body to return. The value must conform to the configured content type.
            content_type: '(String) The content type of the body. Must be one of the following: text/plain, text/xml, or application/json.'
            description: (String) An informative summary of the firewall rule.
            expression: (String) The filter expression. For more information, refer to Expressions.
            filter: (Attributes) (see below for nested schema)
            id: (String) The unique identifier of the firewall rule.
            mode: |-
                (String) The action to perform.
                Available values: "simulate", "ban", "challenge", "js_challenge", "managed_challenge".
            paused: (Boolean) When true, indicates that the firewall rule is currently paused.
            priority: (Number) The priority of the rule. Optional value used to define the processing order. A lower number indicates a higher priority. If not provided, rules with a defined priority will be processed before rules without a priority.
            products: (List of String)
            ref: (String) A short reference tag. Allows you to select related firewall rules.
            response: |-
                (Attributes) A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
                Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed_challenge", or "js_challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object. (see below for nested schema)
            timeout: |-
                (Number) The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
                Notes: If "mode" is "challenge", "managed_challenge", or "js_challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
            zone_id: (String) Defines an identifier.
        importStatements:
            - $ terraform import cloudflare_firewall_rule.example '<zone_id>/<rule_id>'
    cloudflare_healthcheck:
        subCategory: ""
        name: cloudflare_healthcheck
        title: cloudflare_healthcheck Resource - Cloudflare
        examples:
            - name: example_healthcheck
              manifest: |-
                {
                  "address": "www.example.com",
                  "check_regions": [
                    "WEU",
                    "ENAM"
                  ],
                  "consecutive_fails": 0,
                  "consecutive_successes": 0,
                  "description": "Health check for www.example.com",
                  "http_config": {
                    "allow_insecure": true,
                    "expected_body": "success",
                    "expected_codes": [
                      "2xx",
                      "302"
                    ],
                    "follow_redirects": true,
                    "header": {
                      "Host": [
                        "example.com"
                      ],
                      "X-App-ID": [
                        "abc123"
                      ]
                    },
                    "method": "GET",
                    "path": "/health",
                    "port": 0
                  },
                  "interval": 0,
                  "name": "server-1",
                  "retries": 0,
                  "suspended": true,
                  "tcp_config": {
                    "method": "connection_established",
                    "port": 0
                  },
                  "timeout": 0,
                  "type": "HTTPS",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            address: (String) The hostname or IP address of the origin server to run health checks on.
            allow_insecure: (Boolean) Do not validate the certificate when the health check uses HTTPS.
            check_regions: (List of String) A list of regions from which to run health checks. Null means Cloudflare will pick a default region.
            consecutive_fails: (Number) The number of consecutive fails required from a health check before changing the health to unhealthy.
            consecutive_successes: (Number) The number of consecutive successes required from a health check before changing the health to healthy.
            created_on: (String)
            description: (String) A human-readable description of the health check.
            expected_body: (String) A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy.
            expected_codes: (List of String) The expected HTTP response codes (e.g. "200") or code ranges (e.g. "2xx" for all codes starting with 2) of the health check.
            failure_reason: (String) The current failure reason if status is unhealthy.
            follow_redirects: (Boolean) Follow redirects if the origin returns a 3xx status code.
            header: (Map of List of String) The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden.
            http_config: (Attributes) Parameters specific to an HTTP or HTTPS health check. (see below for nested schema)
            id: (String) Identifier
            interval: (Number) The interval between each health check. Shorter intervals may give quicker notifications if the origin status changes, but will increase load on the origin as we check from multiple locations.
            method: |-
                (String) The HTTP method to use for the health check.
                Available values: "GET", "HEAD".
            modified_on: (String)
            name: (String) A short name to identify the health check. Only alphanumeric characters, hyphens and underscores are allowed.
            path: (String) The endpoint path to health check against.
            port: (Number) Port number to connect to for the health check. Defaults to 80 if type is HTTP or 443 if type is HTTPS.
            retries: (Number) The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
            status: |-
                (String) The current status of the origin server according to the health check.
                Available values: "unknown", "healthy", "unhealthy", "suspended".
            suspended: (Boolean) If suspended, no health checks are sent to the origin.
            tcp_config: (Attributes) Parameters specific to TCP health check. (see below for nested schema)
            timeout: (Number) The timeout (in seconds) before marking the health check as failed.
            type: (String) The protocol to use for the health check. Currently supported protocols are 'HTTP', 'HTTPS' and 'TCP'.
            zone_id: (String) Identifier
        importStatements:
            - $ terraform import cloudflare_healthcheck.example '<zone_id>/<healthcheck_id>'
    cloudflare_hostname_tls_setting:
        subCategory: ""
        name: cloudflare_hostname_tls_setting
        title: cloudflare_hostname_tls_setting Resource - Cloudflare
        examples:
            - name: example_hostname_tls_setting
              manifest: |-
                {
                  "hostname": "app.example.com",
                  "setting_id": "ciphers",
                  "value": [
                    "ECDHE-RSA-AES128-GCM-SHA256",
                    "AES128-GCM-SHA256"
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            created_at: (String) This is the time the tls setting was originally created for this hostname.
            hostname: (String) The hostname for which the tls settings are set.
            id: |-
                (String) The TLS Setting name.
                Available values: "ciphers", "min_tls_version", "http2".
            setting_id: |-
                (String) The TLS Setting name.
                Available values: "ciphers", "min_tls_version", "http2".
            status: (String) Deployment status for the given tls setting.
            updated_at: (String) This is the time the tls setting was updated.
            value: (Dynamic) The tls setting value.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_hostname_tls_setting.example '<zone_id>/<setting_id>'
    cloudflare_hyperdrive_config:
        subCategory: ""
        name: cloudflare_hyperdrive_config
        title: cloudflare_hyperdrive_config Resource - Cloudflare
        examples:
            - name: example_hyperdrive_config
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "caching": {
                    "disabled": true
                  },
                  "mtls": {
                    "ca_certificate_id": "00000000-0000-0000-0000-0000000000",
                    "mtls_certificate_id": "00000000-0000-0000-0000-0000000000",
                    "sslmode": "verify-full"
                  },
                  "name": "example-hyperdrive",
                  "origin": {
                    "database": "postgres",
                    "host": "database.example.com",
                    "password": "password",
                    "port": 5432,
                    "scheme": "postgres",
                    "user": "postgres"
                  },
                  "origin_connection_limit": 60
                }
        argumentDocs:
            access_client_id: (String) Defines the Client ID of the Access token to use when connecting to the origin database.
            access_client_secret: (String, Sensitive) Defines the Client Secret of the Access Token to use when connecting to the origin database. The API never returns this write-only value.
            account_id: (String) Define configurations using a unique string identifier.
            ca_certificate_id: (String) Define CA certificate ID obtained after uploading CA cert.
            caching: (Attributes) (see below for nested schema)
            created_on: (String) Defines the creation time of the Hyperdrive configuration.
            database: (String) Set the name of your origin database.
            disabled: (Boolean) Set to true to disable caching of SQL responses. Default is false.
            host: (String) Defines the host (hostname or IP) of your origin database.
            id: (String) Define configurations using a unique string identifier.
            max_age: (Number) Specify the maximum duration (in seconds) items should persist in the cache. Defaults to 60 seconds if not specified.
            modified_on: (String) Defines the last modified time of the Hyperdrive configuration.
            mtls: (Attributes) (see below for nested schema)
            mtls_certificate_id: (String) Define mTLS certificate ID obtained after uploading client cert.
            name: (String) The name of the Hyperdrive configuration. Used to identify the configuration in the Cloudflare dashboard and API.
            origin: (Attributes) (see below for nested schema)
            origin_connection_limit: (Number) The (soft) maximum number of connections the Hyperdrive is allowed to make to the origin database.
            password: (String, Sensitive) Set the password needed to access your origin database. The API never returns this write-only value.
            port: (Number) Defines the port of your origin database. Defaults to 5432 for PostgreSQL or 3306 for MySQL if not specified.
            scheme: |-
                (String) Specifies the URL scheme used to connect to your origin database.
                Available values: "postgres", "postgresql", "mysql".
            sslmode: (String) Set SSL mode to 'require', 'verify-ca', or 'verify-full' to verify the CA.
            stale_while_revalidate: (Number) Specify the number of seconds the cache may serve a stale response. Defaults to 15 seconds if not specified.
            user: (String) Set the user of your origin database.
        importStatements:
            - $ terraform import cloudflare_hyperdrive_config.example '<account_id>/<hyperdrive_id>'
    cloudflare_image:
        subCategory: ""
        name: cloudflare_image
        title: cloudflare_image Resource - Cloudflare
        examples:
            - name: example_image
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "creator": "creator",
                  "file": null,
                  "id": "id",
                  "metadata": {},
                  "require_signed_urls": true,
                  "url": "https://example.com/path/to/logo.png"
                }
        argumentDocs:
            account_id: (String) Account identifier tag.
            creator: (String) Can set the creator field with an internal user ID.
            file: (String) An image binary data. Only needed when type is uploading a file.
            filename: (String) Image file name.
            id: (String) An optional custom unique identifier for your image.
            meta: (String) User modifiable key-value store. Can be used for keeping references to another system of record for managing images. Metadata must not exceed 1024 bytes.
            metadata: (String) User modifiable key-value store. Can use used for keeping references to another system of record for managing images.
            require_signed_urls: (Boolean) Indicates whether the image requires a signature token for the access.
            uploaded: (String) When the media item was uploaded.
            url: (String) A URL to fetch an image from origin. Only needed when type is uploading from a URL.
            variants: (List of String) Object specifying available variants for an image.
        importStatements:
            - $ terraform import cloudflare_image.example '<account_id>/<image_id>'
    cloudflare_image_variant:
        subCategory: ""
        name: cloudflare_image_variant
        title: cloudflare_image_variant Resource - Cloudflare
        examples:
            - name: example_image_variant
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "id": "hero",
                  "never_require_signed_urls": true,
                  "options": {
                    "fit": "scale-down",
                    "height": 768,
                    "metadata": "none",
                    "width": 1366
                  }
                }
        argumentDocs:
            account_id: (String) Account identifier tag.
            fit: |-
                (String) The fit property describes how the width and height dimensions should be interpreted.
                Available values: "scale-down", "contain", "cover", "crop", "pad".
            height: (Number) Maximum height in image pixels.
            id: (String) The ID of this resource.
            metadata: |-
                (String) What EXIF data should be preserved in the output image.
                Available values: "keep", "copyright", "none".
            never_require_signed_urls: (Boolean) Indicates whether the variant can access an image without a signature, regardless of image access control.
            options: (Attributes) Allows you to define image resizing sizes for different use cases. (see below for nested schema)
            variant: (Attributes) (see below for nested schema)
            width: (Number) Maximum width in image pixels.
        importStatements:
            - $ terraform import cloudflare_image_variant.example '<account_id>/<variant_id>'
    cloudflare_keyless_certificate:
        subCategory: ""
        name: cloudflare_keyless_certificate
        title: cloudflare_keyless_certificate Resource - Cloudflare
        examples:
            - name: example_keyless_certificate
              manifest: |-
                {
                  "bundle_method": "ubiquitous",
                  "certificate": "-----BEGIN CERTIFICATE----- MIIDtTCCAp2gAwIBAgIJAM15n7fdxhRtMA0GCSqGSIb3DQEBBQUAMEUxCzAJBgNV BAYTAlVTMRMwEQYDVQQIEwpTb21lLVN0YXRlMSEwHwYDVQQKExhJbnRlcm5ldCBX aWRnaXRzIFB0eSBMdGQwHhcNMTQwMzExMTkyMTU5WhcNMTQwNDEwMTkyMTU5WjBF MQswCQYDVQQGEwJVUzETMBEGA1UECBMKU29tZS1TdGF0ZTEhMB8GA1UEChMYSW50 ZXJuZXQgV2lkZ2l0cyBQdHkgTHRkMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIB CgKCAQEAvq3sKsHpeduJHimOK+fvQdKsI8z8A05MZyyLp2/R/GE8FjNv+hkVY1WQ LIyTNNQH7CJecE1nbTfo8Y56S7x/rhxC6/DJ8MIulapFPnorq46KU6yRxiM0MQ3N nTJHlHA2ozZta6YBBfVfhHWl1F0IfNbXCLKvGwWWMbCx43OfW6KTkbRnE6gFWKuO fSO5h2u5TaWVuSIzBvYs7Vza6m+gtYAvKAJV2nSZ+eSEFPDo29corOy8+huEOUL8 5FAw4BFPsr1TlrlGPFitduQUHGrSL7skk1ESGza0to3bOtrodKei2s9bk5MXm7lZ qI+WZJX4Zu9+mzZhc9pCVi8r/qlXuQIDAQABo4GnMIGkMB0GA1UdDgQWBBRvavf+ sWM4IwKiH9X9w1vl6nUVRDB1BgNVHSMEbjBsgBRvavf+sWM4IwKiH9X9w1vl6nUV RKFJpEcwRTELMAkGA1UEBhMCVVMxEzARBgNVBAgTClNvbWUtU3RhdGUxITAfBgNV BAoTGEludGVybmV0IFdpZGdpdHMgUHR5IEx0ZIIJAM15n7fdxhRtMAwGA1UdEwQF MAMBAf8wDQYJKoZIhvcNAQEFBQADggEBABY2ZzBaW0dMsAAT7tPJzrVWVzQx6KU4 UEBLudIlWPlkAwTnINCWR/8eNjCCmGA4heUdHmazdpPa8RzwOmc0NT1NQqzSyktt vTqb4iHD7+8f9MqJ9/FssCfTtqr/Qst/hGH4Wmdf1EJ/6FqYAAb5iRlPgshFZxU8 uXtA8hWn6fK6eISD9HBdcAFToUvKNZ1BIDPvh9f95Ine8ar6yGd56TUNrHR8eHBs ESxz5ddVR/oWRysNJ+aGAyYqHS8S/ttmC7r4XCAHqXptkHPCGRqkAhsterYhd4I8 /cBzejUobNCjjHFbtkAL/SjxZOLW+pNkZwfeYdM8iPkD54Uua1v2tdw= -----END CERTIFICATE-----",
                  "host": "example.com",
                  "name": "example.com Keyless SSL",
                  "port": 24008,
                  "tunnel": {
                    "private_ip": "10.0.0.1",
                    "vnet_id": "7365377a-85a4-4390-9480-531ef7dc7a3c"
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            bundle_method: |-
                (String) A ubiquitous bundle has the highest probability of being verified everywhere, even by clients using outdated or unusual trust stores. An optimal bundle uses the shortest chain and newest intermediates. And the force bundle verifies the chain, but does not otherwise modify it.
                Available values: "ubiquitous", "optimal", "force".
            certificate: (String) The zone's SSL certificate or SSL certificate and intermediate(s).
            created_on: (String) When the Keyless SSL was created.
            enabled: (Boolean, Deprecated) Whether or not the Keyless SSL is on or off.
            host: (String) The keyless SSL name.
            id: (String) Keyless certificate identifier tag.
            modified_on: (String) When the Keyless SSL was last modified.
            name: (String) The keyless SSL name.
            permissions: (List of String) Available permissions for the Keyless SSL for the current user requesting the item.
            port: (Number) The keyless SSL port used to communicate between Cloudflare and the client's Keyless SSL server.
            private_ip: (String) Private IP of the Key Server Host
            status: |-
                (String) Status of the Keyless SSL.
                Available values: "active", "deleted".
            tunnel: (Attributes) Configuration for using Keyless SSL through a Cloudflare Tunnel (see below for nested schema)
            vnet_id: (String) Cloudflare Tunnel Virtual Network ID
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_keyless_certificate.example '<zone_id>/<keyless_certificate_id>'
    cloudflare_leaked_credential_check:
        subCategory: ""
        name: cloudflare_leaked_credential_check
        title: cloudflare_leaked_credential_check Resource - Cloudflare
        examples:
            - name: example_leaked_credential_check
              manifest: |-
                {
                  "enabled": true,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            enabled: (Boolean) Determines whether or not Leaked Credential Checks are enabled.
            zone_id: (String) Defines an identifier.
        importStatements: []
    cloudflare_leaked_credential_check_rule:
        subCategory: ""
        name: cloudflare_leaked_credential_check_rule
        title: cloudflare_leaked_credential_check_rule Resource - Cloudflare
        examples:
            - name: example_leaked_credential_check_rule
              manifest: |-
                {
                  "password": "lookup_json_string(http.request.body.raw, \"secret\")",
                  "username": "lookup_json_string(http.request.body.raw, \"user\")",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            id: (String) Defines the unique ID for this custom detection.
            password: (String) Defines ehe ruleset expression to use in matching the password in a request.
            username: (String) Defines the ruleset expression to use in matching the username in a request.
            zone_id: (String) Defines an identifier.
        importStatements:
            - $ terraform import cloudflare_leaked_credential_check_rule.example '<zone_id>/<detection_id>'
    cloudflare_list:
        subCategory: ""
        name: cloudflare_list
        title: cloudflare_list Resource - Cloudflare
        examples:
            - name: example_list
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "description": "This is a note",
                  "items": [
                    {
                      "ip": "1.1.1.1"
                    },
                    {
                      "ip": "1.1.1.2"
                    }
                  ],
                  "kind": "ip",
                  "name": "list1"
                }
        argumentDocs:
            account_id: (String) The Account ID for this resource.
            asn: (Number) A non-negative 32 bit integer
            comment: (String) An informative summary of the list item.
            created_on: (String) The RFC 3339 timestamp of when the list was created.
            description: (String) An informative summary of the list.
            exclude_exact_hostname: (Boolean) Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
            hostname: (Attributes) Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-). (see below for nested schema)
            id: (String) The unique ID of the list.
            include_subdomains: (Boolean)
            ip: (String) An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
            items: (Attributes Set) The items in the list. If set, this overwrites all items in the list. Do not use with cloudflare_list_item. (see below for nested schema)
            kind: |-
                (String) The type of the list. Each type supports specific list items (IP addresses, ASNs, hostnames or redirects).
                Available values: "ip", "redirect", "hostname", "asn".
            modified_on: (String) The RFC 3339 timestamp of when the list was last modified.
            name: (String) An informative name for the list. Use this name in filter and rule expressions.
            num_items: (Number) The number of items in the list.
            num_referencing_filters: (Number) The number of filters referencing the list.
            preserve_path_suffix: (Boolean)
            preserve_query_string: (Boolean)
            redirect: (Attributes) The definition of the redirect. (see below for nested schema)
            source_url: (String)
            status_code: '(Number) Available values: 301, 302, 307, 308.'
            subpath_matching: (Boolean)
            target_url: (String)
            url_hostname: (String)
        importStatements:
            - $ terraform import cloudflare_list.example '<account_id>/<list_id>'
    cloudflare_list_item:
        subCategory: ""
        name: cloudflare_list_item
        title: cloudflare_list_item Resource - Cloudflare
        examples:
            - name: example_list_item
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "ip": "10.0.0.1",
                  "list_id": "2c0fc9fa937b11eaa1b71c4d701ab86e"
                }
        argumentDocs:
            account_id: (String) The Account ID for this resource.
            asn: (Number) A non-negative 32 bit integer
            comment: (String) An informative summary of the list item.
            created_on: (String) The RFC 3339 timestamp of when the item was created.
            exclude_exact_hostname: (Boolean) Only applies to wildcard hostnames (e.g., *.example.com). When true (default), only subdomains are blocked. When false, both the root domain and subdomains are blocked.
            hostname: (Attributes) Valid characters for hostnames are ASCII(7) letters from a to z, the digits from 0 to 9, wildcards (*), and the hyphen (-). (see below for nested schema)
            id: (String) The unique ID of the item in the List.
            include_subdomains: (Boolean)
            ip: (String) An IPv4 address, an IPv4 CIDR, an IPv6 address, or an IPv6 CIDR.
            list_id: (String) The unique ID of the list.
            modified_on: (String) The RFC 3339 timestamp of when the item was last modified.
            operation_id: (String) The unique operation ID of the asynchronous action.
            preserve_path_suffix: (Boolean)
            preserve_query_string: (Boolean)
            redirect: (Attributes) The definition of the redirect. (see below for nested schema)
            source_url: (String)
            status_code: '(Number) Available values: 301, 302, 307, 308.'
            subpath_matching: (Boolean)
            target_url: (String)
            url_hostname: (String)
        importStatements:
            - |-
              $ terraform import cloudflare_list_item.example '<account_id>/<list_id>/<item_id>'
              $ terraform import cloudflare_list_item.example '<account_id>/<list_id>/<item_id>'
              $ terraform import cloudflare_list_item.example '<account_id>/<list_id>/<item_id>'
    cloudflare_load_balancer:
        subCategory: ""
        name: cloudflare_load_balancer
        title: cloudflare_load_balancer Resource - Cloudflare
        examples:
            - name: example_load_balancer
              manifest: |-
                {
                  "adaptive_routing": {
                    "failover_across_pools": true
                  },
                  "country_pools": {
                    "GB": [
                      "abd90f38ced07c2e2f4df50b1f61d4194"
                    ],
                    "US": [
                      "de90f38ced07c2e2f4df50b1f61d4194",
                      "00920f38ce07c2e2f4df50b1f61d4194"
                    ]
                  },
                  "default_pools": [
                    "17b5962d775c646f3f9725cbc7a53df4",
                    "9290f38c5d07c2e2f4df57b1f61d4196",
                    "00920f38ce07c2e2f4df50b1f61d4194"
                  ],
                  "description": "Load Balancer for www.example.com",
                  "fallback_pool": "fallback_pool",
                  "location_strategy": {
                    "mode": "resolver_ip",
                    "prefer_ecs": "always"
                  },
                  "name": "www.example.com",
                  "networks": [
                    "string"
                  ],
                  "pop_pools": {
                    "LAX": [
                      "de90f38ced07c2e2f4df50b1f61d4194",
                      "9290f38c5d07c2e2f4df57b1f61d4196"
                    ],
                    "LHR": [
                      "abd90f38ced07c2e2f4df50b1f61d4194",
                      "f9138c5d07c2e2f4df57b1f61d4196"
                    ],
                    "SJC": [
                      "00920f38ce07c2e2f4df50b1f61d4194"
                    ]
                  },
                  "proxied": true,
                  "random_steering": {
                    "default_weight": 0.2,
                    "pool_weights": {
                      "9290f38c5d07c2e2f4df57b1f61d4196": 0.5,
                      "de90f38ced07c2e2f4df50b1f61d4194": 0.3
                    }
                  },
                  "region_pools": {
                    "ENAM": [
                      "00920f38ce07c2e2f4df50b1f61d4194"
                    ],
                    "WNAM": [
                      "de90f38ced07c2e2f4df50b1f61d4194",
                      "9290f38c5d07c2e2f4df57b1f61d4196"
                    ]
                  },
                  "rules": [
                    {
                      "condition": "http.request.uri.path contains \"/testing\"",
                      "disabled": true,
                      "fixed_response": {
                        "content_type": "application/json",
                        "location": "www.example.com",
                        "message_body": "Testing Hello",
                        "status_code": 0
                      },
                      "name": "route the path /testing to testing datacenter.",
                      "overrides": {
                        "adaptive_routing": {
                          "failover_across_pools": true
                        },
                        "country_pools": {
                          "GB": [
                            "abd90f38ced07c2e2f4df50b1f61d4194"
                          ],
                          "US": [
                            "de90f38ced07c2e2f4df50b1f61d4194",
                            "00920f38ce07c2e2f4df50b1f61d4194"
                          ]
                        },
                        "default_pools": [
                          "17b5962d775c646f3f9725cbc7a53df4",
                          "9290f38c5d07c2e2f4df57b1f61d4196",
                          "00920f38ce07c2e2f4df50b1f61d4194"
                        ],
                        "fallback_pool": "fallback_pool",
                        "location_strategy": {
                          "mode": "resolver_ip",
                          "prefer_ecs": "always"
                        },
                        "pop_pools": {
                          "LAX": [
                            "de90f38ced07c2e2f4df50b1f61d4194",
                            "9290f38c5d07c2e2f4df57b1f61d4196"
                          ],
                          "LHR": [
                            "abd90f38ced07c2e2f4df50b1f61d4194",
                            "f9138c5d07c2e2f4df57b1f61d4196"
                          ],
                          "SJC": [
                            "00920f38ce07c2e2f4df50b1f61d4194"
                          ]
                        },
                        "random_steering": {
                          "default_weight": 0.2,
                          "pool_weights": {
                            "9290f38c5d07c2e2f4df57b1f61d4196": 0.5,
                            "de90f38ced07c2e2f4df50b1f61d4194": 0.3
                          }
                        },
                        "region_pools": {
                          "ENAM": [
                            "00920f38ce07c2e2f4df50b1f61d4194"
                          ],
                          "WNAM": [
                            "de90f38ced07c2e2f4df50b1f61d4194",
                            "9290f38c5d07c2e2f4df57b1f61d4196"
                          ]
                        },
                        "session_affinity": "cookie",
                        "session_affinity_attributes": {
                          "drain_duration": 100,
                          "headers": [
                            "x"
                          ],
                          "require_all_headers": true,
                          "samesite": "Auto",
                          "secure": "Auto",
                          "zero_downtime_failover": "sticky"
                        },
                        "session_affinity_ttl": 1800,
                        "steering_policy": "dynamic_latency",
                        "ttl": 30
                      },
                      "priority": 0,
                      "terminates": true
                    }
                  ],
                  "session_affinity": "cookie",
                  "session_affinity_attributes": {
                    "drain_duration": 100,
                    "headers": [
                      "x"
                    ],
                    "require_all_headers": true,
                    "samesite": "Auto",
                    "secure": "Auto",
                    "zero_downtime_failover": "sticky"
                  },
                  "session_affinity_ttl": 1800,
                  "steering_policy": "dynamic_latency",
                  "ttl": 30,
                  "zone_id": "699d98642c564d2e855e9661899b7252"
                }
        argumentDocs:
            '""': |-
                : Will map to "geo" if you use region_pools/country_pools/pop_pools otherwise "off".
                Available values: "off", "geo", "random", "dynamic_latency", "proximity", "least_outstanding_requests", "least_connections", "".
            '"always"': ': Always prefer ECS.'
            '"dynamic_latency"': ': Use round trip time to select the closest pool in default_pools (requires pool health checks).'
            '"geo"': ': Use region_pools/country_pools/pop_pools. For non-proxied requests, the country for country_pools is determined by location_strategy.'
            '"least_connections"': ': Select a pool by taking into consideration random_steering weights, as well as each pool''s number of open connections. Pools with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections.'
            '"least_outstanding_requests"': ': Select a pool by taking into consideration random_steering weights, as well as each pool''s number of outstanding requests. Pools with more pending requests are weighted proportionately less relative to others.'
            '"never"': ': Never prefer ECS.'
            '"off"': ': Use default_pools.'
            '"pop"': ': Use the Cloudflare PoP location.'
            '"proximity"': ': Use the pools'' latitude and longitude to select the closest pool using the Cloudflare PoP location for proxied requests or the location determined by location_strategy for non-proxied requests.'
            '"random"': ': Select a pool randomly.'
            '"resolver_ip"': |-
                : Use the DNS resolver GeoIP location. If the GeoIP lookup is unsuccessful, use the Cloudflare PoP location.
                Available values: "pop", "resolver_ip".
            adaptive_routing: (Attributes) Controls features that modify the routing of requests to pools and origins in response to dynamic conditions, such as during the interval between active health monitoring requests. For example, zero-downtime failover occurs immediately when an origin becomes unavailable due to HTTP 521, 522, or 523 response codes. If there is another healthy origin in the same pool, the request is retried once against this alternate origin. (see below for nested schema)
            condition: (String) The condition expressions to evaluate. If the condition evaluates to true, the overrides or fixed_response in this rule will be applied. An empty condition is always true. For more details on condition expressions, please see https://developers.cloudflare.com/load-balancing/understand-basics/load-balancing-rules/expressions.
            content_type: (String) The http 'Content-Type' header to include in the response.
            country_pools: (Map of List of String) A mapping of country codes to a list of pool IDs (ordered by their failover priority) for the given country. Any country not explicitly defined will fall back to using the corresponding region_pool mapping if it exists else to default_pools.
            created_on: (String)
            default_pools: (List of String) A list of pool IDs ordered by their failover priority. Pools defined here are used by default, or when region_pools are not configured for a given region.
            default_weight: (Number) The default weight for pools in the load balancer that are not specified in the pool_weights map.
            description: (String) Object description.
            disabled: (Boolean) Disable this specific rule. It will no longer be evaluated by this load balancer.
            drain_duration: (Number) Configures the drain duration in seconds. This field is only used when session affinity is enabled on the load balancer.
            enabled: (Boolean) Whether to enable (the default) this load balancer.
            failover_across_pools: (Boolean) Extends zero-downtime failover of requests to healthy origins from alternate pools, when no healthy alternate exists in the same pool, according to the failover order defined by traffic and origin steering. When set false (the default) zero-downtime failover will only occur between origins within the same pool. See session_affinity_attributes for control over when sessions are broken or reassigned.
            fallback_pool: (String) The pool ID to use when all other pools are detected as unhealthy.
            fixed_response: (Attributes) A collection of fields used to directly respond to the eyeball instead of routing to a pool. If a fixed_response is supplied the rule will be marked as terminates. (see below for nested schema)
            headers: '(List of String) Configures the names of HTTP headers to base session affinity on when header session_affinity is enabled. At least one HTTP header name must be provided. To specify the exact cookies to be used, include an item in the following format: "cookie:<cookie-name-1>,<cookie-name-2>" (example) where everything after the colon is a comma-separated list of cookie names. Providing only "cookie" will result in all cookies being used. The default max number of HTTP header names that can be provided depends on your plan: 5 for Enterprise, 1 for all other plans.'
            id: (String) The ID of this resource.
            location: (String) The http 'Location' header to include in the response.
            location_strategy: (Attributes) Controls location-based steering for non-proxied requests. See steering_policy to learn how steering is affected. (see below for nested schema)
            message_body: (String) Text to include as the http body.
            mode: (String) Determines the authoritative location when ECS is not preferred, does not exist in the request, or its GeoIP lookup is unsuccessful.
            modified_on: (String)
            name: (String) The DNS hostname to associate with your Load Balancer. If this hostname already exists as a DNS record in Cloudflare's DNS, the Load Balancer will take precedence and the DNS record will not be used.
            networks: (List of String) List of networks where Load Balancer or Pool is enabled.
            overrides: (Attributes) A collection of overrides to apply to the load balancer when this rule's condition is true. All fields are optional. (see below for nested schema)
            pool_weights: (Map of Number) A mapping of pool IDs to custom weights. The weight is relative to other pools in the load balancer.
            pop_pools: '(Map of List of String) Enterprise only: A mapping of Cloudflare PoP identifiers to a list of pool IDs (ordered by their failover priority) for the PoP (datacenter). Any PoPs not explicitly defined will fall back to using the corresponding country_pool, then region_pool mapping if it exists else to default_pools.'
            prefer_ecs: (String) Whether the EDNS Client Subnet (ECS) GeoIP should be preferred as the authoritative location.
            priority: (Number) The order in which rules should be executed in relation to each other. Lower values are executed first. Values do not need to be sequential. If no value is provided for any rule the array order of the rules field will be used to assign a priority.
            proxied: (Boolean) Whether the hostname should be gray clouded (false) or orange clouded (true).
            random_steering: (Attributes) Configures pool weights.
            region_pools: (Map of List of String) A mapping of region codes to a list of pool IDs (ordered by their failover priority) for the given region. Any regions not explicitly defined will fall back to using default_pools.
            require_all_headers: '(Boolean) When header session_affinity is enabled, this option can be used to specify how HTTP headers on load balancing requests will be used. The supported values are: - "true": Load balancing requests must contain all of the HTTP headers specified by the headers session affinity attribute, otherwise sessions aren''t created. - "false": Load balancing requests must contain at least one of the HTTP headers specified by the headers session affinity attribute, otherwise sessions aren''t created.'
            rules: '(Attributes List) BETA Field Not General Access: A list of rules for this load balancer to execute. (see below for nested schema)'
            samesite: |-
                (String) Configures the SameSite attribute on session affinity cookie. Value "Auto" will be translated to "Lax" or "None" depending if Always Use HTTPS is enabled. Note: when using value "None", the secure attribute can not be set to "Never".
                Available values: "Auto", "Lax", "None", "Strict".
            secure: |-
                (String) Configures the Secure attribute on session affinity cookie. Value "Always" indicates the Secure attribute will be set in the Set-Cookie header, "Never" indicates the Secure attribute will not be set, and "Auto" will set the Secure attribute depending if Always Use HTTPS is enabled.
                Available values: "Auto", "Always", "Never".
            session_affinity: |-
                (String) Specifies the type of session affinity the load balancer should use unless specified as "none". The supported types are: - "cookie": On the first request to a proxied load balancer, a cookie is generated, encoding information of which origin the request will be forwarded to. Subsequent requests, by the same client to the same load balancer, will be sent to the origin server the cookie encodes, for the duration of the cookie and as long as the origin server remains healthy. If the cookie has expired or the origin server is unhealthy, then a new origin server is calculated and used. - "ip_cookie": Behaves the same as "cookie" except the initial origin selection is stable and based on the client's ip address. - "header": On the first request to a proxied load balancer, a session key based on the configured HTTP headers (see session_affinity_attributes.headers) is generated, encoding the request headers used for storing in the load balancer session state which origin the request will be forwarded to. Subsequent requests to the load balancer with the same headers will be sent to the same origin server, for the duration of the session and as long as the origin server remains healthy. If the session has been idle for the duration of session_affinity_ttl seconds or the origin server is unhealthy, then a new origin server is calculated and used. See headers in session_affinity_attributes for additional required configuration.
                Available values: "none", "cookie", "ip_cookie", "header".
            session_affinity_attributes: (Attributes) Configures attributes for session affinity. (see below for nested schema)
            session_affinity_ttl: '(Number) Time, in seconds, until a client''s session expires after being created. Once the expiry time has been reached, subsequent requests may get sent to a different origin server. The accepted ranges per session_affinity policy are: - "cookie" / "ip_cookie": The current default of 23 hours will be used unless explicitly set. The accepted range of values is between [1800, 604800]. - "header": The current default of 1800 seconds will be used unless explicitly set. The accepted range of values is between [30, 3600]. Note: With session affinity by header, sessions only expire after they haven''t been used for the number of seconds specified.'
            status_code: (Number) The http status code to respond with.
            steering_policy: (String) Steering Policy for this load balancer.
            steering_policy="least_connections": ': Use pool weights to scale each pool''s open connections. (see below for nested schema)'
            steering_policy="least_outstanding_requests": ': Use pool weights to scale each pool''s outstanding requests.'
            steering_policy="random": ': A random pool is selected with probability proportional to pool weights.'
            terminates: (Boolean) If this rule's condition is true, this causes rule evaluation to stop after processing this rule.
            ttl: (Number) Time to live (TTL) of the DNS entry for the IP address returned by this load balancer. This only applies to gray-clouded (unproxied) load balancers.
            zero_downtime_failover: |-
                (String) Configures the zero-downtime failover between origins within a pool when session affinity is enabled. This feature is currently incompatible with Argo, Tiered Cache, and Bandwidth Alliance. The supported values are: - "none": No failover takes place for sessions pinned to the origin (default). - "temporary": Traffic will be sent to another other healthy origin until the originally pinned origin is available; note that this can potentially result in heavy origin flapping. - "sticky": The session affinity cookie is updated and subsequent requests are sent to the new origin. Note: Zero-downtime failover with sticky sessions is currently not supported for session affinity by header.
                Available values: "none", "temporary", "sticky".
            zone_id: (String)
            zone_name: (String)
        importStatements:
            - $ terraform import cloudflare_load_balancer.example '<zone_id>/<load_balancer_id>'
    cloudflare_load_balancer_monitor:
        subCategory: ""
        name: cloudflare_load_balancer_monitor
        title: cloudflare_load_balancer_monitor Resource - Cloudflare
        examples:
            - name: example_load_balancer_monitor
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "allow_insecure": true,
                  "consecutive_down": 0,
                  "consecutive_up": 0,
                  "description": "Login page monitor",
                  "expected_body": "alive",
                  "expected_codes": "2xx",
                  "follow_redirects": true,
                  "header": {
                    "Host": [
                      "example.com"
                    ],
                    "X-App-ID": [
                      "abc123"
                    ]
                  },
                  "interval": 0,
                  "method": "GET",
                  "path": "/health",
                  "port": 0,
                  "probe_zone": "example.com",
                  "retries": 0,
                  "timeout": 0,
                  "type": "https"
                }
        argumentDocs:
            account_id: (String) Identifier.
            allow_insecure: (Boolean) Do not validate the certificate when monitor use HTTPS. This parameter is currently only valid for HTTP and HTTPS monitors.
            consecutive_down: (Number) To be marked unhealthy the monitored origin must fail this healthcheck N consecutive times.
            consecutive_up: (Number) To be marked healthy the monitored origin must pass this healthcheck N consecutive times.
            created_on: (String)
            description: (String) Object description.
            expected_body: (String) A case-insensitive sub-string to look for in the response body. If this string is not found, the origin will be marked as unhealthy. This parameter is only valid for HTTP and HTTPS monitors.
            expected_codes: (String) The expected HTTP response code or code range of the health check. This parameter is only valid for HTTP and HTTPS monitors.
            follow_redirects: (Boolean) Follow redirects if returned by the origin. This parameter is only valid for HTTP and HTTPS monitors.
            header: (Map of List of String) The HTTP request headers to send in the health check. It is recommended you set a Host header by default. The User-Agent header cannot be overridden. This parameter is only valid for HTTP and HTTPS monitors.
            id: (String) The ID of this resource.
            interval: (Number) The interval between each health check. Shorter intervals may improve failover time, but will increase load on the origins as we check from multiple locations.
            method: (String) The method to use for the health check. This defaults to 'GET' for HTTP/HTTPS based checks and 'connection_established' for TCP based health checks.
            modified_on: (String)
            path: (String) The endpoint path you want to conduct a health check against. This parameter is only valid for HTTP and HTTPS monitors.
            port: '(Number) The port number to connect to for the health check. Required for TCP, UDP, and SMTP checks. HTTP and HTTPS checks should only define the port when using a non-standard port (HTTP: default 80, HTTPS: default 443).'
            probe_zone: (String) Assign this monitor to emulate the specified zone while probing. This parameter is only valid for HTTP and HTTPS monitors.
            retries: (Number) The number of retries to attempt in case of a timeout before marking the origin as unhealthy. Retries are attempted immediately.
            timeout: (Number) The timeout (in seconds) before marking the health check as failed.
            type: |-
                (String) The protocol to use for the health check. Currently supported protocols are 'HTTP','HTTPS', 'TCP', 'ICMP-PING', 'UDP-ICMP', and 'SMTP'.
                Available values: "http", "https", "tcp", "udp_icmp", "icmp_ping", "smtp".
        importStatements:
            - $ terraform import cloudflare_load_balancer_monitor.example '<account_id>/<monitor_id>'
    cloudflare_load_balancer_pool:
        subCategory: ""
        name: cloudflare_load_balancer_pool
        title: cloudflare_load_balancer_pool Resource - Cloudflare
        examples:
            - name: example_load_balancer_pool
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "description": "Primary data center - Provider XYZ",
                  "enabled": false,
                  "latitude": 0,
                  "load_shedding": {
                    "default_percent": 0,
                    "default_policy": "random",
                    "session_percent": 0,
                    "session_policy": "hash"
                  },
                  "longitude": 0,
                  "minimum_origins": 0,
                  "monitor": "monitor",
                  "monitor_group": "monitor_group",
                  "name": "primary-dc-1",
                  "notification_email": "someone@example.com,sometwo@example.com",
                  "notification_filter": {
                    "origin": {
                      "disable": true,
                      "healthy": true
                    },
                    "pool": {
                      "disable": true,
                      "healthy": false
                    }
                  },
                  "origin_steering": {
                    "policy": "random"
                  },
                  "origins": [
                    {
                      "address": "0.0.0.0",
                      "enabled": true,
                      "header": {
                        "host": [
                          "example.com"
                        ]
                      },
                      "name": "app-server-1",
                      "port": 0,
                      "virtual_network_id": "a5624d4e-044a-4ff0-b3e1-e2465353d4b4",
                      "weight": 0.6
                    }
                  ]
                }
        argumentDocs:
            '"hash"': ': Select an origin by computing a hash over the CF-Connecting-IP address.'
            '"least_connections"': |-
                : Select an origin by taking into consideration origin weights, as well as each origin's number of open connections. Origins with more open connections are weighted proportionately less relative to others. Supported for HTTP/1 and HTTP/2 connections.
                Available values: "random", "hash", "least_outstanding_requests", "least_connections".
            '"least_outstanding_requests"': ': Select an origin by taking into consideration origin weights, as well as each origin''s number of outstanding requests. Origins with more pending requests are weighted proportionately less relative to others.'
            '"random"': ': Select an origin randomly.'
            account_id: (String) Identifier.
            address: (String) The IP address (IPv4 or IPv6) of the origin, or its publicly addressable hostname. Hostnames entered here should resolve directly to the origin, and not be a hostname proxied by Cloudflare. To set an internal/reserved address, virtual_network_id must also be set.
            check_regions: (List of String) A list of regions from which to run health checks. Null means every Cloudflare data center.
            created_on: (String)
            default_percent: (Number) The percent of traffic to shed from the pool, according to the default policy. Applies to new sessions and traffic without session affinity.
            default_policy: |-
                (String) The default policy to use when load shedding. A random policy randomly sheds a given percent of requests. A hash policy computes a hash over the CF-Connecting-IP address and sheds all requests originating from a percent of IPs.
                Available values: "random", "hash".
            description: (String) A human-readable description of the pool.
            disable: (Boolean) If set true, disable notifications for this type of resource (pool or origin).
            disabled_at: (String) This field shows up only if the pool is disabled. This field is set with the time the pool was disabled at.
            enabled: (Boolean) Whether to enable (the default) or disable this pool. Disabled pools will not receive traffic and are excluded from health checks. Disabling a pool will cause any load balancers using it to failover to the next pool (if any).
            header: (Attributes) The request header is used to pass additional information with an HTTP request. Currently supported header is 'Host'. (see below for nested schema)
            healthy: (Boolean) If present, send notifications only for this health status (e.g. false for only DOWN events). Use null to reset (all events).
            host: (List of String) The 'Host' header allows to override the hostname set in the HTTP request. Current support is 1 'Host' header override per origin.
            id: (String) The ID of this resource.
            latitude: (Number) The latitude of the data center containing the origins used in this pool in decimal degrees. If this is set, longitude must also be set.
            load_shedding: (Attributes) Configures load shedding policies and percentages for the pool. (see below for nested schema)
            longitude: (Number) The longitude of the data center containing the origins used in this pool in decimal degrees. If this is set, latitude must also be set.
            minimum_origins: (Number) The minimum number of origins that must be healthy for this pool to serve traffic. If the number of healthy origins falls below this number, the pool will be marked unhealthy and will failover to the next available pool.
            modified_on: (String)
            monitor: (String) The ID of the Monitor to use for checking the health of origins within this pool.
            monitor_group: (String) The ID of the Monitor Group to use for checking the health of origins within this pool.
            name: (String) A short name (tag) for the pool. Only alphanumeric characters, hyphens, and underscores are allowed.
            networks: (List of String) List of networks where Load Balancer or Pool is enabled.
            notification_email: (String) This field is now deprecated. It has been moved to Cloudflare's Centralized Notification service https://developers.cloudflare.com/fundamentals/notifications/. The email address to send health status notifications to. This can be an individual mailbox or a mailing list. Multiple emails can be supplied as a comma delimited list.
            notification_filter: (Attributes) Filter pool and origin health notifications by resource type or health status. Use null to reset. (see below for nested schema)
            origin: (Attributes) Filter options for a particular resource type (pool or origin). Use null to reset. (see below for nested schema)
            origin_steering: (Attributes) Configures origin steering for the pool. Controls how origins are selected for new sessions and traffic without session affinity. (see below for nested schema)
            origin_steering.policy="least_connections": ': Use weight to scale the origin''s open connections.'
            origin_steering.policy="least_outstanding_requests": ': Use weight to scale the origin''s outstanding requests.'
            origins: (Attributes List) The list of origins within this pool. Traffic directed at this pool is balanced across all currently healthy origins, provided the pool itself is healthy. (see below for nested schema)
            policy: (String) The type of origin steering policy to use.
            pool: (Attributes) Filter options for a particular resource type (pool or origin). Use null to reset. (see below for nested schema)
            port: (Number) The port for upstream connections. A value of 0 means the default port for the protocol will be used.
            session_percent: (Number) The percent of existing sessions to shed from the pool, according to the session policy.
            session_policy: |-
                (String) Only the hash policy is supported for existing sessions (to avoid exponential decay).
                Available values: "hash".
            virtual_network_id: (String) The virtual network subnet ID the origin belongs in. Virtual network must also belong to the account.
            weight: (Number) The weight of this origin relative to other origins in the pool. Based on the configured weight the total traffic is distributed among origins within the pool.
        importStatements:
            - $ terraform import cloudflare_load_balancer_pool.example '<account_id>/<pool_id>'
    cloudflare_logpull_retention:
        subCategory: ""
        name: cloudflare_logpull_retention
        title: cloudflare_logpull_retention Resource - Cloudflare
        examples:
            - name: example_logpull_retention
              manifest: |-
                {
                  "flag": true,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            flag: (Boolean) The log retention flag for Logpull API.
            id: (String) Identifier.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_logpull_retention.example '<zone_id>'
    cloudflare_logpush_job:
        subCategory: ""
        name: cloudflare_logpush_job
        title: cloudflare_logpush_job Resource - Cloudflare
        examples:
            - name: example_logpush_job
              manifest: |-
                {
                  "dataset": "gateway_dns",
                  "destination_conf": "s3://mybucket/logs?region=us-west-2",
                  "enabled": false,
                  "filter": "{\"where\":{\"and\":[{\"key\":\"ClientRequestPath\",\"operator\":\"contains\",\"value\":\"/static\"},{\"key\":\"ClientRequestHost\",\"operator\":\"eq\",\"value\":\"example.com\"}]}}",
                  "frequency": "high",
                  "kind": "",
                  "logpull_options": "fields=RayID,ClientIP,EdgeStartTimestamp\u0026timestamps=rfc3339",
                  "max_upload_bytes": 5000000,
                  "max_upload_interval_seconds": 30,
                  "max_upload_records": 1000,
                  "name": "example.com",
                  "output_options": {
                    "batch_prefix": "",
                    "batch_suffix": "",
                    "cve_2021_44228": false,
                    "field_delimiter": ",",
                    "field_names": [
                      "Datetime",
                      "DstIP",
                      "SrcIP"
                    ],
                    "output_type": "ndjson",
                    "record_delimiter": "",
                    "record_prefix": "{",
                    "record_suffix": "    }\n\n",
                    "record_template": "record_template",
                    "sample_rate": 1,
                    "timestamp_format": "unixnano"
                  },
                  "ownership_challenge": "00000000000000000000",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            batch_prefix: (String) String to be prepended before each batch.
            batch_suffix: (String) String to be appended after each batch.
            cve_2021_44228: (Boolean) If set to true, will cause all occurrences of ${ in the generated files to be replaced with x{.
            dataset: |-
                (String) Name of the dataset. A list of supported datasets can be found on the Developer Docs.
                Available values: "access_requests", "audit_logs", "audit_logs_v2", "biso_user_actions", "casb_findings", "device_posture_results", "dex_application_tests", "dex_device_state_events", "dlp_forensic_copies", "dns_firewall_logs", "dns_logs", "email_security_alerts", "firewall_events", "gateway_dns", "gateway_http", "gateway_network", "http_requests", "ipsec_logs", "magic_ids_detections", "nel_reports", "network_analytics_logs", "page_shield_events", "sinkhole_http_logs", "spectrum_events", "ssh_logs", "warp_config_changes", "warp_toggle_changes", "workers_trace_events", "zaraz_events", "zero_trust_network_sessions".
            destination_conf: (String) Uniquely identifies a resource (such as an s3 bucket) where data. will be pushed. Additional configuration parameters supported by the destination may be included.
            enabled: (Boolean) Flag that indicates if the job is enabled.
            error_message: '(String) If not null, the job is currently failing. Failures are usually. repetitive (example: no permissions to write to destination bucket). Only the last failure is recorded. On successful execution of a job the error_message and last_error are set to null.'
            field_delimiter: (String) String to join fields. This field be ignored when record_template is set.
            field_names: (List of String) List of field names to be included in the Logpush output. For the moment, there is no option to add all fields at once, so you must specify all the fields names you are interested in.
            filter: (String) The filters to select the events to include and/or remove from your logs. For more information, refer to Filters.
            frequency: |-
                (String, Deprecated) This field is deprecated. Please use max_upload_* parameters instead. . The frequency at which Cloudflare sends batches of logs to your destination. Setting frequency to high sends your logs in larger quantities of smaller files. Setting frequency to low sends logs in smaller quantities of larger files.
                Available values: "high", "low".
            id: (Number) Unique id of the job.
            kind: |-
                (String) The kind parameter (optional) is used to differentiate between Logpush and Edge Log Delivery jobs (when supported by the dataset).
                Available values: "", "edge".
            last_complete: (String) Records the last time for which logs have been successfully pushed. If the last successful push was for logs range 2018-07-23T10:00:00Z to 2018-07-23T10:01:00Z then the value of this field will be 2018-07-23T10:01:00Z. If the job has never run or has just been enabled and hasn't run yet then the field will be empty.
            last_error: (String) Records the last time the job failed. If not null, the job is currently. failing. If null, the job has either never failed or has run successfully at least once since last failure. See also the error_message field.
            logpull_options: (String, Deprecated) This field is deprecated. Use output_options instead. Configuration string. It specifies things like requested fields and timestamp formats. If migrating from the logpull api, copy the url (full url or just the query string) of your call here, and logpush will keep on making this call for you, setting start and end times appropriately.
            max_upload_bytes: (Number) The maximum uncompressed file size of a batch of logs. This setting value must be between 5 MB and 1 GB, or 0 to disable it. Note that you cannot set a minimum file size; this means that log files may be much smaller than this batch size.
            max_upload_interval_seconds: (Number) The maximum interval in seconds for log batches. This setting must be between 30 and 300 seconds (5 minutes), or 0 to disable it. Note that you cannot specify a minimum interval for log batches; this means that log files may be sent in shorter intervals than this.
            max_upload_records: (Number) The maximum number of log lines per batch. This setting must be between 1000 and 1,000,000 lines, or 0 to disable it. Note that you cannot specify a minimum number of log lines per batch; this means that log files may contain many fewer lines than this.
            name: (String) Optional human readable job name. Not unique. Cloudflare suggests. that you set this to a meaningful string, like the domain name, to make it easier to identify your job.
            output_options: (Attributes) The structured replacement for logpull_options. When including this field, the logpull_option field will be ignored. (see below for nested schema)
            output_type: |-
                (String) Specifies the output type, such as ndjson or csv. This sets default values for the rest of the settings, depending on the chosen output type. Some formatting rules, like string quoting, are different between output types.
                Available values: "ndjson", "csv".
            ownership_challenge: (String, Sensitive) Ownership challenge token to prove destination ownership.
            record_delimiter: (String) String to be inserted in-between the records as separator.
            record_prefix: (String) String to be prepended before each record.
            record_suffix: (String) String to be appended after each record.
            record_template: (String) String to use as template for each record instead of the default json key value mapping. All fields used in the template must be present in field_names as well, otherwise they will end up as null. Format as a Go text/template without any standard functions, like conditionals, loops, sub-templates, etc.
            sample_rate: (Number) Floating number to specify sampling rate. Sampling is applied on top of filtering, and regardless of the current sample_interval of the data.
            timestamp_format: |-
                (String) String to specify the format for timestamps, such as unixnano, unix, or rfc3339.
                Available values: "unixnano", "unix", "rfc3339".
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_logpush_job.example '<{accounts|zones}/{account_id|zone_id}>/<job_id>'
    cloudflare_logpush_ownership_challenge:
        subCategory: ""
        name: cloudflare_logpush_ownership_challenge
        title: cloudflare_logpush_ownership_challenge Resource - Cloudflare
        examples:
            - name: example_logpush_ownership_challenge
              manifest: |-
                {
                  "destination_conf": "s3://mybucket/logs?region=us-west-2",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            destination_conf: (String) Uniquely identifies a resource (such as an s3 bucket) where data. will be pushed. Additional configuration parameters supported by the destination may be included.
            filename: (String)
            message: (String)
            valid: (Boolean)
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements: []
    cloudflare_magic_network_monitoring_configuration:
        subCategory: ""
        name: cloudflare_magic_network_monitoring_configuration
        title: cloudflare_magic_network_monitoring_configuration Resource - Cloudflare
        examples:
            - name: example_magic_network_monitoring_configuration
              manifest: |-
                {
                  "account_id": "6f91088a406011ed95aed352566e8d4c",
                  "default_sampling": 1,
                  "name": "cloudflare user's account",
                  "router_ips": [
                    "203.0.113.1"
                  ],
                  "warp_devices": [
                    {
                      "id": "5360368d-b351-4791-abe1-93550dabd351",
                      "name": "My warp device",
                      "router_ip": "203.0.113.1"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String)
            default_sampling: (Number) Fallback sampling rate of flow messages being sent in packets per second. This should match the packet sampling rate configured on the router.
            id: (String) Unique identifier for the warp device.
            name: (String) The account name.
            router_ip: (String) IPv4 CIDR of the router sourcing flow data associated with this warp device. Only /32 addresses are currently supported.
            router_ips: (List of String)
            warp_devices: (Attributes List) (see below for nested schema)
        importStatements: []
    cloudflare_magic_network_monitoring_rule:
        subCategory: ""
        name: cloudflare_magic_network_monitoring_rule
        title: cloudflare_magic_network_monitoring_rule Resource - Cloudflare
        examples:
            - name: example_magic_network_monitoring_rule
              manifest: |-
                {
                  "account_id": "6f91088a406011ed95aed352566e8d4c",
                  "automatic_advertisement": true,
                  "bandwidth": 1000,
                  "duration": "1m",
                  "name": "my_rule_1",
                  "packet_threshold": 10000,
                  "prefixes": [
                    "203.0.113.1/32"
                  ]
                }
        argumentDocs:
            account_id: (String)
            automatic_advertisement: (Boolean) Toggle on if you would like Cloudflare to automatically advertise the IP Prefixes within the rule via Magic Transit when the rule is triggered. Only available for users of Magic Transit.
            bandwidth: (Number) The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
            bandwidth_threshold: (Number) The number of bits per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
            duration: |-
                (String) The amount of time that the rule threshold must be exceeded to send an alert notification. The final value must be equivalent to one of the following 8 values ["1m","5m","10m","15m","20m","30m","45m","60m"].
                Available values: "1m", "5m", "10m", "15m", "20m", "30m", "45m", "60m".
            id: (String) The id of the rule. Must be unique.
            name: (String) The name of the rule. Must be unique. Supports characters A-Z, a-z, 0-9, underscore (_), dash (-), period (.), and tilde (~). You cant have a space in the rule name. Max 256 characters.
            packet_threshold: (Number) The number of packets per second for the rule. When this value is exceeded for the set duration, an alert notification is sent. Minimum of 1 and no maximum.
            prefix_match: |-
                (String) Prefix match type to be applied for a prefix auto advertisement when using an advanced_ddos rule.
                Available values: "exact", "subnet", "supernet".
            prefixes: (List of String)
            type: |-
                (String) MNM rule type.
                Available values: "threshold", "zscore", "advanced_ddos".
            zscore_sensitivity: |-
                (String) Level of sensitivity set for zscore rules.
                Available values: "low", "medium", "high".
            zscore_target: |-
                (String) Target of the zscore rule analysis.
                Available values: "bits", "packets".
        importStatements:
            - $ terraform import cloudflare_magic_network_monitoring_rule.example '<account_id>/<rule_id>'
    cloudflare_magic_transit_connector:
        subCategory: ""
        name: cloudflare_magic_transit_connector
        title: cloudflare_magic_transit_connector Resource - Cloudflare
        examples:
            - name: example_magic_transit_connector
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "activated": true,
                  "device": {
                    "id": "id",
                    "provision_license": true,
                    "serial_number": "serial_number"
                  },
                  "interrupt_window_duration_hours": 0,
                  "interrupt_window_hour_of_day": 0,
                  "notes": "notes",
                  "timezone": "timezone"
                }
        argumentDocs:
            account_id: (String) Account identifier
            activated: (Boolean)
            device: (Attributes) (see below for nested schema)
            id: (String) The ID of this resource.
            interrupt_window_duration_hours: (Number)
            interrupt_window_hour_of_day: (Number)
            license_key: (String, Sensitive) License key for the connector. This is only returned on creation and will not be available in subsequent reads.
            notes: (String)
            provision_license: (Boolean) Set to true to provision a license key for this connector. Only used during resource creation. This is a write-only field that will not be stored in state.
            serial_number: (String)
            timezone: (String)
        importStatements:
            - $ terraform import cloudflare_magic_transit_connector.example '<account_id>/<connector_id>'
    cloudflare_magic_transit_site:
        subCategory: ""
        name: cloudflare_magic_transit_site
        title: cloudflare_magic_transit_site Resource - Cloudflare
        examples:
            - name: example_magic_transit_site
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "connector_id": "ac60d3d0435248289d446cedd870bcf4",
                  "description": "description",
                  "ha_mode": true,
                  "location": {
                    "lat": "37.6192",
                    "lon": "122.3816"
                  },
                  "name": "site_1",
                  "secondary_connector_id": "8d67040d3835dbcf46ce29da440dc482"
                }
        argumentDocs:
            account_id: (String) Identifier
            connector_id: (String) Magic Connector identifier tag.
            description: (String)
            ha_mode: (Boolean) Site high availability mode. If set to true, the site can have two connectors and runs in high availability mode.
            id: (String) Identifier
            lat: (String) Latitude
            location: (Attributes) Location of site in latitude and longitude. (see below for nested schema)
            lon: (String) Longitude
            name: (String) The name of the site.
            secondary_connector_id: (String) Magic Connector identifier tag. Used when high availability mode is on.
        importStatements:
            - $ terraform import cloudflare_magic_transit_site.example '<account_id>/<site_id>'
    cloudflare_magic_transit_site_acl:
        subCategory: ""
        name: cloudflare_magic_transit_site_acl
        title: cloudflare_magic_transit_site_acl Resource - Cloudflare
        examples:
            - name: example_magic_transit_site_acl
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "description": "Allows local traffic between PIN pads and cash register.",
                  "forward_locally": true,
                  "lan_1": {
                    "lan_id": "lan_id",
                    "lan_name": "lan_name",
                    "port_ranges": [
                      "8080-9000"
                    ],
                    "ports": [
                      1
                    ],
                    "subnets": [
                      "192.0.2.1"
                    ]
                  },
                  "lan_2": {
                    "lan_id": "lan_id",
                    "lan_name": "lan_name",
                    "port_ranges": [
                      "8080-9000"
                    ],
                    "ports": [
                      1
                    ],
                    "subnets": [
                      "192.0.2.1"
                    ]
                  },
                  "name": "PIN Pad - Cash Register",
                  "protocols": [
                    "tcp"
                  ],
                  "site_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "unidirectional": true
                }
        argumentDocs:
            account_id: (String) Identifier
            description: (String) Description for the ACL.
            forward_locally: (Boolean) The desired forwarding action for this ACL policy. If set to "false", the policy will forward traffic to Cloudflare. If set to "true", the policy will forward traffic locally on the Magic Connector. If not included in request, will default to false.
            id: (String) Identifier
            lan_1: (Attributes) (see below for nested schema)
            lan_2: (Attributes) (see below for nested schema)
            lan_id: (String) The identifier for the LAN you want to create an ACL policy with.
            lan_name: (String) The name of the LAN based on the provided lan_id.
            name: (String) The name of the ACL.
            port_ranges: (List of String) Array of port ranges on the provided LAN that will be included in the ACL. If no ports or port rangess are provided, communication on any port on this LAN is allowed.
            ports: (List of Number) Array of ports on the provided LAN that will be included in the ACL. If no ports or port ranges are provided, communication on any port on this LAN is allowed.
            protocols: (List of String)
            site_id: (String) Identifier
            subnets: (List of String) Array of subnet IPs within the LAN that will be included in the ACL. If no subnets are provided, communication on any subnets on this LAN are allowed.
            unidirectional: (Boolean) The desired traffic direction for this ACL policy. If set to "false", the policy will allow bidirectional traffic. If set to "true", the policy will only allow traffic in one direction. If not included in request, will default to false.
        importStatements:
            - $ terraform import cloudflare_magic_transit_site_acl.example '<account_id>/<site_id>/<acl_id>'
    cloudflare_magic_transit_site_lan:
        subCategory: ""
        name: cloudflare_magic_transit_site_lan
        title: cloudflare_magic_transit_site_lan Resource - Cloudflare
        examples:
            - name: example_magic_transit_site_lan
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "ha_link": true,
                  "name": "name",
                  "nat": {
                    "static_prefix": "192.0.2.0/24"
                  },
                  "physport": 1,
                  "routed_subnets": [
                    {
                      "nat": {
                        "static_prefix": "192.0.2.0/24"
                      },
                      "next_hop": "192.0.2.1",
                      "prefix": "192.0.2.0/24"
                    }
                  ],
                  "site_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "static_addressing": {
                    "address": "192.0.2.0/24",
                    "dhcp_relay": {
                      "server_addresses": [
                        "192.0.2.1"
                      ]
                    },
                    "dhcp_server": {
                      "dhcp_pool_end": "192.0.2.1",
                      "dhcp_pool_start": "192.0.2.1",
                      "dns_server": "192.0.2.1",
                      "dns_servers": [
                        "192.0.2.1"
                      ],
                      "reservations": {
                        "00:11:22:33:44:55": "192.0.2.100",
                        "AA:BB:CC:DD:EE:FF": "192.168.1.101"
                      }
                    },
                    "secondary_address": "192.0.2.0/24",
                    "virtual_address": "192.0.2.0/24"
                  },
                  "vlan_tag": 42
                }
        argumentDocs:
            account_id: (String) Identifier
            address: (String) A valid CIDR notation representing an IP range.
            dhcp_pool_end: (String) A valid IPv4 address.
            dhcp_pool_start: (String) A valid IPv4 address.
            dhcp_relay: (Attributes) (see below for nested schema)
            dhcp_server: (Attributes) (see below for nested schema)
            dns_server: (String) A valid IPv4 address.
            dns_servers: (List of String)
            ha_link: (Boolean) mark true to use this LAN for HA probing. only works for site with HA turned on. only one LAN can be set as the ha_link.
            id: (String) Identifier
            name: (String)
            nat: (Attributes) (see below for nested schema)
            next_hop: (String) A valid IPv4 address.
            physport: (Number)
            prefix: (String) A valid CIDR notation representing an IP range.
            reservations: (Map of String) Mapping of MAC addresses to IP addresses
            routed_subnets: (Attributes List) (see below for nested schema)
            secondary_address: (String) A valid CIDR notation representing an IP range.
            server_addresses: (List of String) List of DHCP server IPs.
            site_id: (String) Identifier
            static_addressing: (Attributes) If the site is not configured in high availability mode, this configuration is optional (if omitted, use DHCP). However, if in high availability mode, static_address is required along with secondary and virtual address. (see below for nested schema)
            static_prefix: (String) A valid CIDR notation representing an IP range.
            virtual_address: (String) A valid CIDR notation representing an IP range.
            vlan_tag: (Number) VLAN ID. Use zero for untagged.
        importStatements:
            - $ terraform import cloudflare_magic_transit_site_lan.example '<account_id>/<site_id>/<lan_id>'
    cloudflare_magic_transit_site_wan:
        subCategory: ""
        name: cloudflare_magic_transit_site_wan
        title: cloudflare_magic_transit_site_wan Resource - Cloudflare
        examples:
            - name: example_magic_transit_site_wan
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "name",
                  "physport": 1,
                  "priority": 0,
                  "site_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "static_addressing": {
                    "address": "192.0.2.0/24",
                    "gateway_address": "192.0.2.1",
                    "secondary_address": "192.0.2.0/24"
                  },
                  "vlan_tag": 42
                }
        argumentDocs:
            account_id: (String) Identifier
            address: (String) A valid CIDR notation representing an IP range.
            gateway_address: (String) A valid IPv4 address.
            health_check_rate: |-
                (String) Magic WAN health check rate for tunnels created on this link. The default value is mid.
                Available values: "low", "mid", "high".
            id: (String) Identifier
            name: (String)
            physport: (Number)
            priority: (Number)
            secondary_address: (String) A valid CIDR notation representing an IP range.
            site_id: (String) Identifier
            static_addressing: (Attributes) (optional) if omitted, use DHCP. Submit secondary_address when site is in high availability mode. (see below for nested schema)
            vlan_tag: (Number) VLAN ID. Use zero for untagged.
        importStatements:
            - $ terraform import cloudflare_magic_transit_site_wan.example '<account_id>/<site_id>/<wan_id>'
    cloudflare_magic_wan_gre_tunnel:
        subCategory: ""
        name: cloudflare_magic_wan_gre_tunnel
        title: cloudflare_magic_wan_gre_tunnel Resource - Cloudflare
        examples:
            - name: example_magic_wan_gre_tunnel
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "automatic_return_routing": true,
                  "bgp": {
                    "customer_asn": 0,
                    "extra_prefixes": [
                      "string"
                    ],
                    "md5_key": "md5_key"
                  },
                  "cloudflare_gre_endpoint": "203.0.113.1",
                  "customer_gre_endpoint": "203.0.113.1",
                  "description": "Tunnel for ISP X",
                  "health_check": {
                    "direction": "bidirectional",
                    "enabled": true,
                    "rate": "low",
                    "target": {
                      "saved": "203.0.113.1"
                    },
                    "type": "request"
                  },
                  "interface_address": "192.0.2.0/31",
                  "interface_address6": "2606:54c1:7:0:a9fe:12d2:1:200/127",
                  "mtu": 0,
                  "name": "GRE_1",
                  "ttl": 0
                }
        argumentDocs:
            '''!@#$%^&*()+[]{}<>/.,;:_-~': = |`
            account_id: (String) Identifier
            automatic_return_routing: (Boolean) True if automatic stateful return routing should be enabled for a tunnel, false otherwise.
            bgp: (Attributes) (see below for nested schema)
            bgp_state: (String)
            bgp_status: (Attributes) (see below for nested schema)
            cf_speaker_ip: (String)
            cf_speaker_port: (Number)
            cloudflare_gre_endpoint: (String) The IP address assigned to the Cloudflare side of the GRE tunnel.
            created_on: (String) The date and time the tunnel was created.
            customer_asn: (Number) ASN used on the customer end of the BGP session
            customer_gre_endpoint: (String) The IP address assigned to the customer side of the GRE tunnel.
            customer_speaker_ip: (String)
            customer_speaker_port: (Number)
            description: (String) An optional description of the GRE tunnel.
            direction: |-
                (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
                Available values: "unidirectional", "bidirectional".
            effective: (String) The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
            enabled: (Boolean) Determines whether to run healthchecks for a tunnel.
            extra_prefixes: (List of String) Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.
            health_check: (Attributes) (see below for nested schema)
            id: (String) Identifier
            interface_address: '(String) A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.'
            interface_address6: (String) A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127
            md5_key: (String) MD5 key to use for session authentication.
            modified_on: (String) The date and time the tunnel was last modified.
            mtu: (Number) Maximum Transmission Unit (MTU) in bytes for the GRE tunnel. The minimum value is 576.
            name: (String) The name of the tunnel. The name cannot contain spaces or special characters, must be 15 characters or less, and cannot share a name with another GRE tunnel.
            rate: |-
                (String) How frequent the health check is run. The default value is mid.
                Available values: "low", "mid", "high".
            saved: (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
            state: '(String) Available values: "BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING".'
            target: (Attributes) The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to customer_gre_endpoint address. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
            tcp_established: (Boolean)
            ttl: (Number) Time To Live (TTL) in number of hops of the GRE tunnel.
            type: |-
                (String) The type of healthcheck to run, reply or request. The default value is reply.
                Available values: "reply", "request".
            updated_at: (String)
        importStatements:
            - $ terraform import cloudflare_magic_wan_gre_tunnel.example '<account_id>/<gre_tunnel_id>'
    cloudflare_magic_wan_ipsec_tunnel:
        subCategory: ""
        name: cloudflare_magic_wan_ipsec_tunnel
        title: cloudflare_magic_wan_ipsec_tunnel Resource - Cloudflare
        examples:
            - name: example_magic_wan_ipsec_tunnel
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "automatic_return_routing": true,
                  "bgp": {
                    "customer_asn": 0,
                    "extra_prefixes": [
                      "string"
                    ],
                    "md5_key": "md5_key"
                  },
                  "cloudflare_endpoint": "203.0.113.1",
                  "custom_remote_identities": {
                    "fqdn_id": "fqdn_id"
                  },
                  "customer_endpoint": "203.0.113.1",
                  "description": "Tunnel for ISP X",
                  "health_check": {
                    "direction": "bidirectional",
                    "enabled": true,
                    "rate": "low",
                    "target": {
                      "saved": "203.0.113.1"
                    },
                    "type": "request"
                  },
                  "interface_address": "192.0.2.0/31",
                  "interface_address6": "2606:54c1:7:0:a9fe:12d2:1:200/127",
                  "name": "IPsec_1",
                  "psk": "O3bwKSjnaoCxDoUxjcq4Rk8ZKkezQUiy",
                  "replay_protection": false
                }
        argumentDocs:
            '''!@#$%^&*()+[]{}<>/.,;:_-~': = |`
            account_id: (String) Identifier
            allow_null_cipher: (Boolean) When true, the tunnel can use a null-cipher (ENCR_NULL) in the ESP tunnel (Phase 2).
            automatic_return_routing: (Boolean) True if automatic stateful return routing should be enabled for a tunnel, false otherwise.
            bgp: (Attributes) (see below for nested schema)
            bgp_state: (String)
            bgp_status: (Attributes) (see below for nested schema)
            cf_speaker_ip: (String)
            cf_speaker_port: (Number)
            cloudflare_endpoint: (String) The IP address assigned to the Cloudflare side of the IPsec tunnel.
            created_on: (String) The date and time the tunnel was created.
            custom_remote_identities: (Attributes) (see below for nested schema)
            customer_asn: (Number) ASN used on the customer end of the BGP session
            customer_endpoint: (String) The IP address assigned to the customer side of the IPsec tunnel. Not required, but must be set for proactive traceroutes to work.
            customer_speaker_ip: (String)
            customer_speaker_port: (Number)
            description: (String) An optional description forthe IPsec tunnel.
            direction: |-
                (String) The direction of the flow of the healthcheck. Either unidirectional, where the probe comes to you via the tunnel and the result comes back to Cloudflare via the open Internet, or bidirectional where both the probe and result come and go via the tunnel.
                Available values: "unidirectional", "bidirectional".
            effective: (String) The effective health check target. If 'saved' is empty, then this field will be populated with the calculated default value on GET requests. Ignored in POST, PUT, and PATCH requests.
            enabled: (Boolean) Determines whether to run healthchecks for a tunnel.
            extra_prefixes: (List of String) Prefixes in this list will be advertised to the customer device, in addition to the routes in the Magic routing table.
            fqdn_id: |-
                (String) A custom IKE ID of type FQDN that may be used to identity the IPsec tunnel. The
                generated IKE IDs can still be used even if this custom value is specified.
            health_check: (Attributes) (see below for nested schema)
            id: (String) Identifier
            interface_address: '(String) A 31-bit prefix (/31 in CIDR notation) supporting two hosts, one for each side of the tunnel. Select the subnet from the following private IP space: 10.0.0.010.255.255.255, 172.16.0.0172.31.255.255, 192.168.0.0192.168.255.255.'
            interface_address6: (String) A 127 bit IPV6 prefix from within the virtual_subnet6 prefix space with the address being the first IP of the subnet and not same as the address of virtual_subnet6. Eg if virtual_subnet6 is 2606:54c1:7:0:a9fe:12d2::/127 , interface_address6 could be 2606:54c1:7:0:a9fe:12d2:1:200/127
            last_generated_on: (String) The date and time the tunnel was last modified.
            md5_key: (String) MD5 key to use for session authentication.
            modified_on: (String) The date and time the tunnel was last modified.
            name: (String) The name of the IPsec tunnel. The name cannot share a name with other tunnels.
            psk: (String, Sensitive) A randomly generated or provided string for use in the IPsec tunnel.
            psk_metadata: (Attributes) The PSK metadata that includes when the PSK was generated. (see below for nested schema)
            rate: |-
                (String) How frequent the health check is run. The default value is mid.
                Available values: "low", "mid", "high".
            replay_protection: (Boolean) If true, then IPsec replay protection will be supported in the Cloudflare-to-customer direction.
            saved: (String) The saved health check target. Setting the value to the empty string indicates that the calculated default value will be used.
            state: '(String) Available values: "BGP_DOWN", "BGP_UP", "BGP_ESTABLISHING".'
            target: (Attributes) The destination address in a request type health check. After the healthcheck is decapsulated at the customer end of the tunnel, the ICMP echo will be forwarded to this address. This field defaults to customer_gre_endpoint address. This field is ignored for bidirectional healthchecks as the interface_address (not assigned to the Cloudflare side of the tunnel) is used as the target. Must be in object form if the x-magic-new-hc-target header is set to true and string form if x-magic-new-hc-target is absent or set to false. (see below for nested schema)
            tcp_established: (Boolean)
            type: |-
                (String) The type of healthcheck to run, reply or request. The default value is reply.
                Available values: "reply", "request".
            updated_at: (String)
        importStatements:
            - $ terraform import cloudflare_magic_wan_ipsec_tunnel.example '<account_id>/<ipsec_tunnel_id>'
    cloudflare_magic_wan_static_route:
        subCategory: ""
        name: cloudflare_magic_wan_static_route
        title: cloudflare_magic_wan_static_route Resource - Cloudflare
        examples:
            - name: example_magic_wan_static_route
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "description": "New route for new prefix 203.0.113.1",
                  "nexthop": "203.0.113.1",
                  "prefix": "192.0.2.0/24",
                  "priority": 0,
                  "scope": {
                    "colo_names": [
                      "den01"
                    ],
                    "colo_regions": [
                      "APAC"
                    ]
                  },
                  "weight": 0
                }
        argumentDocs:
            account_id: (String) Identifier
            colo_names: (List of String) List of colo names for the ECMP scope.
            colo_regions: (List of String) List of colo regions for the ECMP scope.
            created_on: (String) When the route was created.
            description: (String) An optional human provided description of the static route.
            id: (String) Identifier
            modified_on: (String) When the route was last modified.
            nexthop: (String) The next-hop IP Address for the static route.
            prefix: (String) IP Prefix in Classless Inter-Domain Routing format.
            priority: (Number) Priority of the static route.
            scope: (Attributes) Used only for ECMP routes. (see below for nested schema)
            weight: (Number) Optional weight of the ECMP scope - if provided.
        importStatements:
            - $ terraform import cloudflare_magic_wan_static_route.example '<account_id>/<route_id>'
    cloudflare_managed_transforms:
        subCategory: ""
        name: cloudflare_managed_transforms
        title: cloudflare_managed_transforms Resource - Cloudflare
        examples:
            - name: example_managed_transforms
              manifest: |-
                {
                  "managed_request_headers": [
                    {
                      "enabled": true,
                      "id": "add_bot_protection_headers"
                    }
                  ],
                  "managed_response_headers": [
                    {
                      "enabled": true,
                      "id": "add_security_headers"
                    }
                  ],
                  "zone_id": "9f1839b6152d298aca64c4e906b6d074"
                }
        argumentDocs:
            enabled: (Boolean) Whether the Managed Transform is enabled.
            id: (String) The unique ID of the zone.
            managed_request_headers: (Attributes Set) The list of Managed Request Transforms. (see below for nested schema)
            managed_response_headers: (Attributes Set) The list of Managed Response Transforms. (see below for nested schema)
            zone_id: (String) The unique ID of the zone.
        importStatements:
            - $ terraform import cloudflare_managed_transforms.example '<zone_id>'
    cloudflare_mtls_certificate:
        subCategory: ""
        name: cloudflare_mtls_certificate
        title: cloudflare_mtls_certificate Resource - Cloudflare
        examples:
            - name: example_mtls_certificate
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "ca": true,
                  "certificates": "  -----BEGIN CERTIFICATE-----\n  MIIDmDCCAoCgAwIBAgIUKTOAZNjcXVZRj4oQt0SHsl1c1vMwDQYJKoZIhvcNAQELBQAwUTELMAkGA1UEBhMCVVMxFjAUBgNVBAgMDVNhbiBGcmFuY2lzY28xEzARBgNVBAcMCkNhbGlmb3JuaWExFTATBgNVBAoMDEV4YW1wbGUgSW5jLjAgFw0yMjExMjIxNjU5NDdaGA8yMTIyMTAyOTE2NTk0N1owUTELMAkGA1UEBhMCVVMxFjAUBgNVBAgMDVNhbiBGcmFuY2lzY28xEzARBgNVBAcMCkNhbGlmb3JuaWExFTATBgNVBAoMDEV4YW1wbGUgSW5jLjCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBAMRcORwgJFTdcG/2GKI+cFYiOBNDKjCZUXEOvXWY42BkH9wxiMT869CO+enA1w5pIrXow6kCM1sQspHHaVmJUlotEMJxyoLFfA/8Kt1EKFyobOjuZs2SwyVyJ2sStvQuUQEosULZCNGZEqoH5g6zhMPxaxm7ZLrrsDZ9maNGVqo7EWLWHrZ57Q/5MtTrbxQL+eXjUmJ9K3kS+3uEwMdqR6Z3BluU1ivanpPc1CN2GNhdO0/hSY4YkGEnuLsqJyDd3cIiB1MxuCBJ4ZaqOd2viV1WcP3oU3dxVPm4MWyfYIldMWB14FahScxLhWdRnM9YZ/i9IFcLypXsuz7DjrJPtPUCAwEAAaNmMGQwHQYDVR0OBBYEFP5JzLUawNF+c3AXsYTEWHh7z2czMB8GA1UdIwQYMBaAFP5JzLUawNF+c3AXsYTEWHh7z2czMA4GA1UdDwEB/wQEAwIBBjASBgNVHRMBAf8ECDAGAQH/AgEBMA0GCSqGSIb3DQEBCwUAA4IBAQBc+Be7NDhpE09y7hLPZGRPl1cSKBw4RI0XIv6rlbSTFs5EebpTGjhx/whNxwEZhB9HZ7111Oa1YlT8xkI9DshB78mjAHCKBAJ76moK8tkG0aqdYpJ4ZcJTVBB7l98Rvgc7zfTii7WemTy72deBbSeiEtXavm4EF0mWjHhQ5Nxpnp00Bqn5g1x8CyTDypgmugnep+xG+iFzNmTdsz7WI9T/7kDMXqB7M/FPWBORyS98OJqNDswCLF8bIZYwUBEe+bRHFomoShMzaC3tvim7WCb16noDkSTMlfKO4pnvKhpcVdSgwcruATV7y+W+Lvmz2OT/Gui4JhqeoTewsxndhDDE\n  -----END CERTIFICATE-----\n",
                  "name": "example_ca_cert",
                  "private_key": "  -----BEGIN PRIVATE KEY-----\n  MIIEvQIBADANBgkqhkiG9w0BAQEFAASCBKcwggSjAgEAAoIBAQDEXDkcICRU3XBv9hiiPnBWIjgTQyowmVFxDr11mONgZB/cMYjE/OvQjvnpwNcOaSK16MOpAjNbELKRx2lZiVJaLRDCccqCxXwP/CrdRChcqGzo7mbNksMlcidrErb0LlEBKLFC2QjRmRKqB+YOs4TD8WsZu2S667A2fZmjRlaqOxFi1h62ee0P+TLU628UC/nl41JifSt5Evt7hMDHakemdwZblNYr2p6T3NQjdhjYXTtP4UmOGJBhJ7i7Kicg3d3CIgdTMbggSeGWqjndr4ldVnD96FN3cVT5uDFsn2CJXTFgdeBWoUnMS4VnUZzPWGf4vSBXC8qV7Ls+w46yT7T1AgMBAAECggEAQZnp/oqCeNPOR6l5S2L+1tfx0gWjZ78hJVteUpZ0iHSK7F6kKeOxyOird7vUXV0kmo+cJq+0hp0Ke4eam640FCpwKfYoSQ4/R3vgujGWJnaihCN5tv5sMet0XeJPuz5qE7ALoKCvwI6aXLHs20aAeZIDTQJ9QbGSGnJVzOWn+JDTidIgZpN57RpXfSAwnJPTQK/PN8i5z108hsaDOdEgGmxYZ7kYqMqzX20KXmth58LDfPixs5JGtS60iiKC/wOcGzkB2/AdTSojR76oEU77cANP/3zO25NG//whUdYlW0t0d7PgXxIeJe+xgYnamDQJx3qonVyt4H77ha0ObRAj9QKBgQDicZr+VTwFMnELP3a+FXGnjehRiuS1i7MXGKxNweCD+dFlML0FplSQS8Ro2n+d8lu8BBXGx0qm6VXu8Rhn7TAUL6q+PCgfarzxfIhacb/TZCqfieIHsMlVBfhV5HCXnk+kis0tuC/PRArcWTwDHJUJXkBhvkUsNswvQzavDPI7KwKBgQDd/WgLkj7A3X5fgIHZH/GbDSBiXwzKb+rF4ZCT2XFgG/OAW7vapfcX/w+v+5lBLyrocmOAS3PGGAhM5T3HLnUCQfnK4qgps1Lqibkc9Tmnsn60LanUjuUMsYv/zSw70tozbzhJ0pioEpWfRxRZBztO2Rr8Ntm7h6Fk701EXGNAXwKBgQCD1xsjy2J3sCerIdcz0u5qXLAPkeuZW+34m4/ucdwTWwc0gEz9lhsULFj9p4G351zLuiEnq+7mAWLcDJlmIO3mQt6JhiLiL9Y0T4pgBmxmWqKKYtAsJB0EmMY+1BNN44mBRqMxZFTJu1cLdhT/xstrOeoIPqytknYNanfTMZlzIwKBgHrLXe5oq0XMP8dcMneEcAUwsaU4pr6kQd3L9EmUkl5zl7J9C+DaxWAEuwzBw/iGutlxzRB+rD/7szu14wJ29EqXbDGKRzMp+se5/yfBjm7xEZ1hVPw7PwBShfqt57X/4Ktq7lwHnmH6RcGhc+P7WBc5iO/S94YAdIp8xOT3pf9JAoGAE0QkqJUY+5Mgr+fBO0VNV72ZoPveGpW+De59uhKAOnu1zljQCUtk59m6+DXfm0tNYKtawa5n8iN71Zh+s62xXSt3pYi1Y5CCCmv8Y4BhwIcPwXKk3zEvLgSHVTpC0bayA9aSO4bbZgVXa5w+Z0w/vvfp9DWo1IS3EnQRrz6WMYA=\n  -----END PRIVATE KEY-----\n"
                }
        argumentDocs:
            account_id: (String) Identifier.
            ca: (Boolean) Indicates whether the certificate is a CA or leaf certificate.
            certificates: (String) The uploaded root CA certificate.
            expires_on: (String) When the certificate expires.
            id: (String) Identifier.
            issuer: (String) The certificate authority that issued the certificate.
            name: (String) Optional unique name for the certificate. Only used for human readability.
            private_key: (String, Sensitive) The private key for the certificate. This field is only needed for specific use cases such as using a custom certificate with Zero Trust's block page.
            serial_number: (String) The certificate serial number.
            signature: (String) The type of hash used for the certificate.
            updated_at: (String) This is the time the certificate was updated.
            uploaded_on: (String) This is the time the certificate was uploaded.
        importStatements:
            - $ terraform import cloudflare_mtls_certificate.example '<account_id>/<mtls_certificate_id>'
    cloudflare_notification_policy:
        subCategory: ""
        name: cloudflare_notification_policy
        title: cloudflare_notification_policy Resource - Cloudflare
        examples:
            - name: example_notification_policy
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "alert_interval": "30m",
                  "alert_type": "universal_ssl_event_type",
                  "description": "Something describing the policy.",
                  "enabled": true,
                  "filters": {
                    "actions": [
                      "string"
                    ],
                    "affected_asns": [
                      "string"
                    ],
                    "affected_components": [
                      "string"
                    ],
                    "affected_locations": [
                      "string"
                    ],
                    "airport_code": [
                      "string"
                    ],
                    "alert_trigger_preferences": [
                      "string"
                    ],
                    "alert_trigger_preferences_value": [
                      "string"
                    ],
                    "enabled": [
                      "string"
                    ],
                    "environment": [
                      "string"
                    ],
                    "event": [
                      "string"
                    ],
                    "event_source": [
                      "string"
                    ],
                    "event_type": [
                      "string"
                    ],
                    "group_by": [
                      "string"
                    ],
                    "health_check_id": [
                      "string"
                    ],
                    "incident_impact": [
                      "INCIDENT_IMPACT_NONE"
                    ],
                    "input_id": [
                      "string"
                    ],
                    "insight_class": [
                      "string"
                    ],
                    "limit": [
                      "string"
                    ],
                    "logo_tag": [
                      "string"
                    ],
                    "megabits_per_second": [
                      "string"
                    ],
                    "new_health": [
                      "string"
                    ],
                    "new_status": [
                      "string"
                    ],
                    "packets_per_second": [
                      "string"
                    ],
                    "pool_id": [
                      "string"
                    ],
                    "pop_names": [
                      "string"
                    ],
                    "product": [
                      "string"
                    ],
                    "project_id": [
                      "string"
                    ],
                    "protocol": [
                      "string"
                    ],
                    "query_tag": [
                      "string"
                    ],
                    "requests_per_second": [
                      "string"
                    ],
                    "selectors": [
                      "string"
                    ],
                    "services": [
                      "string"
                    ],
                    "slo": [
                      "99.9"
                    ],
                    "status": [
                      "string"
                    ],
                    "target_hostname": [
                      "string"
                    ],
                    "target_ip": [
                      "string"
                    ],
                    "target_zone_name": [
                      "string"
                    ],
                    "traffic_exclusions": [
                      "security_events"
                    ],
                    "tunnel_id": [
                      "string"
                    ],
                    "tunnel_name": [
                      "string"
                    ],
                    "type": [
                      "string"
                    ],
                    "where": [
                      "string"
                    ],
                    "zones": [
                      "string"
                    ]
                  },
                  "mechanisms": {
                    "email": [
                      {
                        "id": "id"
                      }
                    ],
                    "pagerduty": [
                      {
                        "id": "f174e90afafe4643bbbc4a0ed4fc8415"
                      }
                    ],
                    "webhooks": [
                      {
                        "id": "f174e90afafe4643bbbc4a0ed4fc8415"
                      }
                    ]
                  },
                  "name": "SSL Notification Event Policy"
                }
        argumentDocs:
            account_id: (String) The account id
            actions: (List of String) Usage depends on specific alert type
            affected_asns: (List of String) Used for configuring radar_notification
            affected_components: (List of String) Used for configuring incident_alert
            affected_locations: (List of String) Used for configuring radar_notification
            airport_code: (List of String) Used for configuring maintenance_event_notification
            alert_interval: (String) Optional specification of how often to re-alert from the same incident, not support on all alert types.
            alert_trigger_preferences: (List of String) Usage depends on specific alert type
            alert_trigger_preferences_value: (List of String) Usage depends on specific alert type
            alert_type: |-
                (String) Refers to which event will trigger a Notification dispatch. You can use the endpoint to get available alert types which then will give you a list of possible values.
                Available values: "abuse_report_alert", "access_custom_certificate_expiration_type", "advanced_ddos_attack_l4_alert", "advanced_ddos_attack_l7_alert", "advanced_http_alert_error", "bgp_hijack_notification", "billing_usage_alert", "block_notification_block_removed", "block_notification_new_block", "block_notification_review_rejected", "bot_traffic_basic_alert", "brand_protection_alert", "brand_protection_digest", "clickhouse_alert_fw_anomaly", "clickhouse_alert_fw_ent_anomaly", "cloudforce_one_request_notification", "custom_analytics", "custom_bot_detection_alert", "custom_ssl_certificate_event_type", "dedicated_ssl_certificate_event_type", "device_connectivity_anomaly_alert", "dos_attack_l4", "dos_attack_l7", "expiring_service_token_alert", "failing_logpush_job_disabled_alert", "fbm_auto_advertisement", "fbm_dosd_attack", "fbm_volumetric_attack", "health_check_status_notification", "hostname_aop_custom_certificate_expiration_type", "http_alert_edge_error", "http_alert_origin_error", "image_notification", "image_resizing_notification", "incident_alert", "load_balancing_health_alert", "load_balancing_pool_enablement_alert", "logo_match_alert", "magic_tunnel_health_check_event", "magic_wan_tunnel_health", "maintenance_event_notification", "mtls_certificate_store_certificate_expiration_type", "pages_event_alert", "radar_notification", "real_origin_monitoring", "scriptmonitor_alert_new_code_change_detections", "scriptmonitor_alert_new_hosts", "scriptmonitor_alert_new_malicious_hosts", "scriptmonitor_alert_new_malicious_scripts", "scriptmonitor_alert_new_malicious_url", "scriptmonitor_alert_new_max_length_resource_url", "scriptmonitor_alert_new_resources", "secondary_dns_all_primaries_failing", "secondary_dns_primaries_failing", "secondary_dns_warning", "secondary_dns_zone_successfully_updated", "secondary_dns_zone_validation_warning", "security_insights_alert", "sentinel_alert", "stream_live_notifications", "synthetic_test_latency_alert", "synthetic_test_low_availability_alert", "traffic_anomalies_alert", "tunnel_health_event", "tunnel_update_event", "universal_ssl_event_type", "web_analytics_metrics_update", "zone_aop_custom_certificate_expiration_type".
            created: (String)
            description: (String) Optional description for the Notification policy.
            email: (Attributes Set) (see below for nested schema)
            enabled: (Boolean) Whether or not the Notification policy is enabled.
            environment: (List of String) Used for configuring pages_event_alert
            event: (List of String) Used for configuring pages_event_alert
            event_source: (List of String) Used for configuring load_balancing_health_alert
            event_type: (List of String) Usage depends on specific alert type
            filters: (Attributes) Optional filters that allow you to be alerted only on a subset of events for that alert type based on some criteria. This is only available for select alert types. See alert type documentation for more details. (see below for nested schema)
            group_by: (List of String) Usage depends on specific alert type
            health_check_id: (List of String) Used for configuring health_check_status_notification
            id: (String) UUID
            incident_impact: (List of String) Used for configuring incident_alert
            input_id: (List of String) Used for configuring stream_live_notifications
            insight_class: (List of String) Used for configuring security_insights_alert
            limit: (List of String) Used for configuring billing_usage_alert
            logo_tag: (List of String) Used for configuring logo_match_alert
            mechanisms: (Attributes) List of IDs that will be used when dispatching a notification. IDs for email type will be the email address. (see below for nested schema)
            megabits_per_second: (List of String) Used for configuring advanced_ddos_attack_l4_alert
            modified: (String)
            name: (String) Name of the policy.
            new_health: (List of String) Used for configuring load_balancing_health_alert
            new_status: (List of String) Used for configuring tunnel_health_event
            packets_per_second: (List of String) Used for configuring advanced_ddos_attack_l4_alert
            pagerduty: (Attributes Set) (see below for nested schema)
            pool_id: (List of String) Usage depends on specific alert type
            pop_names: (List of String) Usage depends on specific alert type
            product: (List of String) Used for configuring billing_usage_alert
            project_id: (List of String) Used for configuring pages_event_alert
            protocol: (List of String) Used for configuring advanced_ddos_attack_l4_alert
            query_tag: (List of String) Usage depends on specific alert type
            requests_per_second: (List of String) Used for configuring advanced_ddos_attack_l7_alert
            selectors: (List of String) Usage depends on specific alert type
            services: (List of String) Used for configuring clickhouse_alert_fw_ent_anomaly
            slo: (List of String) Usage depends on specific alert type
            status: (List of String) Used for configuring health_check_status_notification
            target_hostname: (List of String) Used for configuring advanced_ddos_attack_l7_alert
            target_ip: (List of String) Used for configuring advanced_ddos_attack_l4_alert
            target_zone_name: (List of String) Used for configuring advanced_ddos_attack_l7_alert
            traffic_exclusions: (List of String) Used for configuring traffic_anomalies_alert
            tunnel_id: (List of String) Used for configuring tunnel_health_event
            tunnel_name: (List of String) Usage depends on specific alert type
            type: (List of String) Usage depends on specific alert type
            webhooks: (Attributes Set) (see below for nested schema)
            where: (List of String) Usage depends on specific alert type
            zones: (List of String) Usage depends on specific alert type
        importStatements:
            - $ terraform import cloudflare_notification_policy.example '<account_id>/<policy_id>'
    cloudflare_notification_policy_webhooks:
        subCategory: ""
        name: cloudflare_notification_policy_webhooks
        title: cloudflare_notification_policy_webhooks Resource - Cloudflare
        examples:
            - name: example_notification_policy_webhooks
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "Slack Webhook",
                  "secret": "secret",
                  "url": "https://hooks.slack.com/services/Ds3fdBFbV/456464Gdd"
                }
        argumentDocs:
            account_id: (String) The account id
            created_at: (String) Timestamp of when the webhook destination was created.
            id: (String) UUID
            last_failure: (String) Timestamp of the last time an attempt to dispatch a notification to this webhook failed.
            last_success: (String) Timestamp of the last time Cloudflare was able to successfully dispatch a notification using this webhook.
            name: (String) The name of the webhook destination. This will be included in the request body when you receive a webhook notification.
            secret: (String, Sensitive) Optional secret that will be passed in the cf-webhook-auth header when dispatching generic webhook notifications or formatted for supported destinations. Secrets are not returned in any API response body.
            type: |-
                (String) Type of webhook endpoint.
                Available values: "datadog", "discord", "feishu", "gchat", "generic", "opsgenie", "slack", "splunk".
            url: (String) The POST endpoint to call when dispatching a notification.
        importStatements:
            - $ terraform import cloudflare_notification_policy_webhooks.example '<account_id>/<webhook_id>'
    cloudflare_observatory_scheduled_test:
        subCategory: ""
        name: cloudflare_observatory_scheduled_test
        title: cloudflare_observatory_scheduled_test Resource - Cloudflare
        examples:
            - name: example_observatory_scheduled_test
              manifest: |-
                {
                  "url": "example.com",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            cls: (Number) Cumulative Layout Shift.
            code: |-
                (String) The error code of the Lighthouse result.
                Available values: "NOT_REACHABLE", "DNS_FAILURE", "NOT_HTML", "LIGHTHOUSE_TIMEOUT", "UNKNOWN".
            date: (String)
            desktop_report: (Attributes) The Lighthouse report. (see below for nested schema)
            detail: (String) Detailed error message.
            device_type: |-
                (String) The type of device.
                Available values: "DESKTOP", "MOBILE".
            error: (Attributes) (see below for nested schema)
            fcp: (Number) First Contentful Paint.
            final_displayed_url: (String) The final URL displayed to the user.
            frequency: |-
                (String) The frequency of the test.
                Available values: "DAILY", "WEEKLY".
            id: (String) A URL.
            json_report_url: (String) The URL to the full Lighthouse JSON report.
            label: (String)
            lcp: (Number) Largest Contentful Paint.
            mobile_report: (Attributes) The Lighthouse report. (see below for nested schema)
            performance_score: (Number) The Lighthouse performance score.
            region: |-
                (String) A test region.
                Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
            schedule: (Attributes) The test schedule. (see below for nested schema)
            schedule_frequency: |-
                (String) The frequency of the test.
                Available values: "DAILY", "WEEKLY".
            si: (Number) Speed Index.
            state: |-
                (String) The state of the Lighthouse report.
                Available values: "RUNNING", "COMPLETE", "FAILED".
            tbt: (Number) Total Blocking Time.
            test: (Attributes) (see below for nested schema)
            ttfb: (Number) Time To First Byte.
            tti: (Number) Time To Interactive.
            url: (String) A URL.
            value: |-
                (String) A test region.
                Available values: "asia-east1", "asia-northeast1", "asia-northeast2", "asia-south1", "asia-southeast1", "australia-southeast1", "europe-north1", "europe-southwest1", "europe-west1", "europe-west2", "europe-west3", "europe-west4", "europe-west8", "europe-west9", "me-west1", "southamerica-east1", "us-central1", "us-east1", "us-east4", "us-south1", "us-west1".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_observatory_scheduled_test.example '<zone_id>/<url>'
    cloudflare_organization:
        subCategory: ""
        name: cloudflare_organization
        title: cloudflare_organization Resource - Cloudflare
        examples:
            - name: example_organization
              manifest: |-
                {
                  "name": "name",
                  "parent": {
                    "id": "a7b9c3d2e8f4g1h5i6j0k9l2m3n7o4p8"
                  },
                  "profile": {
                    "business_address": "business_address",
                    "business_email": "business_email",
                    "business_name": "business_name",
                    "business_phone": "business_phone",
                    "external_metadata": "external_metadata"
                  }
                }
        argumentDocs:
            account_creation: (String)
            account_deletion: (String)
            account_migration: (String)
            account_mobility: (String)
            business_address: (String)
            business_email: (String)
            business_name: (String)
            business_phone: (String)
            create_time: (String)
            external_metadata: (String)
            flags: (Attributes) Enable features for Organizations. (see below for nested schema)
            id: (String) The ID of this resource.
            managed_by: (String)
            meta: (Attributes) (see below for nested schema)
            name: (String)
            parent: (Attributes) (see below for nested schema)
            profile: (Attributes) (see below for nested schema)
            sub_org_creation: (String)
        importStatements:
            - $ terraform import cloudflare_organization.example '<organization_id>'
    cloudflare_organization_profile:
        subCategory: ""
        name: cloudflare_organization_profile
        title: cloudflare_organization_profile Resource - Cloudflare
        examples:
            - name: example_organization_profile
              manifest: |-
                {
                  "business_address": "business_address",
                  "business_email": "business_email",
                  "business_name": "business_name",
                  "business_phone": "business_phone",
                  "external_metadata": "external_metadata",
                  "organization_id": "a7b9c3d2e8f4g1h5i6j0k9l2m3n7o4p8"
                }
        argumentDocs:
            business_address: (String)
            business_email: (String)
            business_name: (String)
            business_phone: (String)
            external_metadata: (String)
            organization_id: (String)
        importStatements: []
    cloudflare_origin_ca_certificate:
        subCategory: ""
        name: cloudflare_origin_ca_certificate
        title: cloudflare_origin_ca_certificate Resource - Cloudflare
        examples:
            - name: example_origin_ca_certificate
              manifest: |-
                {
                  "csr": "  -----BEGIN CERTIFICATE REQUEST-----\n  MIICxzCCAa8CAQAwSDELMAkGA1UEBhMCVVMxFjAUBgNVBAgTDVNhbiBGcmFuY2lz\n  Y28xCzAJBgNVBAcTAkNBMRQwEgYDVQQDEwtleGFtcGxlLm5ldDCCASIwDQYJKoZI\n  hvcNAQEBBQADggEPADCCAQoCggEBALxejtu4b+jPdFeFi6OUsye8TYJQBm3WfCvL\n  Hu5EvijMO/4Z2TImwASbwUF7Ir8OLgH+mGlQZeqyNvGoSOMEaZVXcYfpR1hlVak8\n  4GGVr+04IGfOCqaBokaBFIwzclGZbzKmLGwIQioNxGfqFm6RGYGA3be2Je2iseBc\n  N8GV1wYmvYE0RR+yWweJCTJ157exyRzu7sVxaEW9F87zBQLyOnwXc64rflXslRqi\n  g7F7w5IaQYOl8yvmk/jEPCAha7fkiUfEpj4N12+oPRiMvleJF98chxjD4MH39c5I\n  uOslULhrWunfh7GB1jwWNA9y44H0snrf+xvoy2TcHmxvma9Eln8CAwEAAaA6MDgG\n  CSqGSIb3DQEJDjErMCkwJwYDVR0RBCAwHoILZXhhbXBsZS5uZXSCD3d3dy5leGFt\n  cGxlLm5ldDANBgkqhkiG9w0BAQsFAAOCAQEAcBaX6dOnI8ncARrI9ZSF2AJX+8mx\n  pTHY2+Y2C0VvrVDGMtbBRH8R9yMbqWtlxeeNGf//LeMkSKSFa4kbpdx226lfui8/\n  auRDBTJGx2R1ccUxmLZXx4my0W5iIMxunu+kez+BDlu7bTT2io0uXMRHue4i6quH\n  yc5ibxvbJMjR7dqbcanVE10/34oprzXQsJ/VmSuZNXtjbtSKDlmcpw6To/eeAJ+J\n  hXykcUihvHyG4A1m2R6qpANBjnA0pHexfwM/SgfzvpbvUg0T1ubmer8BgTwCKIWs\n  dcWYTthM51JIqRBfNqy4QcBnX+GY05yltEEswQI55wdiS3CjTTA67sdbcQ==\n  -----END CERTIFICATE REQUEST-----\n",
                  "hostnames": [
                    "example.com",
                    "*.example.com"
                  ],
                  "request_type": "origin-rsa",
                  "requested_validity": 5475
                }
        argumentDocs:
            certificate: (String) The Origin CA certificate. Will be newline-encoded.
            csr: (String) The Certificate Signing Request (CSR). Must be newline-encoded.
            expires_on: (String) When the certificate will expire.
            hostnames: (List of String) Array of hostnames or wildcard names (e.g., *.example.com) bound to the certificate.
            id: (String) Identifier.
            request_type: |-
                (String) Signature type desired on certificate ("origin-rsa" (rsa), "origin-ecc" (ecdsa), or "keyless-certificate" (for Keyless SSL servers).
                Available values: "origin-rsa", "origin-ecc", "keyless-certificate".
            requested_validity: |-
                (Number) The number of days for which the certificate should be valid.
                Available values: 7, 30, 90, 365, 730, 1095, 5475.
        importStatements:
            - $ terraform import cloudflare_origin_ca_certificate.example '<certificate_id>'
    cloudflare_page_rule:
        subCategory: ""
        name: cloudflare_page_rule
        title: cloudflare_page_rule Resource - Cloudflare
        examples:
            - name: example_page_rule
              manifest: |-
                {
                  "actions": {
                    "forwarding_url": {
                      "status_code": 301,
                      "url": "https://example.com/foo"
                    }
                  },
                  "priority": 1,
                  "status": "active",
                  "target": "example.com/*",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            actions: (Attributes) (see below for nested schema)
            always_use_https: (Boolean)
            automatic_https_rewrites: (String)
            browser_cache_ttl: (Number)
            browser_check: (String)
            bypass_cache_on_cookie: (String)
            cache_by_device_type: (String)
            cache_deception_armor: (String)
            cache_key_fields: (Attributes) (see below for nested schema)
            cache_level: (String)
            cache_on_cookie: (String)
            cache_ttl_by_status: (Map of String)
            check_presence: (List of String)
            cookie: (Attributes) (see below for nested schema)
            created_on: (String) The timestamp of when the Page Rule was created.
            device_type: (Boolean)
            disable_apps: (Boolean)
            disable_performance: (Boolean)
            disable_security: (Boolean)
            disable_zaraz: (Boolean)
            edge_cache_ttl: (Number)
            email_obfuscation: (String)
            exclude: (List of String)
            explicit_cache_control: (String)
            forwarding_url: (Attributes) (see below for nested schema)
            geo: (Boolean)
            header: (Attributes) (see below for nested schema)
            host: (Attributes) (see below for nested schema)
            host_header_override: (String)
            id: (String) Identifier.
            include: (List of String)
            ip_geolocation: (String)
            lang: (Boolean)
            mirage: (String)
            modified_on: (String) The timestamp of when the Page Rule was last modified.
            opportunistic_encryption: (String)
            origin_error_page_pass_thru: (String)
            polish: (String)
            priority: |-
                (Number) The priority of the rule, used to define which Page Rule is processed
                over another. A higher number indicates a higher priority. For example,
                if you have a catch-all Page Rule (rule A: /images/*) but want a more
                specific Page Rule to take precedence (rule B: /images/special/*),
                specify a higher priority for rule B so it overrides rule A.
            query_string: (Attributes) (see below for nested schema)
            resolve_override: (String)
            resolved: (Boolean)
            respect_strong_etag: (String)
            response_buffering: (String)
            rocket_loader: (String)
            security_level: (String)
            sort_query_string_for_cache: (String)
            ssl: (String)
            status: |-
                (String) The status of the Page Rule.
                Available values: "active", "disabled".
            status_code: (Number)
            target: (String)
            true_client_ip_header: (String)
            url: (String)
            user: (Attributes) (see below for nested schema)
            waf: (String)
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_page_rule.example '<zone_id>/<pagerule_id>'
    cloudflare_page_shield_policy:
        subCategory: ""
        name: cloudflare_page_shield_policy
        title: cloudflare_page_shield_policy Resource - Cloudflare
        examples:
            - name: example_page_shield_policy
              manifest: |-
                {
                  "action": "allow",
                  "description": "Checkout page CSP policy",
                  "enabled": true,
                  "expression": "ends_with(http.request.uri.path, \"/checkout\")",
                  "value": "script-src 'none';",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            action: |-
                (String) The action to take if the expression matches
                Available values: "allow", "log".
            description: (String) A description for the policy
            enabled: (Boolean) Whether the policy is enabled
            expression: (String) The expression which must match for the policy to be applied, using the Cloudflare Firewall rule expression syntax
            id: (String) Identifier
            value: (String) The policy which will be applied
            zone_id: (String) Identifier
        importStatements:
            - $ terraform import cloudflare_page_shield_policy.example '<zone_id>/<policy_id>'
    cloudflare_pages_domain:
        subCategory: ""
        name: cloudflare_pages_domain
        title: cloudflare_pages_domain Resource - Cloudflare
        examples:
            - name: example_pages_domain
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "this-is-my-domain-01.com",
                  "project_name": "this-is-my-project-01"
                }
        argumentDocs:
            account_id: (String) Identifier.
            certificate_authority: '(String) Available values: "google", "lets_encrypt".'
            created_on: (String)
            domain_id: (String)
            error_message: (String)
            id: (String) The domain name.
            method: '(String) Available values: "http", "txt".'
            name: (String) The domain name.
            project_name: (String) Name of the project.
            status: '(String) Available values: "initializing", "pending", "active", "deactivated", "blocked", "error".'
            txt_name: (String)
            txt_value: (String)
            validation_data: (Attributes) (see below for nested schema)
            verification_data: (Attributes) (see below for nested schema)
            zone_tag: (String)
        importStatements:
            - $ terraform import cloudflare_pages_domain.example '<account_id>/<project_name>/<domain_name>'
    cloudflare_pages_project:
        subCategory: ""
        name: cloudflare_pages_project
        title: cloudflare_pages_project Resource - Cloudflare
        examples:
            - name: example_pages_project
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "build_config": {
                    "build_caching": true,
                    "build_command": "npm run build",
                    "destination_dir": "build",
                    "root_dir": "/",
                    "web_analytics_tag": "cee1c73f6e4743d0b5e6bb1a0bcaabcc",
                    "web_analytics_token": "021e1057c18547eca7b79f2516f06o7x"
                  },
                  "deployment_configs": {
                    "preview": {
                      "ai_bindings": {
                        "AI_BINDING": {
                          "project_id": "some-project-id"
                        }
                      },
                      "always_use_latest_compatibility_date": false,
                      "analytics_engine_datasets": {
                        "ANALYTICS_ENGINE_BINDING": {
                          "dataset": "api_analytics"
                        }
                      },
                      "browsers": {
                        "BROWSER": {}
                      },
                      "build_image_major_version": 3,
                      "compatibility_date": "2025-01-01",
                      "compatibility_flags": [
                        "url_standard"
                      ],
                      "d1_databases": {
                        "D1_BINDING": {
                          "id": "445e2955-951a-43f8-a35b-a4d0c8138f63"
                        }
                      },
                      "durable_object_namespaces": {
                        "DO_BINDING": {
                          "namespace_id": "5eb63bbbe01eeed093cb22bb8f5acdc3"
                        }
                      },
                      "env_vars": {
                        "foo": {
                          "type": "plain_text",
                          "value": "hello world"
                        }
                      },
                      "fail_open": true,
                      "hyperdrive_bindings": {
                        "HYPERDRIVE": {
                          "id": "a76a99bc342644deb02c38d66082262a"
                        }
                      },
                      "kv_namespaces": {
                        "KV_BINDING": {
                          "namespace_id": "5eb63bbbe01eeed093cb22bb8f5acdc3"
                        }
                      },
                      "limits": {
                        "cpu_ms": 100
                      },
                      "mtls_certificates": {
                        "MTLS": {
                          "certificate_id": "d7cdd17c-916f-4cb7-aabe-585eb382ec4e"
                        }
                      },
                      "placement": {
                        "mode": "smart"
                      },
                      "queue_producers": {
                        "QUEUE_PRODUCER_BINDING": {
                          "name": "some-queue"
                        }
                      },
                      "r2_buckets": {
                        "R2_BINDING": {
                          "jurisdiction": "eu",
                          "name": "some-bucket"
                        }
                      },
                      "services": {
                        "SERVICE_BINDING": {
                          "entrypoint": "MyHandler",
                          "environment": "production",
                          "service": "example-worker"
                        }
                      },
                      "usage_model": "standard",
                      "vectorize_bindings": {
                        "VECTORIZE": {
                          "index_name": "my_index"
                        }
                      },
                      "wrangler_config_hash": "abc123def456"
                    },
                    "production": {
                      "ai_bindings": {
                        "AI_BINDING": {
                          "project_id": "some-project-id"
                        }
                      },
                      "always_use_latest_compatibility_date": false,
                      "analytics_engine_datasets": {
                        "ANALYTICS_ENGINE_BINDING": {
                          "dataset": "api_analytics"
                        }
                      },
                      "browsers": {
                        "BROWSER": {}
                      },
                      "build_image_major_version": 3,
                      "compatibility_date": "2025-01-01",
                      "compatibility_flags": [
                        "url_standard"
                      ],
                      "d1_databases": {
                        "D1_BINDING": {
                          "id": "445e2955-951a-43f8-a35b-a4d0c8138f63"
                        }
                      },
                      "durable_object_namespaces": {
                        "DO_BINDING": {
                          "namespace_id": "5eb63bbbe01eeed093cb22bb8f5acdc3"
                        }
                      },
                      "env_vars": {
                        "foo": {
                          "type": "plain_text",
                          "value": "hello world"
                        }
                      },
                      "fail_open": true,
                      "hyperdrive_bindings": {
                        "HYPERDRIVE": {
                          "id": "a76a99bc342644deb02c38d66082262a"
                        }
                      },
                      "kv_namespaces": {
                        "KV_BINDING": {
                          "namespace_id": "5eb63bbbe01eeed093cb22bb8f5acdc3"
                        }
                      },
                      "limits": {
                        "cpu_ms": 100
                      },
                      "mtls_certificates": {
                        "MTLS": {
                          "certificate_id": "d7cdd17c-916f-4cb7-aabe-585eb382ec4e"
                        }
                      },
                      "placement": {
                        "mode": "smart"
                      },
                      "queue_producers": {
                        "QUEUE_PRODUCER_BINDING": {
                          "name": "some-queue"
                        }
                      },
                      "r2_buckets": {
                        "R2_BINDING": {
                          "jurisdiction": "eu",
                          "name": "some-bucket"
                        }
                      },
                      "services": {
                        "SERVICE_BINDING": {
                          "entrypoint": "MyHandler",
                          "environment": "production",
                          "service": "example-worker"
                        }
                      },
                      "usage_model": "standard",
                      "vectorize_bindings": {
                        "VECTORIZE": {
                          "index_name": "my_index"
                        }
                      },
                      "wrangler_config_hash": "abc123def456"
                    }
                  },
                  "name": "my-pages-app",
                  "production_branch": "main",
                  "source": {
                    "config": {
                      "deployments_enabled": true,
                      "owner": "my-org",
                      "owner_id": "12345678",
                      "path_excludes": [
                        "string"
                      ],
                      "path_includes": [
                        "string"
                      ],
                      "pr_comments_enabled": true,
                      "preview_branch_excludes": [
                        "string"
                      ],
                      "preview_branch_includes": [
                        "string"
                      ],
                      "preview_deployment_setting": "all",
                      "production_branch": "main",
                      "production_deployments_enabled": true,
                      "repo_id": "12345678",
                      "repo_name": "my-repo"
                    },
                    "type": "github"
                  }
                }
        argumentDocs:
            account_id: (String) Identifier.
            ai_bindings: (Attributes Map) Constellation bindings used for Pages Functions. (see below for nested schema)
            aliases: (List of String) A list of alias URLs pointing to this deployment.
            always_use_latest_compatibility_date: (Boolean) Whether to always use the latest compatibility date for Pages Functions.
            analytics_engine_datasets: (Attributes Map) Analytics Engine bindings used for Pages Functions. (see below for nested schema)
            branch: (String) Where the trigger happened.
            browsers: (Attributes Map) Browser bindings used for Pages Functions. (see below for nested schema)
            build_caching: (Boolean) Enable build caching for the project.
            build_command: (String) Command used to build project.
            build_config: (Attributes) Configs for the project build process. (see below for nested schema)
            build_image_major_version: (Number) The major version of the build image to use for Pages Functions.
            canonical_deployment: (Attributes) Most recent production deployment of the project. (see below for nested schema)
            certificate_id: (String)
            commit_dirty: (Boolean) Whether the deployment trigger commit was dirty.
            commit_hash: (String) Hash of the deployment trigger commit.
            commit_message: (String) Message of the deployment trigger commit.
            compatibility_date: (String) Compatibility date used for Pages Functions.
            compatibility_flags: (List of String) Compatibility flags used for Pages Functions.
            config: (Attributes) (see below for nested schema)
            cpu_ms: (Number) CPU time limit in milliseconds.
            created_on: (String) When the project was created.
            d1_databases: (Attributes Map) D1 databases used for Pages Functions. (see below for nested schema)
            dataset: (String) Name of the dataset.
            deployment_configs: (Attributes) Configs for deployments in a project. (see below for nested schema)
            deployment_trigger: (Attributes) Info about what caused the deployment. (see below for nested schema)
            deployments_enabled: |-
                (Boolean, Deprecated) Whether to enable automatic deployments when pushing to the source repository.
                When disabled, no deployments (production or preview) will be triggered automatically.
            destination_dir: (String) Output directory of the build.
            domains: (List of String) A list of associated custom domains for the project.
            durable_object_namespaces: (Attributes Map) Durable Object namespaces used for Pages Functions. (see below for nested schema)
            ended_on: (String) When the stage ended.
            entrypoint: (String) The entrypoint to bind to.
            env_vars: (Attributes Map) Environment variables used for builds and Pages Functions. (see below for nested schema)
            environment: (String) The Service environment.
            fail_open: (Boolean) Whether to fail open when the deployment config cannot be applied.
            framework: (String) Framework the project is using.
            framework_version: (String) Version of the framework the project is using.
            hyperdrive_bindings: (Attributes Map) Hyperdrive bindings used for Pages Functions. (see below for nested schema)
            id: (String) Name of the project.
            index_name: (String)
            is_skipped: (Boolean) If the deployment has been skipped.
            jurisdiction: (String) Jurisdiction of the R2 bucket.
            kv_namespaces: (Attributes Map) KV namespaces used for Pages Functions. (see below for nested schema)
            latest_deployment: (Attributes) Most recent deployment of the project. (see below for nested schema)
            latest_stage: (Attributes) The status of the deployment. (see below for nested schema)
            limits: (Attributes) Limits for Pages Functions. (see below for nested schema)
            metadata: (Attributes) Additional info about the trigger. (see below for nested schema)
            mode: (String) Placement mode.
            modified_on: (String) When the deployment was last modified.
            mtls_certificates: (Attributes Map) mTLS bindings used for Pages Functions. (see below for nested schema)
            name: (String) Name of the project.
            namespace_id: (String) ID of the Durable Object namespace.
            owner: (String) The owner of the repository.
            owner_id: (String) The owner ID of the repository.
            path_excludes: (List of String) A list of paths that should be excluded from triggering a preview deployment. Wildcard syntax (*) is supported.
            path_includes: (List of String) A list of paths that should be watched to trigger a preview deployment. Wildcard syntax (*) is supported.
            placement: (Attributes) Placement setting used for Pages Functions. (see below for nested schema)
            pr_comments_enabled: (Boolean) Whether to enable PR comments.
            preview: (Attributes) Configs for preview deploys. (see below for nested schema)
            preview_branch_excludes: (List of String) A list of branches that should not trigger a preview deployment. Wildcard syntax (*) is supported. Must be used with preview_deployment_setting set to custom.
            preview_branch_includes: (List of String) A list of branches that should trigger a preview deployment. Wildcard syntax (*) is supported. Must be used with preview_deployment_setting set to custom.
            preview_deployment_setting: |-
                (String) Controls whether commits to preview branches trigger a preview deployment.
                Available values: "all", "none", "custom".
            preview_script_name: (String) Name of the preview script.
            production: (Attributes) Configs for production deploys. (see below for nested schema)
            production_branch: (String) Production branch of the project. Used to identify production deployments.
            production_deployments_enabled: (Boolean) Whether to trigger a production deployment on commits to the production branch.
            production_script_name: (String) Name of the production script.
            project_id: (String)
            project_name: (String) Name of the project.
            queue_producers: (Attributes Map) Queue Producer bindings used for Pages Functions. (see below for nested schema)
            r2_buckets: (Attributes Map) R2 buckets used for Pages Functions. (see below for nested schema)
            repo_id: (String) The ID of the repository.
            repo_name: (String) The name of the repository.
            root_dir: (String) Directory to run the command.
            service: (String) The Service name.
            services: (Attributes Map) Services used for Pages Functions. (see below for nested schema)
            short_id: (String) Short Id (8 character) of the deployment.
            source: (Attributes) Configs for the project source control. (see below for nested schema)
            stages: (Attributes List) List of past stages. (see below for nested schema)
            started_on: (String) When the stage started.
            status: |-
                (String) State of the current stage.
                Available values: "success", "idle", "active", "failure", "canceled".
            subdomain: (String) The Cloudflare subdomain associated with the project.
            type: '(String) Available values: "plain_text", "secret_text".'
            url: (String) The live URL to view this deployment.
            usage_model: |-
                (String, Deprecated) The usage model for Pages Functions.
                Available values: "standard", "bundled", "unbound".
            uses_functions: (Boolean) Whether the project uses functions.
            value: (String, Sensitive) Environment variable value.
            vectorize_bindings: (Attributes Map) Vectorize bindings used for Pages Functions. (see below for nested schema)
            web_analytics_tag: (String) The classifying tag for analytics.
            web_analytics_token: (String, Sensitive) The auth token for analytics.
            wrangler_config_hash: (String) Hash of the Wrangler configuration used for the deployment.
        importStatements:
            - $ terraform import cloudflare_pages_project.example '<account_id>/<project_name>'
    cloudflare_queue:
        subCategory: ""
        name: cloudflare_queue
        title: cloudflare_queue Resource - Cloudflare
        examples:
            - name: example_queue
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "queue_name": "example-queue"
                }
        argumentDocs:
            account_id: (String) A Resource identifier.
            batch_size: (Number) The maximum number of messages to include in a batch.
            bucket_name: (String)
            consumer_id: (String) A Resource identifier.
            consumers: (Attributes List) (see below for nested schema)
            consumers_total_count: (Number)
            created_on: (String)
            delivery_delay: (Number) Number of seconds to delay delivery of all messages to consumers.
            delivery_paused: (Boolean) Indicates if message delivery to consumers is currently paused.
            id: (String) The ID of this resource.
            max_concurrency: (Number) Maximum number of concurrent consumers that may consume from this Queue. Set to null to automatically opt in to the platform's maximum (recommended).
            max_retries: (Number) The maximum number of retries
            max_wait_time_ms: (Number) The number of milliseconds to wait for a batch to fill up before attempting to deliver it
            message_retention_period: (Number) Number of seconds after which an unconsumed message will be delayed.
            modified_on: (String)
            producers: (Attributes List) (see below for nested schema)
            producers_total_count: (Number)
            queue_id: (String)
            queue_name: (String)
            retry_delay: (Number) The number of seconds to delay before making the message available for another attempt.
            script: (String) Name of a Worker
            script_name: (String) Name of a Worker
            settings: (Attributes) (see below for nested schema)
            type: '(String) Available values: "worker", "http_pull".'
            visibility_timeout_ms: (Number) The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        importStatements:
            - $ terraform import cloudflare_queue.example '<account_id>/<queue_id>'
    cloudflare_queue_consumer:
        subCategory: ""
        name: cloudflare_queue_consumer
        title: cloudflare_queue_consumer Resource - Cloudflare
        examples:
            - name: example_queue_consumer
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "dead_letter_queue": "example-queue",
                  "queue_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "script_name": "my-consumer-worker",
                  "settings": {
                    "batch_size": 50,
                    "max_concurrency": 10,
                    "max_retries": 3,
                    "max_wait_time_ms": 5000,
                    "retry_delay": 10
                  },
                  "type": "worker"
                }
        argumentDocs:
            account_id: (String) A Resource identifier.
            batch_size: (Number) The maximum number of messages to include in a batch.
            consumer_id: (String) A Resource identifier.
            created_on: (String)
            dead_letter_queue: (String)
            max_concurrency: (Number) Maximum number of concurrent consumers that may consume from this Queue. Set to null to automatically opt in to the platform's maximum (recommended).
            max_retries: (Number) The maximum number of retries
            max_wait_time_ms: (Number) The number of milliseconds to wait for a batch to fill up before attempting to deliver it
            queue_id: (String) A Resource identifier.
            retry_delay: (Number) The number of seconds to delay before making the message available for another attempt.
            script: (String) Name of a Worker
            script_name: (String) Name of a Worker
            settings: (Attributes) (see below for nested schema)
            type: '(String) Available values: "worker", "http_pull".'
            visibility_timeout_ms: (Number) The number of milliseconds that a message is exclusively leased. After the timeout, the message becomes available for another attempt.
        importStatements: []
    cloudflare_r2_bucket:
        subCategory: ""
        name: cloudflare_r2_bucket
        title: cloudflare_r2_bucket Resource - Cloudflare
        examples:
            - name: example_r2_bucket
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "location": "apac",
                  "name": "example-bucket",
                  "storage_class": "Standard"
                }
        argumentDocs:
            account_id: (String) Account ID.
            creation_date: (String) Creation timestamp.
            id: (String) Name of the bucket.
            jurisdiction: |-
                (String) Jurisdiction where objects in this bucket are guaranteed to be stored.
                Available values: "default", "eu", "fedramp".
            location: |-
                (String) Location of the bucket.
                Available values: "apac", "eeur", "enam", "weur", "wnam", "oc".  Note: location is only honored the first time a bucket with a given name is created. If you delete and recreate a bucket with the same name, the original bucket location will be used. It is also a best-effort, not a guarantee, of bucket location.
            name: (String) Name of the bucket.
            storage_class: |-
                (String) Storage class for newly uploaded objects, unless specified otherwise.
                Available values: "Standard", "InfrequentAccess".
        importStatements:
            - $ terraform import cloudflare_r2_bucket.example '<account_id>/<bucket_name>/<jurisdiction>'
    cloudflare_r2_bucket_cors:
        subCategory: ""
        name: cloudflare_r2_bucket_cors
        title: cloudflare_r2_bucket_cors Resource - Cloudflare
        examples:
            - name: example_r2_bucket_cors
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bucket_name": "example-bucket",
                  "rules": [
                    {
                      "allowed": {
                        "headers": [
                          "x-requested-by"
                        ],
                        "methods": [
                          "GET"
                        ],
                        "origins": [
                          "http://localhost:3000"
                        ]
                      },
                      "expose_headers": [
                        "Content-Encoding"
                      ],
                      "id": "Allow Local Development",
                      "max_age_seconds": 3600
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Account ID.
            allowed: (Attributes) Object specifying allowed origins, methods and headers for this CORS rule. (see below for nested schema)
            bucket_name: (String) Name of the bucket.
            expose_headers: (List of String) Specifies the headers that can be exposed back, and accessed by, the JavaScript making the cross-origin request. If you need to access headers beyond the safelisted response headers, such as Content-Encoding or cf-cache-status, you must specify it here.
            headers: (List of String) Specifies the value for the Access-Control-Allow-Headers header R2 sets when requesting objects in this bucket from a browser. Cross-origin requests that include custom headers (e.g. x-user-id) should specify these headers as AllowedHeaders.
            id: (String) Identifier for this rule.
            jurisdiction: (String) Jurisdiction of the bucket
            max_age_seconds: (Number) Specifies the amount of time (in seconds) browsers are allowed to cache CORS preflight responses. Browsers may limit this to 2 hours or less, even if the maximum value (86400) is specified.
            methods: (List of String) Specifies the value for the Access-Control-Allow-Methods header R2 sets when requesting objects in a bucket from a browser.
            origins: (List of String) Specifies the value for the Access-Control-Allow-Origin header R2 sets when requesting objects in a bucket from a browser.
            rules: (Attributes List) (see below for nested schema)
        importStatements: []
    cloudflare_r2_bucket_event_notification:
        subCategory: ""
        name: cloudflare_r2_bucket_event_notification
        title: cloudflare_r2_bucket_event_notification Resource - Cloudflare
        examples:
            - name: example_r2_bucket_event_notification
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bucket_name": "example-bucket",
                  "queue_id": "queue_id",
                  "rules": [
                    {
                      "actions": [
                        "PutObject",
                        "CopyObject"
                      ],
                      "description": "Notifications from source bucket to queue",
                      "prefix": "img/",
                      "suffix": ".jpeg"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Account ID.
            actions: (List of String) Array of R2 object actions that will trigger notifications.
            bucket_name: (String) Name of the bucket.
            description: (String) A description that can be used to identify the event notification rule after creation.
            jurisdiction: (String) Jurisdiction of the bucket
            prefix: (String) Notifications will be sent only for objects with this prefix.
            queue_id: (String) Queue ID.
            queue_name: (String) Name of the queue.
            rules: (Attributes List) Array of rules to drive notifications. (see below for nested schema)
            suffix: (String) Notifications will be sent only for objects with this suffix.
        importStatements: []
    cloudflare_r2_bucket_lifecycle:
        subCategory: ""
        name: cloudflare_r2_bucket_lifecycle
        title: cloudflare_r2_bucket_lifecycle Resource - Cloudflare
        examples:
            - name: example_r2_bucket_lifecycle
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bucket_name": "example-bucket",
                  "rules": [
                    {
                      "abort_multipart_uploads_transition": {
                        "condition": {
                          "max_age": 0,
                          "type": "Age"
                        }
                      },
                      "conditions": {
                        "prefix": "prefix"
                      },
                      "delete_objects_transition": {
                        "condition": {
                          "max_age": 0,
                          "type": "Age"
                        }
                      },
                      "enabled": true,
                      "id": "Expire all objects older than 24 hours",
                      "storage_class_transitions": [
                        {
                          "condition": {
                            "max_age": 0,
                            "type": "Age"
                          },
                          "storage_class": "InfrequentAccess"
                        }
                      ]
                    }
                  ]
                }
        argumentDocs:
            abort_multipart_uploads_transition: (Attributes) Transition to abort ongoing multipart uploads. (see below for nested schema)
            account_id: (String) Account ID.
            bucket_name: (String) Name of the bucket.
            condition: (Attributes) Condition for lifecycle transitions to apply after an object reaches an age in seconds. (see below for nested schema)
            conditions: (Attributes) Conditions that apply to all transitions of this rule. (see below for nested schema)
            date: (String)
            delete_objects_transition: (Attributes) Transition to delete objects. (see below for nested schema)
            enabled: (Boolean) Whether or not this rule is in effect.
            id: (String) Unique identifier for this rule.
            jurisdiction: (String) Jurisdiction of the bucket
            max_age: (Number)
            prefix: (String) Transitions will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
            rules: (Attributes List) (see below for nested schema)
            storage_class: '(String) Available values: "InfrequentAccess".'
            storage_class_transitions: (Attributes List) Transitions to change the storage class of objects. (see below for nested schema)
            type: '(String) Available values: "Age".'
        importStatements: []
    cloudflare_r2_bucket_lock:
        subCategory: ""
        name: cloudflare_r2_bucket_lock
        title: cloudflare_r2_bucket_lock Resource - Cloudflare
        examples:
            - name: example_r2_bucket_lock
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bucket_name": "example-bucket",
                  "rules": [
                    {
                      "condition": {
                        "max_age_seconds": 100,
                        "type": "Age"
                      },
                      "enabled": true,
                      "id": "Lock all objects for 24 hours",
                      "prefix": "prefix"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Account ID.
            bucket_name: (String) Name of the bucket.
            condition: (Attributes) Condition to apply a lock rule to an object for how long in seconds. (see below for nested schema)
            date: (String)
            enabled: (Boolean) Whether or not this rule is in effect.
            id: (String) Unique identifier for this rule.
            jurisdiction: (String) Jurisdiction of the bucket
            max_age_seconds: (Number)
            prefix: (String) Rule will only apply to objects/uploads in the bucket that start with the given prefix, an empty prefix can be provided to scope rule to all objects/uploads.
            rules: (Attributes List) (see below for nested schema)
            type: '(String) Available values: "Age", "Date", "Indefinite".'
        importStatements: []
    cloudflare_r2_bucket_sippy:
        subCategory: ""
        name: cloudflare_r2_bucket_sippy
        title: cloudflare_r2_bucket_sippy Resource - Cloudflare
        examples:
            - name: example_r2_bucket_sippy
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bucket_name": "example-bucket",
                  "destination": {
                    "access_key_id": "accessKeyId",
                    "cloud_provider": "r2",
                    "secret_access_key": "secretAccessKey"
                  },
                  "source": {
                    "access_key_id": "accessKeyId",
                    "bucket": "bucket",
                    "cloud_provider": "aws",
                    "region": "region",
                    "secret_access_key": "secretAccessKey"
                  }
                }
        argumentDocs:
            access_key_id: |-
                (String) ID of a Cloudflare API token.
                This is the value labelled "Access Key ID" when creating an API.
                token from the R2 dashboard.
            account_id: (String) Account ID.
            bucket: (String) Name of the AWS S3 bucket.
            bucket_name: (String) Name of the bucket.
            bucket_url: (String) URL to the S3-compatible API of the bucket.
            client_email: (String) Client email of an IAM credential (ideally scoped to a single GCS bucket).
            cloud_provider: '(String) Available values: "r2".'
            destination: (Attributes) R2 bucket to copy objects to. (see below for nested schema)
            enabled: (Boolean) State of Sippy for this bucket.
            jurisdiction: (String) Jurisdiction of the bucket
            private_key: (String, Sensitive) Private Key of an IAM credential (ideally scoped to a single GCS bucket).
            region: (String) Name of the AWS availability zone.
            secret_access_key: |-
                (String, Sensitive) Value of a Cloudflare API token.
                This is the value labelled "Secret Access Key" when creating an API.
                token from the R2 dashboard.
            source: (Attributes) AWS S3 bucket to copy objects from. (see below for nested schema)
        importStatements: []
    cloudflare_r2_custom_domain:
        subCategory: ""
        name: cloudflare_r2_custom_domain
        title: cloudflare_r2_custom_domain Resource - Cloudflare
        examples:
            - name: example_r2_custom_domain
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bucket_name": "example-bucket",
                  "ciphers": [
                    "string"
                  ],
                  "domain": "prefix.example-domain.com",
                  "enabled": true,
                  "min_tls": "1.0",
                  "zone_id": "36ca64a6d92827b8a6b90be344bb1bfd"
                }
        argumentDocs:
            account_id: (String) Account ID.
            bucket_name: (String) Name of the bucket.
            ciphers: (List of String) An allowlist of ciphers for TLS termination. These ciphers must be in the BoringSSL format.
            domain: (String) Name of the custom domain to be added.
            enabled: (Boolean) Whether to enable public bucket access at the custom domain. If undefined, the domain will be enabled.
            jurisdiction: (String) Jurisdiction of the bucket
            min_tls: |-
                (String) Minimum TLS Version the custom domain will accept for incoming connections. If not set, defaults to 1.0.
                Available values: "1.0", "1.1", "1.2", "1.3".
            ownership: |-
                (String) Ownership status of the domain.
                Available values: "pending", "active", "deactivated", "blocked", "error", "unknown".
            ssl: |-
                (String) SSL certificate status.
                Available values: "initializing", "pending", "active", "deactivated", "error", "unknown".
            status: (Attributes) (see below for nested schema)
            zone_id: (String) Zone ID of the custom domain.
            zone_name: (String) Zone that the custom domain resides in.
        importStatements: []
    cloudflare_r2_managed_domain:
        subCategory: ""
        name: cloudflare_r2_managed_domain
        title: cloudflare_r2_managed_domain Resource - Cloudflare
        examples:
            - name: example_r2_managed_domain
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bucket_name": "example-bucket",
                  "enabled": true
                }
        argumentDocs:
            account_id: (String) Account ID.
            bucket_id: (String) Bucket ID.
            bucket_name: (String) Name of the bucket.
            domain: (String) Domain name of the bucket's r2.dev domain.
            enabled: (Boolean) Whether to enable public bucket access at the r2.dev domain.
            jurisdiction: (String) Jurisdiction of the bucket
        importStatements: []
    cloudflare_rate_limit:
        subCategory: ""
        name: cloudflare_rate_limit
        title: cloudflare_rate_limit Resource - Cloudflare
        examples:
            - name: example_rate_limit
              manifest: |-
                {
                  "action": {
                    "mode": "challenge",
                    "response": {
                      "body": "\u003cerror\u003eThis request has been rate-limited.\u003c/error\u003e",
                      "content_type": "text/xml"
                    },
                    "timeout": 86400
                  },
                  "match": {
                    "headers": [
                      {
                        "name": "Cf-Cache-Status",
                        "op": "ne",
                        "value": "HIT"
                      }
                    ],
                    "request": {
                      "methods": [
                        "GET",
                        "POST"
                      ],
                      "schemes": [
                        "HTTP",
                        "HTTPS"
                      ],
                      "url": "*.example.org/path*"
                    },
                    "response": {
                      "origin_traffic": true
                    }
                  },
                  "period": 900,
                  "threshold": 60,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            action: (Attributes) The action to perform when the threshold of matched traffic within the configured period is exceeded. (see below for nested schema)
            body: (String) The response body to return. The value must conform to the configured content type.
            bypass: (Attributes List) Criteria specifying when the current rate limit should be bypassed. You can specify that the rate limit should not apply to one or more URLs. (see below for nested schema)
            content_type: '(String) The content type of the body. Must be one of the following: text/plain, text/xml, or application/json.'
            description: (String) An informative summary of the rule. This value is sanitized and any tags will be removed.
            disabled: (Boolean) When true, indicates that the rate limit is currently disabled.
            headers: (Attributes List) (see below for nested schema)
            id: (String) The unique identifier of the rate limit.
            match: (Attributes) Determines which traffic the rate limit counts towards the threshold. (see below for nested schema)
            methods: (List of String) The HTTP methods to match. You can specify a subset (for example, ['POST','PUT']) or all methods (['_ALL_']). This field is optional when creating a rate limit.
            mode: |-
                (String) The action to perform.
                Available values: "simulate", "ban", "challenge", "js_challenge", "managed_challenge".
            name: (String) The name of the response header to match.
            op: |-
                (String) The operator used when matching: eq means "equal" and ne means "not equal".
                Available values: "eq", "ne".
            origin_traffic: |-
                (Boolean) When true, only the uncached traffic served from your origin servers will count towards rate limiting. In this case, any cached traffic served by Cloudflare will not count towards rate limiting. This field is optional.
                Notes: This field is deprecated. Instead, use response headers and set "origin_traffic" to "false" to avoid legacy behaviour interacting with the "response_headers" property.
            period: (Number) The time in seconds (an integer value) to count matching traffic. If the count exceeds the configured threshold within this period, Cloudflare will perform the configured action.
            request: (Attributes) (see below for nested schema)
            response: |-
                (Attributes) A custom content type and reponse to return when the threshold is exceeded. The custom response configured in this object will override the custom error for the zone. This object is optional.
                Notes: If you omit this object, Cloudflare will use the default HTML error page. If "mode" is "challenge", "managed_challenge", or "js_challenge", Cloudflare will use the zone challenge pages and you should not provide the "response" object. (see below for nested schema)
            schemes: (List of String) The HTTP schemes to match. You can specify one scheme (['HTTPS']), both schemes (['HTTP','HTTPS']), or all schemes (['_ALL_']). This field is optional.
            threshold: (Number) The threshold that will trigger the configured mitigation action. Configure this value along with the period property to establish a threshold per period.
            timeout: |-
                (Number) The time in seconds during which Cloudflare will perform the mitigation action. Must be an integer value greater than or equal to the period.
                Notes: If "mode" is "challenge", "managed_challenge", or "js_challenge", Cloudflare will use the zone's Challenge Passage time and you should not provide this value.
            url: (String) The URL pattern to match, composed of a host and a path such as example.org/path*. Normalization is applied before the pattern is matched. * wildcards are expanded to match applicable traffic. Query strings are not matched. Set the value to * to match all traffic to your zone.
            value: (String) The value of the response header, which must match exactly.
            zone_id: (String) Defines an identifier.
        importStatements:
            - $ terraform import cloudflare_rate_limit.example '<zone_id>/<rate_limit_id>'
    cloudflare_regional_hostname:
        subCategory: ""
        name: cloudflare_regional_hostname
        title: cloudflare_regional_hostname Resource - Cloudflare
        examples:
            - name: example_regional_hostname
              manifest: |-
                {
                  "hostname": "foo.example.com",
                  "region_key": "ca",
                  "routing": "dns",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            created_on: (String) When the regional hostname was created
            hostname: (String) DNS hostname to be regionalized, must be a subdomain of the zone. Wildcards are supported for one level, e.g *.example.com
            id: (String) DNS hostname to be regionalized, must be a subdomain of the zone. Wildcards are supported for one level, e.g *.example.com
            region_key: (String) Identifying key for the region
            routing: (String) Configure which routing method to use for the regional hostname
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_regional_hostname.example '<zone_id>/<hostname>'
    cloudflare_regional_tiered_cache:
        subCategory: ""
        name: cloudflare_regional_tiered_cache
        title: cloudflare_regional_tiered_cache Resource - Cloudflare
        examples:
            - name: example_regional_tiered_cache
              manifest: |-
                {
                  "value": "on",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            editable: (Boolean) Whether the setting is editable.
            id: (String) Identifier.
            modified_on: (String) Last time this setting was modified.
            value: |-
                (String) Value of the Regional Tiered Cache zone setting.
                Available values: "on", "off".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_regional_tiered_cache.example '<zone_id>'
    cloudflare_registrar_domain:
        subCategory: ""
        name: cloudflare_registrar_domain
        title: cloudflare_registrar_domain Resource - Cloudflare
        examples:
            - name: example_registrar_domain
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "auto_renew": true,
                  "domain_name": "cloudflare.com",
                  "locked": false,
                  "privacy": true
                }
        argumentDocs:
            account_id: (String) Identifier
            auto_renew: (Boolean) Auto-renew controls whether subscription is automatically renewed upon domain expiration.
            domain_name: (String) Domain name.
            locked: (Boolean) Shows whether a registrar lock is in place for a domain.
            privacy: (Boolean) Privacy option controls redacting WHOIS information.
        importStatements: []
    cloudflare_ruleset:
        subCategory: ""
        name: cloudflare_ruleset
        title: cloudflare_ruleset Resource - Cloudflare
        examples:
            - name: example_ruleset
              manifest: |-
                {
                  "description": "A description for my ruleset.",
                  "kind": "root",
                  "name": "My ruleset",
                  "phase": "http_request_firewall_custom",
                  "rules": [
                    {
                      "action": "block",
                      "description": "Block the request.",
                      "expression": "ip.src ne 1.1.1.1",
                      "ref": "my_rule"
                    }
                  ],
                  "zone_id": "9f1839b6152d298aca64c4e906b6d074"
                }
        argumentDocs:
            account_id: (String) The unique ID of the account.
            action: |-
                (String) The action to perform when the rule matches.
                Available values: "block", "challenge", "compress_response", "ddos_dynamic", "execute", "force_connection_close", "js_challenge", "log", "log_custom_field", "managed_challenge", "redirect", "rewrite", "route", "score", "serve_error", "set_cache_settings", "set_config", "skip".
            action_parameters: (Attributes) The parameters configuring the rule's action. (see below for nested schema)
            additional_cacheable_ports: (List of Number) A list of additional ports that caching should be enabled on.
            algorithms: (Attributes List) Custom order for compression algorithms. (see below for nested schema)
            all: (Boolean) Whether to exclude all query string parameters from the cache key.
            asset_name: (String) The name of a custom asset to serve as the response.
            automatic_https_rewrites: (Boolean) Whether to enable Automatic HTTPS Rewrites.
            autominify: (Attributes) Which file extensions to minify automatically. (see below for nested schema)
            bic: (Boolean) Whether to enable Browser Integrity Check (BIC).
            browser_ttl: (Attributes) How long client browsers should cache the response. Cloudflare cache purge will not purge content cached on client browsers, so high browser TTLs may lead to stale content. (see below for nested schema)
            cache: (Boolean) Whether the request's response from the origin is eligible for caching. Caching itself will still depend on the cache control header and your other caching configurations.
            cache_by_device_type: (Boolean) Whether to separate cached content based on the visitor's device type.
            cache_deception_armor: (Boolean) Whether to protect from web cache deception attacks, while allowing static assets to be cached.
            cache_key: (Attributes) Which components of the request are included in or excluded from the cache key Cloudflare uses to store the response in cache. (see below for nested schema)
            cache_reserve: (Attributes) Settings to determine whether the request's response from origin is eligible for Cache Reserve (requires a Cache Reserve add-on plan). (see below for nested schema)
            categories: (Attributes List) A list of category-level overrides. This option has the second-highest precedence after rule-level overrides. (see below for nested schema)
            category: (String) The name of the category to override.
            characteristics: (List of String) Characteristics of the request on which the rate limit counter will be incremented.
            check_presence: (List of String) A list of cookies to check for the presence of. The presence of these cookies is included in the cache key.
            contains: (Map of List of String) A mapping of header names to a list of values. If a header is present in the request and contains any of the values provided, its value is included in the cache key.
            content: (String) The response content.
            content_type: |-
                (String) The content type header to set with the error response.
                Available values: "application/json", "text/html", "text/plain", "text/xml".
            cookie: (Attributes) Which cookies to include in the cache key. (see below for nested schema)
            cookie_fields: (Attributes List) The cookie fields to log. (see below for nested schema)
            counting_expression: (String) An expression that defines when the rate limit counter should be incremented. It defaults to the same as the rule's expression.
            css: (Boolean) Whether to minify CSS files.
            custom_key: (Attributes) Which components of the request are included or excluded from the cache key. (see below for nested schema)
            default: (Number) The browser TTL (in seconds) if you choose the "override_origin" mode.
            description: (String) An informative description of the ruleset.
            device_type: (Boolean) Whether to use the user agent's device type in the cache key.
            disable_apps: (Boolean) Whether to disable Cloudflare Apps.
            disable_rum: (Boolean) Whether to disable Real User Monitoring (RUM).
            disable_stale_while_updating: (Boolean) Whether Cloudflare should disable serving stale content while getting the latest content from the origin.
            disable_zaraz: (Boolean) Whether to disable Zaraz.
            edge_ttl: (Attributes) How long the Cloudflare edge network should cache the response. (see below for nested schema)
            eligible: (Boolean) Whether Cache Reserve is enabled. If this is true and a request meets eligibility criteria, Cloudflare will write the resource to Cache Reserve.
            email_obfuscation: (Boolean) Whether to enable Email Obfuscation.
            enabled: (Boolean) Whether the rule should be executed.
            exclude: (Attributes) Which query string parameters to exclude from the cache key. (see below for nested schema)
            exclude_origin: (Boolean) Whether to exclude the origin header in the cache key.
            exposed_credential_check: (Attributes) Configuration for exposed credential checking. (see below for nested schema)
            expression: (String) The expression defining which traffic will match the rule.
            fonts: (Boolean) Whether to enable Cloudflare Fonts.
            from: (Number) The lower bound of the range.
            from_list: (Attributes) A redirect based on a bulk list lookup. (see below for nested schema)
            from_value: (Attributes) A redirect based on the request properties. (see below for nested schema)
            geo: (Boolean) Whether to use the user agents's country in the cache key.
            header: (Attributes) Which headers to include in the cache key. (see below for nested schema)
            headers: (Attributes Map) A map of headers to rewrite. (see below for nested schema)
            host: (Attributes) How to use the host in the cache key. (see below for nested schema)
            host_header: (String) A value to rewrite the HTTP host header to.
            hotlink_protection: (Boolean) Whether to enable Hotlink Protection.
            html: (Boolean) Whether to minify HTML files.
            id: (String) The unique ID of the ruleset.
            ignore_query_strings_order: (Boolean) Whether to treat requests with the same query parameters the same, regardless of the order those query parameters are in.
            include: (List of String) A list of cookies to include in the cache key.
            increment: (Number) A delta to change the score by, which can be either positive or negative.
            js: (Boolean) Whether to minify JavaScript files.
            key: (String) An expression that evaluates to the list lookup key.
            kind: |-
                (String) The kind of the ruleset.
                Available values: "managed", "custom", "root", "zone".
            lang: (Boolean) Whether to use the user agent's language in the cache key.
            last_updated: (String) The timestamp of when the ruleset was last modified.
            list: (List of String) A list of query string parameters to exclude from the cache key.
            logging: (Attributes) An object configuring the rule's logging behavior. (see below for nested schema)
            matched_data: (Attributes) The configuration to use for matched data logging. (see below for nested schema)
            minimum_file_size: (Number) The minimum file size eligible for storage in Cache Reserve.
            mirage: (Boolean) Whether to enable Mirage.
            mitigation_timeout: (Number) Period of time in seconds after which the action will be disabled following its first execution.
            mode: |-
                (String) The browser TTL mode.
                Available values: "respect_origin", "bypass_by_default", "override_origin", "bypass".
            name: (String) The human-readable name of the ruleset.
            operation: |-
                (String) The operation to perform on the header.
                Available values: "add", "set", "remove".
            opportunistic_encryption: (Boolean) Whether to enable Opportunistic Encryption.
            origin: (Attributes) An origin to route to. (see below for nested schema)
            origin_cache_control: (Boolean) Whether Cloudflare will aim to strictly adhere to RFC 7234.
            origin_error_page_passthru: (Boolean) Whether to generate Cloudflare error pages for issues from the origin server.
            overrides: (Attributes) A set of overrides to apply to the target ruleset. (see below for nested schema)
            password_expression: (String) An expression that selects the password used in the credentials check.
            path: (Attributes) A URI path rewrite. (see below for nested schema)
            period: (Number) Period in seconds over which the counter is being incremented.
            phase: |-
                (String) The phase of the ruleset.
                Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
            phases: |-
                (List of String) A list of phases to skip the execution of. This option is incompatible with the rulesets option.
                Available values: "ddos_l4", "ddos_l7", "http_config_settings", "http_custom_errors", "http_log_custom_fields", "http_ratelimit", "http_request_cache_settings", "http_request_dynamic_redirect", "http_request_firewall_custom", "http_request_firewall_managed", "http_request_late_transform", "http_request_origin", "http_request_redirect", "http_request_sanitize", "http_request_sbfm", "http_request_transform", "http_response_compression", "http_response_firewall_managed", "http_response_headers_transform", "magic_transit", "magic_transit_ids_managed", "magic_transit_managed", "magic_transit_ratelimit".
            polish: |-
                (String) The Polish level to configure.
                Available values: "off", "lossless", "lossy", "webp".
            port: (Number) A destination port to route to.
            preserve_duplicates: (Boolean) Whether to log duplicate values of the same header.
            preserve_query_string: (Boolean) Whether to keep the query string of the original request.
            products: |-
                (List of String) A list of legacy security products to skip the execution of.
                Available values: "bic", "hot", "rateLimit", "securityLevel", "uaBlock", "waf", "zoneLockdown".
            public_key: (String) The public key to encrypt matched data logs with.
            query: (Attributes) A URI query rewrite. (see below for nested schema)
            query_string: (Attributes) Which query string parameters to include in or exclude from the cache key. (see below for nested schema)
            ratelimit: (Attributes) An object configuring the rule's rate limit behavior. (see below for nested schema)
            raw_response_fields: (Attributes List) The raw response fields to log. (see below for nested schema)
            read_timeout: (Number) A timeout value between two successive read operations to use for your origin server. Historically, the timeout value between two read options from Cloudflare to an origin server is 100 seconds. If you are attempting to reduce HTTP 524 errors because of timeouts from an origin server, try increasing this timeout value.
            ref: (String) The reference of the rule (the rule's ID by default).
            request_body_buffering: |-
                (String) The request body buffering mode to configure.
                Available values: "none", "standard", "full".
            request_fields: (Attributes List) The raw request fields to log. (see below for nested schema)
            requests_per_period: (Number) The threshold of requests per period after which the action will be executed for the first time.
            requests_to_origin: (Boolean) Whether counting is only performed when an origin is reached.
            resolved: (Boolean) Whether to use the resolved host in the cache key.
            respect_strong_etags: (Boolean) Whether Cloudflare should respect strong ETag (entity tag) headers. If false, Cloudflare converts strong ETag headers to weak ETag headers.
            response: (Attributes) The response to show when the block is applied. (see below for nested schema)
            response_body_buffering: |-
                (String) The response body buffering mode to configure.
                Available values: "none", "standard".
            response_fields: (Attributes List) The transformed response fields to log. (see below for nested schema)
            rocket_loader: (Boolean) Whether to enable Rocket Loader.
            rules: (Attributes List) The list of rules in the ruleset. (see below for nested schema)
            ruleset: |-
                (String) A ruleset to skip the execution of. This option is incompatible with the rulesets option.
                Available values: "current".
            rulesets: (List of String) A list of ruleset IDs to skip the execution of. This option is incompatible with the ruleset and phases options.
            score_per_period: (Number) The score threshold per period for which the action will be executed the first time.
            score_response_header_name: (String) A response header name provided by the origin, which contains the score to increment rate limit counter with.
            score_threshold: (Number) The score threshold to use for the rule.
            security_level: |-
                (String) The Security Level to configure.
                Available values: "off", "essentially_off", "low", "medium", "high", "under_attack".
            sensitivity_level: |-
                (String) A sensitivity level to set for all rules. This option has lower precedence than rule and category overrides and is only applicable for DDoS phases.
                Available values: "default", "medium", "low", "eoff".
            serve_stale: (Attributes) When to serve stale content from cache. (see below for nested schema)
            server_side_excludes: (Boolean) Whether to enable Server-Side Excludes.
            sni: (Attributes) A Server Name Indication (SNI) override. (see below for nested schema)
            ssl: |-
                (String) The SSL level to configure.
                Available values: "off", "flexible", "full", "strict", "origin_pull".
            status_code: (Number) The status code to use for the error.
            status_code_range: (Attributes) A range of status codes to apply the TTL to. (see below for nested schema)
            status_code_ttl: (Attributes List) A list of TTLs to apply to specific status codes or status code ranges. (see below for nested schema)
            sxg: (Boolean) Whether to enable Signed Exchanges (SXG).
            target_url: (Attributes) A URL to redirect the request to. (see below for nested schema)
            to: (Number) The upper bound of the range.
            transformed_request_fields: (Attributes List) The transformed request fields to log. (see below for nested schema)
            uri: (Attributes) A URI rewrite. (see below for nested schema)
            user: (Attributes) How to use characteristics of the request user agent in the cache key. (see below for nested schema)
            username_expression: (String) An expression that selects the user ID used in the credentials check.
            value: (Number) The time to cache the response for (in seconds). A value of 0 is equivalent to setting the cache control header with the value "no-cache". A value of -1 is equivalent to setting the cache control header with the value of "no-store".
            version: (String) The version of the ruleset.
            zone_id: (String) The unique ID of the zone.
        importStatements:
            - $ terraform import cloudflare_ruleset.example '<{accounts|zones}/{account_id|zone_id}>/<ruleset_id>'
    cloudflare_schema_validation_operation_settings:
        subCategory: ""
        name: cloudflare_schema_validation_operation_settings
        title: cloudflare_schema_validation_operation_settings Resource - Cloudflare
        examples:
            - name: example_schema_validation_operation_settings
              manifest: |-
                {
                  "mitigation_action": "block",
                  "operation_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            '"block"': '- deny access to the site when request does not conform to schema for this operation'
            '"log"': '- log request when request does not conform to schema for this operation'
            '"none"': '- will skip mitigation for this operation'
            mitigation_action: (String) When set, this applies a mitigation action to this operation
            "null": |-
                - clears any mitigation action
                Available values: "log", "block", "none".
            operation_id: (String) UUID.
            zone_id: (String) Identifier.
        importStatements: []
    cloudflare_schema_validation_schemas:
        subCategory: ""
        name: cloudflare_schema_validation_schemas
        title: cloudflare_schema_validation_schemas Resource - Cloudflare
        examples:
            - name: example_schema_validation_schemas
              manifest: |-
                {
                  "kind": "openapi_v3",
                  "name": "petstore schema",
                  "source": "\u003cschema file contents\u003e",
                  "validation_enabled": true,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            created_at: (String)
            id: (String) A unique identifier of this schema
            kind: |-
                (String) The kind of the schema
                Available values: "openapi_v3".
            name: (String) A human-readable name for the schema
            schema_id: (String) A unique identifier of this schema
            source: (String) The raw schema, e.g., the OpenAPI schema, either as JSON or YAML
            validation_enabled: (Boolean) An indicator if this schema is enabled
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_schema_validation_schemas.example '<zone_id>/<schema_id>'
    cloudflare_schema_validation_settings:
        subCategory: ""
        name: cloudflare_schema_validation_settings
        title: cloudflare_schema_validation_settings Resource - Cloudflare
        examples:
            - name: example_schema_validation_settings
              manifest: |-
                {
                  "validation_default_mitigation_action": "block",
                  "validation_override_mitigation_action": "none",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            '"block"': '- deny access to the site when request does not conform to schema'
            '"log"': '- log request when request does not conform to schema'
            '"none"': |-
                - skip running schema validation
                Available values: "none", "log", "block".
            "null": |-
                - clears any existing override
                Available values: "none".
            validation_default_mitigation_action: |-
                (String) The default mitigation action used
                Mitigation actions are as follows:
            validation_override_mitigation_action: (String) When set, this overrides both zone level and operation level mitigation actions.
            zone_id: (String) Identifier.
        importStatements: []
    cloudflare_snippet:
        subCategory: ""
        name: cloudflare_snippet
        title: cloudflare_snippet Resource - Cloudflare
        examples:
            - name: example_snippet
              manifest: |-
                {
                  "files": [
                    {
                      "content": "export default {\n  async fetch(request) {\n    return new Response('Hello, World!');\n  }\n}\n",
                      "name": "main.js"
                    }
                  ],
                  "metadata": {
                    "main_module": "main.js"
                  },
                  "snippet_name": "my_snippet",
                  "zone_id": "9f1839b6152d298aca64c4e906b6d074"
                }
        argumentDocs:
            content: (String)
            created_on: (String) The timestamp of when the snippet was created.
            files: (List of Object) The list of files belonging to the snippet. (see below for nested schema)
            main_module: (String) Name of the file that contains the main module of the snippet.
            metadata: (Attributes) Metadata about the snippet. (see below for nested schema)
            modified_on: (String) The timestamp of when the snippet was last modified.
            name: (String)
            snippet_name: (String) The identifying name of the snippet.
            zone_id: (String) The unique ID of the zone.
        importStatements: []
    cloudflare_snippet_rules:
        subCategory: ""
        name: cloudflare_snippet_rules
        title: cloudflare_snippet_rules Resource - Cloudflare
        examples:
            - name: example_snippet_rules
              manifest: |-
                {
                  "rules": [
                    {
                      "description": "Execute my_snippet when IP address is 1.1.1.1.",
                      "enabled": true,
                      "expression": "ip.src eq 1.1.1.1",
                      "snippet_name": "my_snippet"
                    }
                  ],
                  "zone_id": "9f1839b6152d298aca64c4e906b6d074"
                }
        argumentDocs:
            description: (String) An informative description of the rule.
            enabled: (Boolean) Whether the rule should be executed.
            expression: (String) The expression defining which traffic will match the rule.
            id: (String) The unique ID of the rule.
            last_updated: (String) The timestamp of when the rule was last modified.
            rules: (Attributes List) A list of snippet rules. (see below for nested schema)
            snippet_name: (String) The identifying name of the snippet.
            zone_id: (String) The unique ID of the zone.
        importStatements: []
    cloudflare_snippets Resource - Cloudflare:
        subCategory: ""
        name: cloudflare_snippets Resource - Cloudflare
        title: cloudflare_snippets Resource - Cloudflare
        argumentDocs:
            created_on: (String) The timestamp of when the snippet was created.
            files: (List of String) The list of files belonging to the snippet.
            main_module: (String) Name of the file that contains the main module of the snippet.
            metadata: (Attributes) Metadata about the snippet. (see below for nested schema)
            modified_on: (String) The timestamp of when the snippet was last modified.
            snippet_name: (String) The identifying name of the snippet.
            zone_id: (String) The unique ID of the zone.
        importStatements: []
    cloudflare_spectrum_application:
        subCategory: ""
        name: cloudflare_spectrum_application
        title: cloudflare_spectrum_application Resource - Cloudflare
        examples:
            - name: example_spectrum_application
              manifest: |-
                {
                  "argo_smart_routing": true,
                  "dns": {
                    "name": "ssh.example.com",
                    "type": "CNAME"
                  },
                  "edge_ips": {
                    "connectivity": "all",
                    "type": "dynamic"
                  },
                  "ip_firewall": false,
                  "origin_direct": [
                    "tcp://127.0.0.1:8080"
                  ],
                  "origin_dns": {
                    "name": "origin.example.com",
                    "ttl": 600,
                    "type": ""
                  },
                  "origin_port": 22,
                  "protocol": "tcp/22",
                  "proxy_protocol": "off",
                  "tls": "off",
                  "traffic_type": "direct",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            argo_smart_routing: |-
                (Boolean) Enables Argo Smart Routing for this application.
                Notes: Only available for TCP applications with traffic_type set to "direct".
            connectivity: |-
                (String) The IP versions supported for inbound connections on Spectrum anycast IPs.
                Available values: "all", "ipv4", "ipv6".
            created_on: (String) When the Application was created.
            dns: (Attributes) The name and type of DNS record for the Spectrum application. (see below for nested schema)
            edge_ips: (Attributes) The anycast edge IP configuration for the hostname of this application. (see below for nested schema)
            id: (String) App identifier.
            ip_firewall: |-
                (Boolean) Enables IP Access Rules for this application.
                Notes: Only available for TCP applications.
            ips: (List of String) The array of customer owned IPs we broadcast via anycast for this hostname and application.
            modified_on: (String) When the Application was last modified.
            name: (String) The name of the DNS record associated with the application.
            origin_direct: (List of String) List of origin IP addresses. Array may contain multiple IP addresses for load balancing.
            origin_dns: (Attributes) The name and type of DNS record for the Spectrum application. (see below for nested schema)
            origin_port: |-
                (Dynamic) The destination port at the origin. Only specified in conjunction with origin_dns. May use an integer to specify a single origin port, for example 1000, or a string to specify a range of origin ports, for example "1000-2000".
                Notes: If specifying a port range, the number of ports in the range must match the number of ports specified in the "protocol" field.
            protocol: (String) The port configuration at Cloudflare's edge. May specify a single port, for example "tcp/1000", or a range of ports, for example "tcp/1000-2000".
            proxy_protocol: |-
                (String) Enables Proxy Protocol to the origin. Refer to Enable Proxy protocol for implementation details on PROXY Protocol V1, PROXY Protocol V2, and Simple Proxy Protocol.
                Available values: "off", "v1", "v2", "simple".
            tls: |-
                (String) The type of TLS termination associated with the application.
                Available values: "off", "flexible", "full", "strict".
            traffic_type: |-
                (String) Determines how data travels from the edge to your origin. When set to "direct", Spectrum will send traffic directly to your origin, and the application's type is derived from the protocol. When set to "http" or "https", Spectrum will apply Cloudflare's HTTP/HTTPS features as it sends traffic to your origin, and the application type matches this property exactly.
                Available values: "direct", "http", "https".
            ttl: (Number) The TTL of our resolution of your DNS record in seconds.
            type: |-
                (String) The type of DNS record associated with the application.
                Available values: "CNAME", "ADDRESS".
            zone_id: (String) Zone identifier.
        importStatements:
            - $ terraform import cloudflare_spectrum_application.example '<zone_id>/<app_id>'
    cloudflare_sso_connector:
        subCategory: ""
        name: cloudflare_sso_connector
        title: cloudflare_sso_connector Resource - Cloudflare
        examples:
            - name: example_sso_connector
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "begin_verification": true,
                  "email_domain": "example.com",
                  "use_fedramp_language": false
                }
        argumentDocs:
            account_id: (String) Account identifier tag.
            begin_verification: (Boolean) Begin the verification process after creation
            code: (String) DNS verification code. Add this entire string to the DNS TXT record of the email domain to validate ownership.
            created_on: (String) Timestamp for the creation of the SSO connector
            email_domain: (String) Email domain of the new SSO connector
            enabled: (Boolean) SSO Connector enabled state
            id: (String) SSO Connector identifier tag.
            status: |-
                (String) The status of the verification code from the verification process.
                Available values: "awaiting", "pending", "failed", "verified".
            updated_on: (String) Timestamp for the last update of the SSO connector
            use_fedramp_language: (Boolean) Controls the display of FedRAMP language to the user during SSO login
            verification: (Attributes) (see below for nested schema)
        importStatements:
            - $ terraform import cloudflare_sso_connector.example '<account_id>/<sso_connector_id>'
    cloudflare_stream:
        subCategory: ""
        name: cloudflare_stream
        title: cloudflare_stream Resource - Cloudflare
        examples:
            - name: example_stream
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            account_id: (String) The account identifier tag.
            allowed_origins: (List of String) Lists the origins allowed to display the video. Enter allowed origin domains in an array and use * for wildcard subdomains. Empty arrays allow the video to be viewed on any origin.
            created: (String) The date and time the media item was created.
            creator: (String) A user-defined identifier for the media creator.
            dash: (String) DASH Media Presentation Description for the video.
            downloaded_from: (String) The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
            duration: (Number) The duration of the video in seconds. A value of -1 means the duration is unknown. The duration becomes available after the upload and before the video is ready.
            error_reason_code: (String) Specifies why the video failed to encode. This field is empty if the video is not in an error state. Preferred for programmatic use.
            error_reason_text: (String) Specifies why the video failed to encode using a human readable error message in English. This field is empty if the video is not in an error state.
            height: (Number) The video height in pixels. A value of -1 means the height is unknown. The value becomes available after the upload and before the video is ready.
            hls: (String) The HLS manifest for the video.
            identifier: (String) A Cloudflare-generated unique identifier for a media item.
            input: (Attributes) (see below for nested schema)
            live_input: (String) The live input ID used to upload a video with Stream Live.
            max_duration_seconds: (Number) The maximum duration in seconds for a video upload. Can be set for a video that is not yet uploaded to limit its duration. Uploads that exceed the specified duration will fail during processing. A value of -1 means the value is unknown.
            meta: (String) A user modifiable key-value store used to reference other systems of record for managing videos.
            modified: (String) The date and time the media item was last modified.
            name: (String) A short description of the watermark profile.
            opacity: (Number) The translucency of the image. A value of 0.0 makes the image completely transparent, and 1.0 makes the image completely opaque. Note that if the image is already semi-transparent, setting this to 1.0 will not make the image completely opaque.
            padding: (Number) The whitespace between the adjacent edges (determined by position) of the video and the image. 0.0 indicates no padding, and 1.0 indicates a fully padded video width or length, as determined by the algorithm.
            pct_complete: (String) Indicates the size of the entire upload in bytes. The value must be a non-negative integer.
            playback: (Attributes) (see below for nested schema)
            position: '(String) The location of the image. Valid positions are: upperRight, upperLeft, lowerLeft, lowerRight, and center. Note that center ignores the padding parameter.'
            preview: (String) The video's preview page URI. This field is omitted until encoding is complete.
            ready_to_stream: (Boolean) Indicates whether the video is playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
            ready_to_stream_at: (String) Indicates the time at which the video became playable. The field is empty if the video is not ready for viewing or the live stream is still in progress.
            require_signed_urls: (Boolean) Indicates whether the video can be a accessed using the UID. When set to true, a signed token must be generated with a signing key to view the video.
            scale: (Number) The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. 0.0 indicates no scaling (use the size of the image as-is), and 1.0 fills the entire video.
            scheduled_deletion: (String) Indicates the date and time at which the video will be deleted. Omit the field to indicate no change, or include with a null value to remove an existing scheduled deletion. If specified, must be at least 30 days from upload time.
            size: (Number) The size of the media item in bytes.
            state: |-
                (String) Specifies the processing status for all quality levels for a video.
                Available values: "pendingupload", "downloading", "queued", "inprogress", "ready", "error", "live-inprogress".
            status: (Attributes) Specifies a detailed status for a video. If the state is inprogress or error, the step field returns encoding or manifest. If the state is inprogress, pctComplete returns a number between 0 and 100 to indicate the approximate percent of completion. If the state is error, errorReasonCode and errorReasonText provide additional details. (see below for nested schema)
            thumbnail: (String) The media item's thumbnail URI. This field is omitted until encoding is complete.
            thumbnail_timestamp_pct: (Number) The timestamp for a thumbnail image calculated as a percentage value of the video's duration. To convert from a second-wise timestamp to a percentage, divide the desired timestamp by the total duration of the video.  If this value is not set, the default thumbnail image is taken from 0s of the video.
            uid: (String) A Cloudflare-generated unique identifier for a media item.
            upload_expiry: (String) The date and time when the video upload URL is no longer valid for direct user uploads.
            uploaded: (String) The date and time the media item was uploaded.
            watermark: (Attributes) (see below for nested schema)
            width: (Number) The video width in pixels. A value of -1 means the width is unknown. The value becomes available after the upload and before the video is ready.
        importStatements: []
    cloudflare_stream_audio_track:
        subCategory: ""
        name: cloudflare_stream_audio_track
        title: cloudflare_stream_audio_track Resource - Cloudflare
        examples:
            - name: example_stream_audio_track
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "audio_identifier": "ea95132c15732412d22c1476fa83f27a",
                  "default": true,
                  "identifier": "ea95132c15732412d22c1476fa83f27a",
                  "label": "director commentary"
                }
        argumentDocs:
            account_id: (String) The account identifier tag.
            audio_identifier: (String) The unique identifier for an additional audio track.
            default: (Boolean) Denotes whether the audio track will be played by default in a player.
            identifier: (String) A Cloudflare-generated unique identifier for a media item.
            label: (String) A string to uniquely identify the track amongst other audio track labels for the specified video.
            status: |-
                (String) Specifies the processing status of the video.
                Available values: "queued", "ready", "error".
            uid: (String) A Cloudflare-generated unique identifier for a media item.
        importStatements: []
    cloudflare_stream_caption_language:
        subCategory: ""
        name: cloudflare_stream_caption_language
        title: cloudflare_stream_caption_language Resource - Cloudflare
        examples:
            - name: example_stream_caption_language
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "identifier": "ea95132c15732412d22c1476fa83f27a",
                  "language": "tr"
                }
        argumentDocs:
            account_id: (String) Identifier.
            file: (String) The WebVTT file containing the caption or subtitle content.
            generated: (Boolean) Whether the caption was generated via AI.
            identifier: (String) A Cloudflare-generated unique identifier for a media item.
            label: (String) The language label displayed in the native language to users.
            language: (String) The language tag in BCP 47 format.
            status: |-
                (String) The status of a generated caption.
                Available values: "ready", "inprogress", "error".
        importStatements: []
    cloudflare_stream_download:
        subCategory: ""
        name: cloudflare_stream_download
        title: cloudflare_stream_download Resource - Cloudflare
        examples:
            - name: example_stream_download
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "identifier": "ea95132c15732412d22c1476fa83f27a"
                }
        argumentDocs:
            account_id: (String) Identifier.
            identifier: (String) A Cloudflare-generated unique identifier for a media item.
        importStatements: []
    cloudflare_stream_key:
        subCategory: ""
        name: cloudflare_stream_key
        title: cloudflare_stream_key Resource - Cloudflare
        examples:
            - name: example_stream_key
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            account_id: (String) Identifier.
            created: (String) The date and time a signing key was created.
            id: (String) Identifier.
            jwk: (String, Sensitive) The signing key in JWK format.
            pem: (String, Sensitive) The signing key in PEM format.
        importStatements:
            - $ terraform import cloudflare_stream_key.example '<account_id>'
    cloudflare_stream_live_input:
        subCategory: ""
        name: cloudflare_stream_live_input
        title: cloudflare_stream_live_input Resource - Cloudflare
        examples:
            - name: example_stream_live_input
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "default_creator": "defaultCreator",
                  "delete_recording_after_days": 45,
                  "meta": {
                    "name": "test stream 1"
                  },
                  "recording": {
                    "allowed_origins": [
                      "example.com"
                    ],
                    "hide_live_viewer_count": false,
                    "mode": "off",
                    "require_signed_urls": false,
                    "timeout_seconds": 0
                  }
                }
        argumentDocs:
            account_id: (String) Identifier.
            allowed_origins: (List of String) Lists the origins allowed to display videos created with this input. Enter allowed origin domains in an array and use * for wildcard subdomains. An empty array allows videos to be viewed on any origin.
            created: (String) The date and time the live input was created.
            default_creator: (String) Sets the creator ID asssociated with this live input.
            delete_recording_after_days: (Number) Indicates the number of days after which the live inputs recordings will be deleted. When a stream completes and the recording is ready, the value is used to calculate a scheduled deletion date for that recording. Omit the field to indicate no change, or include with a null value to remove an existing scheduled deletion.
            hide_live_viewer_count: (Boolean) Disables reporting the number of live viewers when this property is set to true.
            live_input_identifier: (String) A unique identifier for a live input.
            meta: (String) A user modifiable key-value store used to reference other systems of record for managing live inputs.
            mode: |-
                (String) Specifies the recording behavior for the live input. Set this value to off to prevent a recording. Set the value to automatic to begin a recording and transition to on-demand after Stream Live stops receiving input.
                Available values: "off", "automatic".
            modified: (String) The date and time the live input was last modified.
            passphrase: (String, Sensitive) The secret key to use when streaming via SRT to a live input.
            recording: (Attributes) Records the input to a Cloudflare Stream video. Behavior depends on the mode. In most cases, the video will initially be viewable as a live video and transition to on-demand after a condition is satisfied. (see below for nested schema)
            require_signed_urls: (Boolean) Indicates if a video using the live input has the requireSignedURLs property set. Also enforces access controls on any video recording of the livestream with the live input.
            rtmps: (Attributes) Details for streaming to an live input using RTMPS. (see below for nested schema)
            rtmps_playback: (Attributes) Details for playback from an live input using RTMPS. (see below for nested schema)
            srt: (Attributes) Details for streaming to a live input using SRT. (see below for nested schema)
            srt_playback: (Attributes) Details for playback from an live input using SRT. (see below for nested schema)
            status: |-
                (String) The connection status of a live input.
                Available values: "connected", "reconnected", "reconnecting", "client_disconnect", "ttl_exceeded", "failed_to_connect", "failed_to_reconnect", "new_configuration_accepted".
            stream_id: (String) The identifier of the live input to use when streaming via SRT.
            stream_key: (String, Sensitive) The secret key to use when streaming via RTMPS to a live input.
            timeout_seconds: (Number) Determines the amount of time a live input configured in automatic mode should wait before a recording transitions from live to on-demand. 0 is recommended for most use cases and indicates the platform default should be used.
            uid: (String) A unique identifier for a live input.
            url: (String, Sensitive) The RTMPS URL you provide to the broadcaster, which they stream live video to.
            web_rtc: (Attributes) Details for streaming to a live input using WebRTC. (see below for nested schema)
            web_rtc_playback: (Attributes) Details for playback from a live input using WebRTC. (see below for nested schema)
        importStatements: []
    cloudflare_stream_watermark:
        subCategory: ""
        name: cloudflare_stream_watermark
        title: cloudflare_stream_watermark Resource - Cloudflare
        examples:
            - name: example_stream_watermark
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "file": "@/Users/rchen/Downloads/watermark.png",
                  "name": "Marketing Videos",
                  "opacity": 0.75,
                  "padding": 0.1,
                  "position": "center",
                  "scale": 0.1
                }
        argumentDocs:
            account_id: (String) The account identifier tag.
            created: (String) The date and a time a watermark profile was created.
            downloaded_from: (String) The source URL for a downloaded image. If the watermark profile was created via direct upload, this field is null.
            file: (String) The image file to upload.
            height: (Number) The height of the image in pixels.
            identifier: (String) The unique identifier for a watermark profile.
            name: (String) A short description of the watermark profile.
            opacity: (Number) The translucency of the image. A value of 0.0 makes the image completely transparent, and 1.0 makes the image completely opaque. Note that if the image is already semi-transparent, setting this to 1.0 will not make the image completely opaque.
            padding: (Number) The whitespace between the adjacent edges (determined by position) of the video and the image. 0.0 indicates no padding, and 1.0 indicates a fully padded video width or length, as determined by the algorithm.
            position: '(String) The location of the image. Valid positions are: upperRight, upperLeft, lowerLeft, lowerRight, and center. Note that center ignores the padding parameter.'
            scale: (Number) The size of the image relative to the overall size of the video. This parameter will adapt to horizontal and vertical videos automatically. 0.0 indicates no scaling (use the size of the image as-is), and 1.0 fills the entire video.
            size: (Number) The size of the image in bytes.
            uid: (String) The unique identifier for a watermark profile.
            width: (Number) The width of the image in pixels.
        importStatements: []
    cloudflare_stream_webhook:
        subCategory: ""
        name: cloudflare_stream_webhook
        title: cloudflare_stream_webhook Resource - Cloudflare
        examples:
            - name: example_stream_webhook
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "notification_url": "https://example.com"
                }
        argumentDocs:
            account_id: (String) The account identifier tag.
            notification_url: (String) The URL where webhooks will be sent.
        importStatements: []
    cloudflare_tiered_cache:
        subCategory: ""
        name: cloudflare_tiered_cache
        title: cloudflare_tiered_cache Resource - Cloudflare
        examples:
            - name: example_tiered_cache
              manifest: |-
                {
                  "value": "on",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            editable: (Boolean) Whether the setting is editable.
            id: (String) Identifier.
            modified_on: (String) Last time this setting was modified.
            value: |-
                (String) Enable or disable the Smart Tiered Cache.
                Available values: "on", "off".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_tiered_cache.example '<zone_id>'
    cloudflare_token_validation_config:
        subCategory: ""
        name: cloudflare_token_validation_config
        title: cloudflare_token_validation_config Resource - Cloudflare
        examples:
            - name: example_token_validation_config
              manifest: |-
                {
                  "credentials": {
                    "keys": [
                      {
                        "alg": "ES256",
                        "crv": "P-256",
                        "kid": "38013f13-c266-4eec-a72a-92ec92779f21",
                        "kty": "EC",
                        "x": "KN53JRwN3wCjm2o39bvZUX2VdrsHzS8pxOAGjm8m7EQ",
                        "y": "lnkkzIxaveggz-HFhcMWW15nxvOj0Z_uQsXbpK0GFcY"
                      }
                    ]
                  },
                  "description": "Long description for Token Validation Configuration",
                  "title": "Example Token Validation Configuration",
                  "token_sources": [
                    "http.request.headers[\"x-auth\"][0]",
                    "http.request.cookies[\"Authorization\"][0]"
                  ],
                  "token_type": "JWT",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            alg: |-
                (String) Algorithm
                Available values: "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384".
            created_at: (String)
            credentials: (Attributes) (see below for nested schema)
            crv: |-
                (String) Curve
                Available values: "P-256", "P-384".
            description: (String)
            e: (String) RSA exponent
            id: (String) UUID.
            keys: (Attributes List) (see below for nested schema)
            kid: (String) Key ID
            kty: |-
                (String) Key Type
                Available values: "RSA", "EC".
            last_updated: (String)
            "n": (String) RSA modulus
            title: (String)
            token_sources: (List of String)
            token_type: '(String) Available values: "JWT".'
            x: (String) X EC coordinate
            "y": (String) Y EC coordinate
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_token_validation_config.example '<zone_id>/<config_id>'
    cloudflare_token_validation_rules:
        subCategory: ""
        name: cloudflare_token_validation_rules
        title: cloudflare_token_validation_rules Resource - Cloudflare
        examples:
            - name: example_token_validation_rules
              manifest: |-
                {
                  "action": "log",
                  "description": "Long description for Token Validation Rule",
                  "enabled": true,
                  "expression": "is_jwt_valid(\"52973293-cb04-4a97-8f55-e7d2ad1107dd\") or is_jwt_valid(\"46eab8d1-6376-45e3-968f-2c649d77d423\")",
                  "selector": {
                    "exclude": [
                      {
                        "operation_ids": [
                          "f9c5615e-fe15-48ce-bec6-cfc1946f1bec",
                          "56828eae-035a-4396-ba07-51c66d680a04"
                        ]
                      }
                    ],
                    "include": [
                      {
                        "host": [
                          "v1.example.com",
                          "v2.example.com"
                        ]
                      }
                    ]
                  },
                  "title": "Example Token Validation Rule",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            action: |-
                (String) Action to take on requests that match operations included in selector and fail expression.
                Available values: "log", "block".
            after: (String) Move rule to after rule with this ID.
            before: (String) Move rule to before rule with this ID.
            created_at: (String)
            description: (String) A human-readable description that gives more details than title.
            enabled: (Boolean) Toggle rule on or off.
            exclude: (Attributes List) Ignore operations that were otherwise included by include. (see below for nested schema)
            expression: (String) Rule expression. Requests that fail to match this expression will be subject to action.
            host: (List of String) Included hostnames.
            id: (String) UUID.
            include: (Attributes List) Select all matching operations. (see below for nested schema)
            index: (Number) Move rule to this position
            last_updated: (String)
            operation_ids: (List of String) Excluded operation IDs.
            position: (Attributes) Update rule order among zone rules. (see below for nested schema)
            selector: (Attributes) Select operations covered by this rule.
            title: (String) A human-readable name for the rule.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_token_validation_rules.example '<zone_id>/<rule_id>'
    cloudflare_total_tls:
        subCategory: ""
        name: cloudflare_total_tls
        title: cloudflare_total_tls Resource - Cloudflare
        examples:
            - name: example_total_tls
              manifest: |-
                {
                  "certificate_authority": "google",
                  "enabled": true,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            certificate_authority: |-
                (String) The Certificate Authority that Total TLS certificates will be issued through.
                Available values: "google", "lets_encrypt", "ssl_com".
            enabled: (Boolean) If enabled, Total TLS will order a hostname specific TLS certificate for any proxied A, AAAA, or CNAME record in your zone.
            id: (String) Identifier.
            validity_period: |-
                (Number) The validity period in days for the certificates ordered via Total TLS.
                Available values: 90.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_total_tls.example '<zone_id>'
    cloudflare_turnstile_widget:
        subCategory: ""
        name: cloudflare_turnstile_widget
        title: cloudflare_turnstile_widget Resource - Cloudflare
        examples:
            - name: example_turnstile_widget
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "bot_fight_mode": false,
                  "clearance_level": "interactive",
                  "domains": [
                    "203.0.113.1",
                    "cloudflare.com",
                    "blog.example.com"
                  ],
                  "ephemeral_id": false,
                  "mode": "invisible",
                  "name": "blog.cloudflare.com login form",
                  "offlabel": false,
                  "region": "world"
                }
        argumentDocs:
            account_id: (String) Identifier
            bot_fight_mode: |-
                (Boolean) If bot_fight_mode is set to true, Cloudflare issues computationally
                expensive challenges in response to malicious bots (ENT only).
            clearance_level: |-
                (String) If Turnstile is embedded on a Cloudflare site and the widget should grant challenge clearance,
                this setting can determine the clearance level to be set
                Available values: "no_clearance", "jschallenge", "managed", "interactive".
            created_on: (String) When the widget was created.
            domains: (List of String)
            ephemeral_id: (Boolean) Return the Ephemeral ID in /siteverify (ENT only).
            id: (String) Widget item identifier tag.
            mode: |-
                (String) Widget Mode
                Available values: "non-interactive", "invisible", "managed".
            modified_on: (String) When the widget was modified.
            name: |-
                (String) Human readable widget name. Not unique. Cloudflare suggests that you
                set this to a meaningful string to make it easier to identify your
                widget, and where it is used.
            offlabel: (Boolean) Do not show any Cloudflare branding on the widget (ENT only).
            region: |-
                (String) Region where this widget can be used. This cannot be changed after creation.
                Available values: "world", "china".
            secret: (String, Sensitive) Secret key for this widget.
            sitekey: (String) Widget item identifier tag.
        importStatements:
            - $ terraform import cloudflare_turnstile_widget.example '<account_id>/<sitekey>'
    cloudflare_universal_ssl_setting:
        subCategory: ""
        name: cloudflare_universal_ssl_setting
        title: cloudflare_universal_ssl_setting Resource - Cloudflare
        examples:
            - name: example_universal_ssl_setting
              manifest: |-
                {
                  "enabled": true,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            enabled: (Boolean) Disabling Universal SSL removes any currently active Universal SSL certificates for your zone from the edge and prevents any future Universal SSL certificates from being ordered. If there are no advanced certificates or custom certificates uploaded for the domain, visitors will be unable to access the domain over HTTPS.
            id: (String) Identifier.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_universal_ssl_setting.example '<zone_id>'
    cloudflare_url_normalization_settings:
        subCategory: ""
        name: cloudflare_url_normalization_settings
        title: cloudflare_url_normalization_settings Resource - Cloudflare
        examples:
            - name: example_url_normalization_settings
              manifest: |-
                {
                  "scope": "incoming",
                  "type": "cloudflare",
                  "zone_id": "9f1839b6152d298aca64c4e906b6d074"
                }
        argumentDocs:
            id: (String) The unique ID of the zone.
            scope: |-
                (String) The scope of the URL normalization.
                Available values: "incoming", "both", "none".
            type: |-
                (String) The type of URL normalization performed by Cloudflare.
                Available values: "cloudflare", "rfc3986".
            zone_id: (String) The unique ID of the zone.
        importStatements:
            - $ terraform import cloudflare_url_normalization_settings.example '<zone_id>'
    cloudflare_user:
        subCategory: ""
        name: cloudflare_user
        title: cloudflare_user Resource - Cloudflare
        examples:
            - name: example_user
              manifest: |-
                {
                  "country": "US",
                  "first_name": "John",
                  "last_name": "Appleseed",
                  "telephone": "+1 123-123-1234",
                  "zipcode": "12345"
                }
        argumentDocs:
            betas: (List of String) Lists the betas that the user is participating in.
            country: (String) The country in which the user lives.
            first_name: (String) User's first name
            has_business_zones: (Boolean) Indicates whether user has any business zones
            has_enterprise_zones: (Boolean) Indicates whether user has any enterprise zones
            has_pro_zones: (Boolean) Indicates whether user has any pro zones
            id: (String) Identifier of the user.
            last_name: (String) User's last name
            name: (String) Organization name.
            organizations: (Attributes List) (see below for nested schema)
            permissions: (List of String) Access permissions for this User.
            roles: (List of String) List of roles that a user has within an organization.
            status: |-
                (String) Whether the user is a member of the organization or has an invitation pending.
                Available values: "member", "invited".
            suspended: (Boolean) Indicates whether user has been suspended
            telephone: (String) User's telephone number
            two_factor_authentication_enabled: (Boolean) Indicates whether two-factor authentication is enabled for the user account. Does not apply to API authentication.
            two_factor_authentication_locked: (Boolean) Indicates whether two-factor authentication is required by one of the accounts that the user is a member of.
            zipcode: (String) The zipcode or postal code where the user lives.
        importStatements: []
    cloudflare_user_agent_blocking_rule:
        subCategory: ""
        name: cloudflare_user_agent_blocking_rule
        title: cloudflare_user_agent_blocking_rule Resource - Cloudflare
        examples:
            - name: example_user_agent_blocking_rule
              manifest: |-
                {
                  "configuration": {
                    "target": "ua",
                    "value": "Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1)"
                  },
                  "description": "Prevent multiple login failures to mitigate brute force attacks",
                  "mode": "challenge",
                  "paused": false,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            configuration: (Attributes) (see below for nested schema)
            description: (String) An informative summary of the rule. This value is sanitized and any tags will be removed.
            id: (String) The unique identifier of the User Agent Blocking rule.
            mode: |-
                (String) The action to apply to a matched request.
                Available values: "block", "challenge", "whitelist", "js_challenge", "managed_challenge".
            paused: (Boolean) When true, indicates that the rule is currently paused.
            target: |-
                (String) The configuration target. You must set the target to ua when specifying a user agent in the rule.
                Available values: "ua".
            value: (String) the user agent to exactly match
            zone_id: (String) Defines an identifier.
        importStatements:
            - $ terraform import cloudflare_user_agent_blocking_rule.example '<zone_id>/<ua_rule_id>'
    cloudflare_waiting_room:
        subCategory: ""
        name: cloudflare_waiting_room
        title: cloudflare_waiting_room Resource - Cloudflare
        examples:
            - name: example_waiting_room
              manifest: |-
                {
                  "additional_routes": [
                    {
                      "host": "shop2.example.com",
                      "path": "/shop2/checkout"
                    }
                  ],
                  "cookie_attributes": {
                    "samesite": "auto",
                    "secure": "auto"
                  },
                  "cookie_suffix": "abcd",
                  "custom_page_html": "{{#waitTimeKnown}} {{waitTime}} mins {{/waitTimeKnown}} {{^waitTimeKnown}} Queue all enabled {{/waitTimeKnown}}",
                  "default_template_language": "es-ES",
                  "description": "Production - DO NOT MODIFY",
                  "disable_session_renewal": false,
                  "enabled_origin_commands": [
                    "revoke"
                  ],
                  "host": "shop.example.com",
                  "json_response_enabled": false,
                  "name": "production_webinar",
                  "new_users_per_minute": 200,
                  "path": "/shop/checkout",
                  "queue_all": true,
                  "queueing_method": "fifo",
                  "queueing_status_code": 202,
                  "session_duration": 1,
                  "suspended": true,
                  "total_active_users": 200,
                  "turnstile_action": "log",
                  "turnstile_mode": "off",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            additional_routes: (Attributes List) Only available for the Waiting Room Advanced subscription. Additional hostname and path combinations to which this waiting room will be applied. There is an implied wildcard at the end of the path. The hostname and path combination must be unique to this and all other waiting rooms. (see below for nested schema)
            cookie_attributes: (Attributes) Configures cookie attributes for the waiting room cookie. This encrypted cookie stores a user's status in the waiting room, such as queue position. (see below for nested schema)
            cookie_suffix: (String) Appends a '_' + a custom suffix to the end of Cloudflare Waiting Room's cookie name(__cf_waitingroom). If cookie_suffix is "abcd", the cookie name will be __cf_waitingroom_abcd. This field is required if using additional_routes.
            created_on: (String)
            custom_page_html: '(String) Only available for the Waiting Room Advanced subscription. This is a template html file that will be rendered at the edge. If no custom_page_html is provided, the default waiting room will be used. The template is based on mustache ( https://mustache.github.io/ ). There are several variables that are evaluated by the Cloudflare edge:'
            default_template_language: |-
                (String) The language of the default page template. If no default_template_language is provided, then en-US (English) will be used.
                Available values: "en-US", "es-ES", "de-DE", "fr-FR", "it-IT", "ja-JP", "ko-KR", "pt-BR", "zh-CN", "zh-TW", "nl-NL", "pl-PL", "id-ID", "tr-TR", "ar-EG", "ru-RU", "fa-IR", "bg-BG", "hr-HR", "cs-CZ", "da-DK", "fi-FI", "lt-LT", "ms-MY", "nb-NO", "ro-RO", "el-GR", "he-IL", "hi-IN", "hu-HU", "sr-BA", "sk-SK", "sl-SI", "sv-SE", "tl-PH", "th-TH", "uk-UA", "vi-VN".
            description: (String) A note that you can use to add more details about the waiting room.
            disable_session_renewal: (Boolean) Only available for the Waiting Room Advanced subscription. Disables automatic renewal of session cookies. If true, an accepted user will have session_duration minutes to browse the site. After that, they will have to go through the waiting room again. If false, a user's session cookie will be automatically renewed on every request.
            enabled_origin_commands: (List of String) A list of enabled origin commands.
            host: (String) The host name to which the waiting room will be applied (no wildcards). Please do not include the scheme (http:// or https://). The host and path combination must be unique.
            id: (String) The ID of this resource.
            json_response_enabled: '(Boolean) Only available for the Waiting Room Advanced subscription. If true, requests to the waiting room with the header Accept: application/json will receive a JSON response object with information on the user''s status in the waiting room as opposed to the configured static HTML page. This JSON response object has one property cfWaitingRoom which is an object containing the following fields:'
            modified_on: (String)
            name: (String) A unique name to identify the waiting room. Only alphanumeric characters, hyphens and underscores are allowed.
            new_users_per_minute: (Number) Sets the number of new users that will be let into the route every minute. This value is used as baseline for the number of users that are let in per minute. So it is possible that there is a little more or little less traffic coming to the route based on the traffic patterns at that time around the world.
            next_event_prequeue_start_time: (String) An ISO 8601 timestamp that marks when the next event will begin queueing.
            next_event_start_time: (String) An ISO 8601 timestamp that marks when the next event will start.
            path: (String) Sets the path within the host to enable the waiting room on. The waiting room will be enabled for all subpaths as well. If there are two waiting rooms on the same subpath, the waiting room for the most specific path will be chosen. Wildcards and query parameters are not supported.
            queue_all: (Boolean) If queue_all is true, all the traffic that is coming to a route will be sent to the waiting room. No new traffic can get to the route once this field is set and estimated time will become unavailable.
            queueing_method: '(String) Sets the queueing method used by the waiting room. Changing this parameter from the default queueing method is only available for the Waiting Room Advanced subscription. Regardless of the queueing method, if queue_all is enabled or an event is prequeueing, users in the waiting room will not be accepted to the origin. These users will always see a waiting room page that refreshes automatically. The valid queueing methods are:'
            queueing_status_code: |-
                (Number) HTTP status code returned to a user while in the queue.
                Available values: 200, 202, 429.
            samesite: |-
                (String) Configures the SameSite attribute on the waiting room cookie. Value auto will be translated to lax or none depending if Always Use HTTPS is enabled. Note that when using value none, the secure attribute cannot be set to never.
                Available values: "auto", "lax", "none", "strict".
            secure: |-
                (String) Configures the Secure attribute on the waiting room cookie. Value always indicates that the Secure attribute will be set in the Set-Cookie header, never indicates that the Secure attribute will not be set, and auto will set the Secure attribute depending if Always Use HTTPS is enabled.
                Available values: "auto", "always", "never".
            session_duration: (Number) Lifetime of a cookie (in minutes) set by Cloudflare for users who get access to the route. If a user is not seen by Cloudflare again in that time period, they will be treated as a new user that visits the route.
            suspended: (Boolean) Suspends or allows traffic going to the waiting room. If set to true, the traffic will not go to the waiting room.
            total_active_users: (Number) Sets the total number of active user sessions on the route at a point in time. A route is a combination of host and path on which a waiting room is available. This value is used as a baseline for the total number of active user sessions on the route. It is possible to have a situation where there are more or less active users sessions on the route based on the traffic patterns at that time around the world.
            turnstile_action: |-
                (String) Which action to take when a bot is detected using Turnstile. log will
                have no impact on queueing behavior, simply keeping track of how many
                bots are detected in Waiting Room Analytics. infinite_queue will send
                bots to a false queueing state, where they will never reach your
                origin. infinite_queue requires Advanced Waiting Room.
                Available values: "log", "infinite_queue".
            turnstile_mode: |-
                (String) Which Turnstile widget type to use for detecting bot traffic. See
                the Turnstile documentation
                for the definitions of these widget types. Set to off to disable the
                Turnstile integration entirely. Setting this to anything other than
                off or invisible requires Advanced Waiting Room.
                Available values: "off", "invisible", "visible_non_interactive", "visible_managed".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_waiting_room.example '<zone_id>/<waiting_room_id>'
    cloudflare_waiting_room_event:
        subCategory: ""
        name: cloudflare_waiting_room_event
        title: cloudflare_waiting_room_event Resource - Cloudflare
        examples:
            - name: example_waiting_room_event
              manifest: |-
                {
                  "custom_page_html": "{{#waitTimeKnown}} {{waitTime}} mins {{/waitTimeKnown}} {{^waitTimeKnown}} Event is prequeueing / Queue all enabled {{/waitTimeKnown}}",
                  "description": "Production event - DO NOT MODIFY",
                  "disable_session_renewal": true,
                  "event_end_time": "2021-09-28T17:00:00.000Z",
                  "event_start_time": "2021-09-28T15:30:00.000Z",
                  "name": "production_webinar_event",
                  "new_users_per_minute": 200,
                  "prequeue_start_time": "2021-09-28T15:00:00.000Z",
                  "queueing_method": "random",
                  "session_duration": 1,
                  "shuffle_at_event_start": true,
                  "suspended": true,
                  "total_active_users": 200,
                  "turnstile_action": "log",
                  "turnstile_mode": "off",
                  "waiting_room_id": "699d98642c564d2e855e9661899b7252",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            created_on: (String)
            custom_page_html: (String) If set, the event will override the waiting room's custom_page_html property while it is active. If null, the event will inherit it.
            description: (String) A note that you can use to add more details about the event.
            disable_session_renewal: (Boolean) If set, the event will override the waiting room's disable_session_renewal property while it is active. If null, the event will inherit it.
            event_end_time: (String) An ISO 8601 timestamp that marks the end of the event.
            event_start_time: (String) An ISO 8601 timestamp that marks the start of the event. At this time, queued users will be processed with the event's configuration. The start time must be at least one minute before event_end_time.
            id: (String) The ID of this resource.
            modified_on: (String)
            name: (String) A unique name to identify the event. Only alphanumeric characters, hyphens and underscores are allowed.
            new_users_per_minute: (Number) If set, the event will override the waiting room's new_users_per_minute property while it is active. If null, the event will inherit it. This can only be set if the event's total_active_users property is also set.
            prequeue_start_time: (String) An ISO 8601 timestamp that marks when to begin queueing all users before the event starts. The prequeue must start at least five minutes before event_start_time.
            queueing_method: (String) If set, the event will override the waiting room's queueing_method property while it is active. If null, the event will inherit it.
            session_duration: (Number) If set, the event will override the waiting room's session_duration property while it is active. If null, the event will inherit it.
            shuffle_at_event_start: (Boolean) If enabled, users in the prequeue will be shuffled randomly at the event_start_time. Requires that prequeue_start_time is not null. This is useful for situations when many users will join the event prequeue at the same time and you want to shuffle them to ensure fairness. Naturally, it makes the most sense to enable this feature when the queueing_method during the event respects ordering such as fifo, or else the shuffling may be unnecessary.
            suspended: (Boolean) Suspends or allows an event. If set to true, the event is ignored and traffic will be handled based on the waiting room configuration.
            total_active_users: (Number) If set, the event will override the waiting room's total_active_users property while it is active. If null, the event will inherit it. This can only be set if the event's new_users_per_minute property is also set.
            turnstile_action: |-
                (String) If set, the event will override the waiting room's turnstile_action property while it is active. If null, the event will inherit it.
                Available values: "log", "infinite_queue".
            turnstile_mode: |-
                (String) If set, the event will override the waiting room's turnstile_mode property while it is active. If null, the event will inherit it.
                Available values: "off", "invisible", "visible_non_interactive", "visible_managed".
            waiting_room_id: (String)
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_waiting_room_event.example '<zone_id>/<waiting_room_id>/<event_id>'
    cloudflare_waiting_room_rules:
        subCategory: ""
        name: cloudflare_waiting_room_rules
        title: cloudflare_waiting_room_rules Resource - Cloudflare
        examples:
            - name: example_waiting_room_rules
              manifest: |-
                {
                  "rules": [
                    {
                      "action": "bypass_waiting_room",
                      "description": "allow all traffic from 10.20.30.40",
                      "enabled": true,
                      "expression": "ip.src in {10.20.30.40}"
                    }
                  ],
                  "waiting_room_id": "699d98642c564d2e855e9661899b7252",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            action: |-
                (String) The action to take when the expression matches.
                Available values: "bypass_waiting_room".
            description: (String) The description of the rule.
            enabled: (Boolean) When set to true, the rule is enabled.
            expression: (String) Criteria defining when there is a match for the current rule.
            id: (String) The ID of the rule.
            rules: (Attributes List) (see below for nested schema)
            waiting_room_id: (String)
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_waiting_room_rules.example '<zone_id>/<waiting_room_id>'
    cloudflare_waiting_room_settings:
        subCategory: ""
        name: cloudflare_waiting_room_settings
        title: cloudflare_waiting_room_settings Resource - Cloudflare
        examples:
            - name: example_waiting_room_settings
              manifest: |-
                {
                  "search_engine_crawler_bypass": true,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            id: (String) Identifier.
            search_engine_crawler_bypass: |-
                (Boolean) Whether to allow verified search engine crawlers to bypass all waiting rooms on this zone.
                Verified search engine crawlers will not be tracked or counted by the waiting room system,
                and will not appear in waiting room analytics.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_waiting_room_settings.example '<zone_id>'
    cloudflare_web_analytics_rule:
        subCategory: ""
        name: cloudflare_web_analytics_rule
        title: cloudflare_web_analytics_rule Resource - Cloudflare
        examples:
            - name: example_web_analytics_rule
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "host": "example.com",
                  "inclusive": true,
                  "is_paused": false,
                  "paths": [
                    "*"
                  ],
                  "ruleset_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415"
                }
        argumentDocs:
            account_id: (String) Identifier.
            created: (String)
            host: (String)
            id: (String) The Web Analytics rule identifier.
            inclusive: (Boolean) Whether the rule includes or excludes traffic from being measured.
            is_paused: (Boolean) Whether the rule is paused or not.
            paths: (List of String)
            priority: (Number)
            ruleset_id: (String) The Web Analytics ruleset identifier.
        importStatements: []
    cloudflare_web_analytics_site:
        subCategory: ""
        name: cloudflare_web_analytics_site
        title: cloudflare_web_analytics_site Resource - Cloudflare
        examples:
            - name: example_web_analytics_site
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "auto_install": true,
                  "host": "example.com",
                  "zone_tag": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            account_id: (String) Identifier.
            auto_install: (Boolean) If enabled, the JavaScript snippet is automatically injected for orange-clouded sites.
            created: (String)
            enabled: (Boolean) Enables or disables RUM. This option can be used only when auto_install is set to true.
            host: (String) The hostname to use for gray-clouded sites.
            id: (String) The Web Analytics site identifier.
            inclusive: (Boolean) Whether the rule includes or excludes traffic from being measured.
            is_paused: (Boolean) Whether the rule is paused or not.
            lite: (Boolean) If enabled, the JavaScript snippet will not be injected for visitors from the EU.
            paths: (List of String) The paths the rule will be applied to.
            priority: (Number)
            rules: (Attributes List) A list of rules. (see below for nested schema)
            ruleset: (Attributes) (see below for nested schema)
            site_tag: (String) The Web Analytics site identifier.
            site_token: (String) The Web Analytics site token.
            snippet: (String) Encoded JavaScript snippet.
            zone_name: (String)
            zone_tag: (String) The zone identifier.
        importStatements:
            - $ terraform import cloudflare_web_analytics_site.example '<account_id>/<site_id>'
    cloudflare_web3_hostname:
        subCategory: ""
        name: cloudflare_web3_hostname
        title: cloudflare_web3_hostname Resource - Cloudflare
        examples:
            - name: example_web3_hostname
              manifest: |-
                {
                  "description": "This is my IPFS gateway.",
                  "dnslink": "/ipns/onboarding.ipfs.cloudflare.com",
                  "name": "gateway.example.com",
                  "target": "ipfs",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            created_on: (String)
            description: (String) Specify an optional description of the hostname.
            dnslink: (String) Specify the DNSLink value used if the target is ipfs.
            id: (String) Specify the identifier of the hostname.
            modified_on: (String)
            name: (String) Specify the hostname that points to the target gateway via CNAME.
            status: |-
                (String) Specifies the status of the hostname's activation.
                Available values: "active", "pending", "deleting", "error".
            target: |-
                (String) Specify the target gateway of the hostname.
                Available values: "ethereum", "ipfs", "ipfs_universal_path".
            zone_id: (String) Specify the identifier of the hostname.
        importStatements:
            - $ terraform import cloudflare_web3_hostname.example '<zone_id>/<identifier>'
    cloudflare_worker:
        subCategory: ""
        name: cloudflare_worker
        title: cloudflare_worker Resource - Cloudflare
        examples:
            - name: example_worker
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "logpush": true,
                  "name": "my-worker",
                  "observability": {
                    "enabled": true,
                    "head_sampling_rate": 1,
                    "logs": {
                      "enabled": true,
                      "head_sampling_rate": 1,
                      "invocation_logs": true
                    }
                  },
                  "subdomain": {
                    "enabled": true,
                    "previews_enabled": true
                  },
                  "tags": [
                    "my-team",
                    "my-public-api"
                  ],
                  "tail_consumers": [
                    {
                      "name": "my-tail-consumer"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Identifier.
            certificate_id: (String) ID of the TLS certificate issued for the custom domain.
            created_on: (String) When the Worker was created.
            dispatch_namespace_outbounds: (Attributes List) Other Workers that reference the Worker as an outbound for a dispatch namespace. (see below for nested schema)
            domains: (Attributes List) Custom domains connected to the Worker. (see below for nested schema)
            durable_objects: (Attributes List) Other Workers that reference Durable Object classes implemented by the Worker. (see below for nested schema)
            enabled: (Boolean) Whether observability is enabled for the Worker.
            head_sampling_rate: (Number) The sampling rate for observability. From 0 to 1 (1 = 100%, 0.1 = 10%).
            hostname: (String) Full hostname of the custom domain, including the zone name.
            id: (String) Immutable ID of the Worker.
            invocation_logs: (Boolean) Whether invocation logs are enabled for the Worker.
            logpush: (Boolean) Whether logpush is enabled for the Worker.
            logs: (Attributes) Log settings for the Worker. (see below for nested schema)
            name: (String) Name of the Worker.
            namespace_id: (String) ID of the dispatch namespace.
            namespace_name: (String) Name of the dispatch namespace.
            observability: (Attributes) Observability settings for the Worker. (see below for nested schema)
            previews_enabled: (Boolean) Whether preview URLs are enabled for the Worker.
            queue_consumer_id: (String) ID of the queue consumer configuration.
            queue_id: (String) ID of the queue.
            queue_name: (String) Name of the queue.
            queues: (Attributes List) Queues that send messages to the Worker. (see below for nested schema)
            references: (Attributes) Other resources that reference the Worker and depend on it existing. (see below for nested schema)
            subdomain: (Attributes) Subdomain settings for the Worker. (see below for nested schema)
            tags: (Set of String) Tags associated with the Worker.
            tail_consumers: (Attributes Set) Other Workers that should consume logs from the Worker. (see below for nested schema)
            updated_on: (String) When the Worker was most recently updated.
            worker_id: (String) ID of the Worker using the dispatch namespace.
            worker_name: (String) Name of the Worker using the dispatch namespace.
            workers: (Attributes List) Other Workers that reference the Worker using service bindings. (see below for nested schema)
            zone_id: (String) ID of the zone.
            zone_name: (String) Name of the zone.
        importStatements:
            - $ terraform import cloudflare_worker.example '<account_id>/<worker_id>'
    cloudflare_worker_version:
        subCategory: ""
        name: cloudflare_worker_version
        title: cloudflare_worker_version Resource - Cloudflare
        examples:
            - name: example_worker_version
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "annotations": {
                    "workers_message": "Fixed bug.",
                    "workers_tag": "v1.0.1"
                  },
                  "assets": {
                    "config": {
                      "html_handling": "auto-trailing-slash",
                      "not_found_handling": "404-page",
                      "run_worker_first": [
                        "string"
                      ]
                    },
                    "jwt": "jwt"
                  },
                  "bindings": [
                    {
                      "name": "MY_ENV_VAR",
                      "text": "my_data",
                      "type": "plain_text"
                    }
                  ],
                  "compatibility_date": "2021-01-01",
                  "compatibility_flags": [
                    "nodejs_compat"
                  ],
                  "limits": {
                    "cpu_ms": 50
                  },
                  "main_module": "index.js",
                  "migrations": {
                    "deleted_classes": [
                      "string"
                    ],
                    "new_classes": [
                      "string"
                    ],
                    "new_sqlite_classes": [
                      "string"
                    ],
                    "new_tag": "v2",
                    "old_tag": "v1",
                    "renamed_classes": [
                      {
                        "from": "from",
                        "to": "to"
                      }
                    ],
                    "transferred_classes": [
                      {
                        "from": "from",
                        "from_script": "from_script",
                        "to": "to"
                      }
                    ]
                  },
                  "modules": [
                    {
                      "content_file": "dist/index.js",
                      "content_type": "application/javascript+module",
                      "name": "index.js"
                    }
                  ],
                  "placement": {
                    "mode": "smart"
                  },
                  "worker_id": "worker_id"
                }
        argumentDocs:
            account_id: (String) Identifier.
            algorithm: (String) Algorithm-specific key parameters. Learn more.
            allowed_destination_addresses: (List of String) List of allowed destination addresses.
            allowed_sender_addresses: (List of String) List of allowed sender addresses.
            annotations: (Attributes) Metadata about the version. (see below for nested schema)
            asset_manifest_sha256: (String) The SHA-256 hash of the asset manifest of files to upload.
            assets: (Attributes) Configuration for assets within a Worker.
            bindings: '(Attributes List) List of bindings attached to a Worker. You can find more about bindings on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/#bindings. (see below for nested schema)'
            bucket_name: (String) R2 bucket to bind to.
            certificate_id: (String) Identifier of the certificate to bind to.
            class_name: (String) The exported class name of the Durable Object.
            compatibility_date: (String) Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
            compatibility_flags: (Set of String) Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a compatibility_date.
            config: (Attributes) Configuration for assets within a Worker. (see below for nested schema)
            content_base64: (String) The base64-encoded module content.
            content_file: (String) The file path of the module content.
            content_sha256: (String) The SHA-256 hash of the module content.
            content_type: (String) The content type of the module.
            cpu_ms: (Number) CPU time limit in milliseconds.
            created_on: (String) When the version was created.
            dataset: (String) The name of the dataset to bind to.
            deleted_classes: (List of String) A list of classes to delete Durable Object namespaces from.
            destination_address: (String) Destination address for the email.
            directory: (String) Path to the directory containing asset files to upload.
            environment: (String) The environment of the script_name to bind to.
            format: |-
                (String) Data format of the key. Learn more.
                Available values: "raw", "pkcs8", "spki", "jwk".
            from: (String)
            from_script: (String)
            html_handling: |-
                (String) Determines the redirects and rewrites of requests for HTML content.
                Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
            id: (String) Version identifier.
            index_name: (String) Name of the Vectorize index to bind to.
            json: (String) JSON data to use.
            jurisdiction: |-
                (String) The jurisdiction of the R2 bucket.
                Available values: "eu", "fedramp".
            jwt: (String, Sensitive) Token provided upon successful upload of all files from a registered manifest.
            key_base64: (String, Sensitive) Base64-encoded key data. Required if format is "raw", "pkcs8", or "spki".
            key_jwk: (String, Sensitive) Key data in JSON Web Key format. Required if format is "jwk".
            limits: (Attributes) Resource limits enforced at runtime. (see below for nested schema)
            main_module: (String) The name of the main module in the modules array (e.g. the name of the module that exports a fetch handler).
            main_script_base64: (String) The base64-encoded main script content. This is only returned for service worker syntax workers (not ES modules). Used when importing existing workers that use the older service worker syntax.
            migrations: (Attributes) Migrations for Durable Objects associated with the version. Migrations are applied when the version is deployed. (see below for nested schema)
            mode: |-
                (String) Placement mode for the version.
                Available values: "smart".
            modules: (Attributes Set) Code, sourcemaps, and other content used at runtime.
            name: (String) A JavaScript variable name for the binding.
            namespace: (String) The name of the dispatch namespace.
            namespace_id: (String) Namespace identifier tag.
            new_classes: (List of String) A list of classes to create Durable Object namespaces from.
            new_sqlite_classes: (List of String) A list of classes to create Durable Object namespaces with SQLite from.
            new_tag: (String) Tag to set as the latest migration tag.
            not_found_handling: |-
                (String) Determines the response when a request does not match a static asset, and there is no Worker script.
                Available values: "none", "404-page", "single-page-application".
            number: (Number) The integer version number, starting from one.
            old_name: (String) The old name of the inherited binding. If set, the binding will be renamed from old_name to name in the new version. If not set, the binding will keep the same name between versions.
            old_tag: (String) Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
            outbound: (Attributes) Outbound worker. (see below for nested schema)
            params: (List of String) Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
            part: (String) The name of the file containing the data content. Only accepted for service worker syntax Workers.
            pipeline: (String) Name of the Pipeline to bind to.
            placement: (Attributes) Placement settings for the version. (see below for nested schema)
            queue_name: (String) Name of the Queue to bind to.
            renamed_classes: (Attributes List) A list of classes with Durable Object namespaces that were renamed. (see below for nested schema)
            run_worker_first: (Dynamic) When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
            script_name: (String) The script where the Durable Object is defined, if it is external to this Worker.
            secret_name: (String) Name of the secret in the store.
            service: (String) Name of Worker to bind to.
            source: (String) The client used to create the version.
            startup_time_ms: (Number) Time in milliseconds spent on Worker startup.
            steps: (Attributes List) Migrations to apply in order. (see below for nested schema)
            store_id: (String) ID of the store containing the secret.
            text: (String, Sensitive) The text value to use.
            to: (String)
            transferred_classes: (Attributes List) A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker. (see below for nested schema)
            type: |-
                (String) The kind of resource that the binding provides.
                Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
            usage_model: |-
                (String, Deprecated) Usage model for the version.
                Available values: "standard", "bundled", "unbound".
            usages: (Set of String) Allowed operations with the key. Learn more.
            version_id: (String) Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
            worker: (Attributes) Outbound worker. (see below for nested schema)
            worker_id: (String) Identifier for the Worker, which can be ID or name.
            workers_message: (String) Human-readable message about the version.
            workers_tag: (String) User-provided identifier for the version.
            workers_triggered_by: (String) Operation that triggered the creation of the version.
            workflow_name: (String) Name of the Workflow to bind to.
        importStatements:
            - $ terraform import cloudflare_worker_version.example '<account_id>/<worker_id>/<version_id>'
    cloudflare_workers_cron_trigger:
        subCategory: ""
        name: cloudflare_workers_cron_trigger
        title: cloudflare_workers_cron_trigger Resource - Cloudflare
        examples:
            - name: example_workers_cron_trigger
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "body": [
                    {
                      "cron": "*/30 * * * *"
                    }
                  ],
                  "script_name": "this-is_my_script-01"
                }
        argumentDocs:
            account_id: (String) Identifier.
            created_on: (String)
            cron: (String)
            id: (String) Name of the script, used in URLs and route configuration.
            modified_on: (String)
            schedules: (Attributes List) (see below for nested schema)
            script_name: (String) Name of the script, used in URLs and route configuration.
        importStatements:
            - $ terraform import cloudflare_workers_cron_trigger.example '<account_id>/<script_name>'
    cloudflare_workers_custom_domain:
        subCategory: ""
        name: cloudflare_workers_custom_domain
        title: cloudflare_workers_custom_domain Resource - Cloudflare
        examples:
            - name: example_workers_custom_domain
              manifest: |-
                {
                  "account_id": "9a7806061c88ada191ed06f989cc3dac",
                  "environment": "production",
                  "hostname": "foo.example.com",
                  "service": "foo",
                  "zone_id": "593c9c94de529bbbfaac7c53ced0447d"
                }
        argumentDocs:
            account_id: (String) Identifer of the account.
            environment: (String, Deprecated) Worker environment associated with the zone and hostname.
            hostname: (String) Hostname of the Worker Domain.
            id: (String) Identifer of the Worker Domain.
            service: (String) Worker service associated with the zone and hostname.
            zone_id: (String) Identifier of the zone.
            zone_name: (String) Name of the zone.
        importStatements:
            - $ terraform import cloudflare_workers_custom_domain.example '<account_id>/<domain_id>'
    cloudflare_workers_deployment:
        subCategory: ""
        name: cloudflare_workers_deployment
        title: cloudflare_workers_deployment Resource - Cloudflare
        examples:
            - name: example_workers_deployment
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "annotations": {
                    "workers_message": "Deploy bug fix."
                  },
                  "script_name": "this-is_my_script-01",
                  "strategy": "percentage",
                  "versions": [
                    {
                      "percentage": 100,
                      "version_id": "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Identifier.
            annotations: (Attributes) (see below for nested schema)
            author_email: (String)
            created_on: (String)
            id: (String) The ID of this resource.
            percentage: (Number)
            script_name: (String) Name of the script, used in URLs and route configuration.
            source: (String)
            strategy: '(String) Available values: "percentage".'
            version_id: (String)
            versions: (Attributes List) (see below for nested schema)
            workers_message: (String) Human-readable message about the deployment. Truncated to 100 bytes.
            workers_triggered_by: (String) Operation that triggered the creation of the deployment.
        importStatements:
            - $ terraform import cloudflare_workers_deployment.example '<account_id>/<script_name>/<deployment_id>'
    cloudflare_workers_for_platforms_dispatch_namespace:
        subCategory: ""
        name: cloudflare_workers_for_platforms_dispatch_namespace
        title: cloudflare_workers_for_platforms_dispatch_namespace Resource - Cloudflare
        examples:
            - name: example_workers_for_platforms_dispatch_namespace
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "my-dispatch-namespace"
                }
        argumentDocs:
            account_id: (String) Identifier.
            created_by: (String) Identifier.
            created_on: (String) When the script was created.
            id: (String) Name of the Workers for Platforms dispatch namespace.
            modified_by: (String) Identifier.
            modified_on: (String) When the script was last modified.
            name: (String) The name of the dispatch namespace.
            namespace_id: (String) API Resource UUID tag.
            namespace_name: (String) Name of the Workers for Platforms dispatch namespace.
            script_count: (Number) The current number of scripts in this Dispatch Namespace.
            trusted_workers: (Boolean) Whether the Workers in the namespace are executed in a "trusted" manner. When a Worker is trusted, it has access to the shared caches for the zone in the Cache API, and has access to the request.cf object on incoming Requests. When a Worker is untrusted, caches are not shared across the zone, and request.cf is undefined. By default, Workers in a namespace are "untrusted".
        importStatements:
            - $ terraform import cloudflare_workers_for_platforms_dispatch_namespace.example '<account_id>/<dispatch_namespace>'
    cloudflare_workers_kv:
        subCategory: ""
        name: cloudflare_workers_kv
        title: cloudflare_workers_kv Resource - Cloudflare
        examples:
            - name: example_workers_kv
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "key_name": "My-Key",
                  "metadata": {},
                  "namespace_id": "0f2ac74b498b48028cb68387c421e279",
                  "value": "Some Value"
                }
        argumentDocs:
            account_id: (String) Identifier.
            id: (String) A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL.
            key_name: (String) A key's name. The name may be at most 512 bytes. All printable, non-whitespace characters are valid. Use percent-encoding to define key names as part of a URL.
            metadata: (String) Associates arbitrary JSON data with a key/value pair.
            namespace_id: (String) Namespace identifier tag.
            value: (String) A byte sequence to be stored, up to 25 MiB in length.
        importStatements:
            - $ terraform import cloudflare_workers_kv.example '<account_id>/<namespace_id>/<key_name>'
    cloudflare_workers_kv_namespace:
        subCategory: ""
        name: cloudflare_workers_kv_namespace
        title: cloudflare_workers_kv_namespace Resource - Cloudflare
        examples:
            - name: example_workers_kv_namespace
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "title": "My Own Namespace"
                }
        argumentDocs:
            account_id: (String) Identifier.
            id: (String) Namespace identifier tag.
            supports_url_encoding: (Boolean) True if keys written on the URL will be URL-decoded before storing. For example, if set to "true", a key written on the URL as "%3F" will be stored as "?".
            title: (String) A human-readable string name for a Namespace.
        importStatements:
            - $ terraform import cloudflare_workers_kv_namespace.example '<account_id>/<namespace_id>'
    cloudflare_workers_route:
        subCategory: ""
        name: cloudflare_workers_route
        title: cloudflare_workers_route Resource - Cloudflare
        examples:
            - name: example_workers_route
              manifest: |-
                {
                  "pattern": "example.com/*",
                  "script": "my-workers-script",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            id: (String) Identifier.
            pattern: (String) Pattern to match incoming requests against. Learn more.
            script: (String) Name of the script to run if the route matches.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_workers_route.example '<zone_id>/<route_id>'
    cloudflare_workers_script:
        subCategory: ""
        name: cloudflare_workers_script
        title: cloudflare_workers_script Resource - Cloudflare
        examples:
            - name: example_workers_script
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "assets": {
                    "config": {
                      "headers": "        /dashboard/*\n        X-Frame-Options: DENY\n\n        /static/*\n        Access-Control-Allow-Origin: *\n",
                      "html_handling": "auto-trailing-slash",
                      "not_found_handling": "none",
                      "redirects": "        /foo /bar 301\n        /news/* /blog/:splat\n",
                      "run_worker_first": false
                    },
                    "jwt": "jwt"
                  },
                  "bindings": [
                    {
                      "name": "MY_ENV_VAR",
                      "text": "my_data",
                      "type": "plain_text"
                    }
                  ],
                  "compatibility_date": "2021-01-01",
                  "compatibility_flags": [
                    "nodejs_compat"
                  ],
                  "content_file": "worker.js",
                  "content_sha256": "${filesha256(\"worker.js\")}",
                  "keep_assets": false,
                  "keep_bindings": [
                    "kv_namespace"
                  ],
                  "limits": {
                    "cpu_ms": 50
                  },
                  "logpush": false,
                  "main_module": "worker.js",
                  "migrations": {
                    "deleted_classes": [
                      "string"
                    ],
                    "new_classes": [
                      "string"
                    ],
                    "new_sqlite_classes": [
                      "string"
                    ],
                    "new_tag": "v2",
                    "old_tag": "v1",
                    "renamed_classes": [
                      {
                        "from": "from",
                        "to": "to"
                      }
                    ],
                    "transferred_classes": [
                      {
                        "from": "from",
                        "from_script": "from_script",
                        "to": "to"
                      }
                    ]
                  },
                  "observability": {
                    "enabled": true,
                    "head_sampling_rate": 0.1,
                    "logs": {
                      "destinations": [
                        "cloudflare"
                      ],
                      "enabled": true,
                      "head_sampling_rate": 0.1,
                      "invocation_logs": true,
                      "persist": true
                    }
                  },
                  "placement": {
                    "mode": "smart"
                  },
                  "script_name": "this-is_my_script-01",
                  "tail_consumers": [
                    {
                      "environment": "production",
                      "namespace": "my-namespace",
                      "service": "my-log-consumer"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String) Identifier.
            algorithm: (String) Algorithm-specific key parameters. Learn more.
            allowed_destination_addresses: (List of String) List of allowed destination addresses.
            allowed_sender_addresses: (List of String) List of allowed sender addresses.
            asset_manifest_sha256: (String) The SHA-256 hash of the asset manifest of files to upload.
            assets: (Attributes) Configuration for assets within a Worker. (see below for nested schema)
            bindings: '(Attributes List) List of bindings attached to a Worker. You can find more about bindings on our docs: https://developers.cloudflare.com/workers/configuration/multipart-upload-metadata/#bindings. (see below for nested schema)'
            body_part: (String) Name of the uploaded file that contains the script (e.g. the file adding a listener to the fetch event). Indicates a service worker syntax Worker.
            bucket_name: (String) R2 bucket to bind to.
            certificate_id: (String) Identifier of the certificate to bind to.
            class_name: (String) The exported class name of the Durable Object.
            compatibility_date: (String) Date indicating targeted support in the Workers runtime. Backwards incompatible fixes to the runtime following this date will not affect this Worker.
            compatibility_flags: (Set of String) Flags that enable or disable certain features in the Workers runtime. Used to enable upcoming features or opt in or out of specific changes not included in a compatibility_date.
            config: (Attributes) Configuration for assets within a Worker. (see below for nested schema)
            content: (String) Module or Service Worker contents of the Worker. Conflicts with content_file.
            content_file: (String) Path to a file containing the Module or Service Worker contents of the Worker. Conflicts with content. Must be paired with content_sha256.
            content_sha256: (String) SHA-256 hash of the Worker contents. Used to trigger updates when source code changes. Must be provided when content_file is specified.
            content_type: (String) Content-Type of the Worker. Required if uploading a non-JavaScript Worker (e.g. "text/x-python").
            cpu_ms: (Number) The amount of CPU time this Worker can use in milliseconds.
            created_on: (String) When the script was created.
            dataset: (String) The name of the dataset to bind to.
            deleted_classes: (List of String) A list of classes to delete Durable Object namespaces from.
            destination_address: (String) Destination address for the email.
            destinations: (List of String) A list of destinations where logs will be exported to.
            directory: (String) Path to the directory containing asset files to upload.
            enabled: (Boolean) Whether observability is enabled for the Worker.
            environment: (String) The environment of the script_name to bind to.
            etag: (String) Hashed script content, can be used in a If-None-Match header when updating.
            format: |-
                (String) Data format of the key. Learn more.
                Available values: "raw", "pkcs8", "spki", "jwk".
            from: (String)
            from_script: (String)
            handlers: (List of String) The names of handlers exported as part of the default export.
            has_assets: (Boolean) Whether a Worker contains assets.
            has_modules: (Boolean) Whether a Worker contains modules.
            head_sampling_rate: (Number) The sampling rate for incoming requests. From 0 to 1 (1 = 100%, 0.1 = 10%). Default is 1.
            headers: (String) The contents of a _headers file (used to attach custom headers on asset responses).
            host: (String) TCP host and port for targeted placement.
            hostname: (String) HTTP hostname for targeted placement.
            html_handling: |-
                (String) Determines the redirects and rewrites of requests for HTML content.
                Available values: "auto-trailing-slash", "force-trailing-slash", "drop-trailing-slash", "none".
            id: (String) Name of the script, used in URLs and route configuration.
            index_name: (String) Name of the Vectorize index to bind to.
            invocation_logs: (Boolean) Whether invocation logs are enabled for the Worker.
            json: (String) JSON data to use.
            jurisdiction: |-
                (String) The jurisdiction of the R2 bucket.
                Available values: "eu", "fedramp".
            jwt: (String, Sensitive) Token provided upon successful upload of all files from a registered manifest.
            keep_assets: (Boolean) Retain assets which exist for a previously uploaded Worker version; used in lieu of providing a completion token.
            keep_bindings: (Set of String) List of binding types to keep from previous_upload.
            key_base64: (String, Sensitive) Base64-encoded key data. Required if format is "raw", "pkcs8", or "spki".
            key_jwk: (String, Sensitive) Key data in JSON Web Key format. Required if format is "jwk".
            last_analyzed_at: (String) The last time the script was analyzed for Smart Placement.
            last_deployed_from: (String) The client most recently used to deploy this Worker.
            limits: (Attributes) Limits to apply for this Worker. (see below for nested schema)
            logpush: (Boolean) Whether Logpush is turned on for the Worker.
            logs: (Attributes) Log settings for the Worker. (see below for nested schema)
            main_module: (String) Name of the uploaded file that contains the main module (e.g. the file exporting a fetch handler). Indicates a module syntax Worker.
            migration_tag: (String) The tag of the Durable Object migration that was most recently applied for this Worker.
            migrations: (Attributes) Migrations to apply for Durable Objects associated with this Worker. (see below for nested schema)
            mode: |-
                (String) Enables Smart Placement.
                Available values: "smart".
            modified_on: (String) When the script was last modified.
            name: (String) A JavaScript variable name for the binding.
            named_handlers: (Attributes List) Named exports, such as Durable Object class implementations and named entrypoints. (see below for nested schema)
            namespace: (String) The name of the dispatch namespace.
            namespace_id: (String) Namespace identifier tag.
            new_classes: (List of String) A list of classes to create Durable Object namespaces from.
            new_sqlite_classes: (List of String) A list of classes to create Durable Object namespaces with SQLite from.
            new_tag: (String) Tag to set as the latest migration tag.
            not_found_handling: |-
                (String) Determines the response when a request does not match a static asset, and there is no Worker script.
                Available values: "none", "404-page", "single-page-application".
            observability: (Attributes) Observability settings for the Worker. (see below for nested schema)
            old_name: (String) The old name of the inherited binding. If set, the binding will be renamed from old_name to name in the new version. If not set, the binding will keep the same name between versions.
            old_tag: (String) Tag used to verify against the latest migration tag for this Worker. If they don't match, the upload is rejected.
            outbound: (Attributes) Outbound worker. (see below for nested schema)
            params: (List of String) Pass information from the Dispatch Worker to the Outbound Worker through the parameters.
            part: (String) The name of the file containing the data content. Only accepted for service worker syntax Workers.
            persist: (Boolean) Whether log persistence is enabled for the Worker.
            pipeline: (String) Name of the Pipeline to bind to.
            placement: (Attributes) Configuration for Smart Placement. Specify either mode for Smart Placement, or one of region/hostname/host for targeted placement. (see below for nested schema)
            queue_name: (String) Name of the Queue to bind to.
            redirects: (String) The contents of a _redirects file (used to apply redirects or proxy paths ahead of asset serving).
            region: (String) Cloud region for targeted placement in format 'provider:region'.
            renamed_classes: (Attributes List) A list of classes with Durable Object namespaces that were renamed. (see below for nested schema)
            run_worker_first: (Dynamic) When a boolean true, requests will always invoke the Worker script. Otherwise, attempt to serve an asset matching the request, falling back to the Worker script. When a list of strings, contains path rules to control routing to either the Worker or assets. Glob (*) and negative (!) rules are supported. Rules must start with either '/' or '!/'. At least one non-negative rule must be provided, and negative rules have higher precedence than non-negative rules.
            script_name: (String) Name of the script, used in URLs and route configuration.
            secret_name: (String) Name of the secret in the store.
            serve_directly: (Boolean, Deprecated) When true and the incoming request matches an asset, that will be served instead of invoking the Worker script. When false, requests will always invoke the Worker script.
            service: (String) Name of Worker to bind to.
            startup_time_ms: (Number)
            status: |-
                (String) Status of Smart Placement.
                Available values: "SUCCESS", "UNSUPPORTED_APPLICATION", "INSUFFICIENT_INVOCATIONS".
            steps: (Attributes List) Migrations to apply in order. (see below for nested schema)
            store_id: (String) ID of the store containing the secret.
            tail_consumers: (Attributes Set) List of Workers that will consume logs from the attached Worker. (see below for nested schema)
            text: (String, Sensitive) The text value to use.
            to: (String)
            transferred_classes: (Attributes List) A list of transfers for Durable Object namespaces from a different Worker and class to a class defined in this Worker. (see below for nested schema)
            type: |-
                (String) The kind of resource that the binding provides.
                Available values: "ai", "analytics_engine", "assets", "browser", "d1", "data_blob", "dispatch_namespace", "durable_object_namespace", "hyperdrive", "inherit", "images", "json", "kv_namespace", "mtls_certificate", "plain_text", "pipelines", "queue", "r2_bucket", "secret_text", "send_email", "service", "tail_consumer", "text_blob", "vectorize", "version_metadata", "secrets_store_secret", "secret_key", "workflow", "wasm_module".
            usage_model: |-
                (String) Usage model for the Worker invocations.
                Available values: "standard", "bundled", "unbound".
            usages: (Set of String) Allowed operations with the key. Learn more.
            version_id: (String) Identifier for the version to inherit the binding from, which can be the version ID or the literal "latest" to inherit from the latest version. Defaults to inheriting the binding from the latest version.
            worker: (Attributes) Outbound worker. (see below for nested schema)
            workflow_name: (String) Name of the Workflow to bind to.
        importStatements:
            - $ terraform import cloudflare_workers_script.example '<account_id>/<script_name>'
    cloudflare_workers_script_subdomain:
        subCategory: ""
        name: cloudflare_workers_script_subdomain
        title: cloudflare_workers_script_subdomain Resource - Cloudflare
        examples:
            - name: example_workers_script_subdomain
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "enabled": true,
                  "previews_enabled": false,
                  "script_name": "this-is_my_script-01"
                }
        argumentDocs:
            account_id: (String) Identifier.
            enabled: (Boolean) Whether the Worker should be available on the workers.dev subdomain.
            id: (String) Identifier for the resource.
            previews_enabled: (Boolean) Whether the Worker's Preview URLs should be available on the workers.dev subdomain.
            script_name: (String) Name of the script, used in URLs and route configuration.
        importStatements:
            - $ terraform import cloudflare_workers_script_subdomain.example '<account_id>/<script_name>'
    cloudflare_workflow:
        subCategory: ""
        name: cloudflare_workflow
        title: cloudflare_workflow Resource - Cloudflare
        examples:
            - name: example_workflow
              manifest: |-
                {
                  "account_id": "account_id",
                  "class_name": "x",
                  "script_name": "x",
                  "workflow_name": "x"
                }
        argumentDocs:
            account_id: (String)
            class_name: (String)
            complete: (Number)
            created_on: (String)
            errored: (Number)
            id: (String) The ID of this resource.
            instances: (Attributes) (see below for nested schema)
            is_deleted: (Number)
            modified_on: (String)
            name: (String)
            paused: (Number)
            queued: (Number)
            running: (Number)
            script_name: (String)
            terminated: (Number)
            terminator_running: (Number)
            triggered_on: (String)
            version_id: (String)
            waiting: (Number)
            waiting_for_pause: (Number)
            workflow_name: (String)
        importStatements:
            - $ terraform import cloudflare_workflow.example '<account_id>/<workflow_name>'
    cloudflare_zero_trust_access_ai_controls_mcp_portal:
        subCategory: ""
        name: cloudflare_zero_trust_access_ai_controls_mcp_portal
        title: cloudflare_zero_trust_access_ai_controls_mcp_portal Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_ai_controls_mcp_portal
              manifest: |-
                {
                  "account_id": "a86a8f5c339544d7bdc89926de14fb8c",
                  "description": "This is my custom MCP Portal",
                  "hostname": "exmaple.com",
                  "id": "my-mcp-portal",
                  "name": "My MCP Portal",
                  "servers": [
                    {
                      "default_disabled": true,
                      "on_behalf": true,
                      "server_id": "my-mcp-server",
                      "updated_prompts": [
                        {
                          "description": "description",
                          "enabled": true,
                          "name": "name"
                        }
                      ],
                      "updated_tools": [
                        {
                          "description": "description",
                          "enabled": true,
                          "name": "name"
                        }
                      ]
                    }
                  ]
                }
        argumentDocs:
            account_id: (String)
            created_at: (String)
            created_by: (String)
            default_disabled: (Boolean)
            description: (String)
            enabled: (Boolean)
            hostname: (String)
            id: (String) portal id
            modified_at: (String)
            modified_by: (String)
            name: (String)
            on_behalf: (Boolean)
            server_id: (String) server id
            servers: (Attributes List) (see below for nested schema)
            updated_prompts: (Attributes List) (see below for nested schema)
            updated_tools: (Attributes List) (see below for nested schema)
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_ai_controls_mcp_portal.example '<account_id>/<id>'
    cloudflare_zero_trust_access_ai_controls_mcp_server:
        subCategory: ""
        name: cloudflare_zero_trust_access_ai_controls_mcp_server
        title: cloudflare_zero_trust_access_ai_controls_mcp_server Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_ai_controls_mcp_server
              manifest: |-
                {
                  "account_id": "a86a8f5c339544d7bdc89926de14fb8c",
                  "auth_credentials": "auth_credentials",
                  "auth_type": "unauthenticated",
                  "description": "This is one remote mcp server",
                  "hostname": "https://exmaple.com/mcp",
                  "id": "my-mcp-server",
                  "name": "My MCP Server"
                }
        argumentDocs:
            account_id: (String)
            auth_credentials: (String)
            auth_type: '(String) Available values: "oauth", "bearer", "unauthenticated".'
            created_at: (String)
            created_by: (String)
            description: (String)
            error: (String)
            hostname: (String)
            id: (String) server id
            last_synced: (String)
            modified_at: (String)
            modified_by: (String)
            name: (String)
            prompts: (List of Map of String)
            status: (String)
            tools: (List of Map of String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_ai_controls_mcp_server.example '<account_id>/<id>'
    cloudflare_zero_trust_access_application:
        subCategory: ""
        name: cloudflare_zero_trust_access_application
        title: cloudflare_zero_trust_access_application Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_application
              manifest: |-
                {
                  "allow_authenticate_via_warp": true,
                  "allow_iframe": true,
                  "allowed_idps": [
                    "699d98642c564d2e855e9661899b7252"
                  ],
                  "app_launcher_visible": true,
                  "auto_redirect_to_identity": true,
                  "cors_headers": {
                    "allow_all_headers": true,
                    "allow_all_methods": true,
                    "allow_all_origins": true,
                    "allow_credentials": true,
                    "allowed_headers": [
                      "string"
                    ],
                    "allowed_methods": [
                      "GET"
                    ],
                    "allowed_origins": [
                      "https://example.com"
                    ],
                    "max_age": -1
                  },
                  "custom_deny_message": "custom_deny_message",
                  "custom_deny_url": "custom_deny_url",
                  "custom_non_identity_deny_url": "custom_non_identity_deny_url",
                  "custom_pages": [
                    "699d98642c564d2e855e9661899b7252"
                  ],
                  "destinations": [
                    {
                      "type": "public",
                      "uri": "test.example.com/admin"
                    },
                    {
                      "type": "public",
                      "uri": "test.anotherexample.com/staff"
                    },
                    {
                      "cidr": "10.5.0.0/24",
                      "hostname": "hostname",
                      "l4_protocol": "tcp",
                      "port_range": "80-90",
                      "type": "private",
                      "vnet_id": "vnet_id"
                    },
                    {
                      "cidr": "10.5.0.3/32",
                      "hostname": "hostname",
                      "l4_protocol": "tcp",
                      "port_range": "80",
                      "type": "private",
                      "vnet_id": "vnet_id"
                    },
                    {
                      "cidr": "cidr",
                      "hostname": "hostname",
                      "l4_protocol": "tcp",
                      "port_range": "port_range",
                      "type": "private",
                      "vnet_id": "vnet_id"
                    }
                  ],
                  "domain": "test.example.com/admin",
                  "enable_binding_cookie": true,
                  "http_only_cookie_attribute": true,
                  "logo_url": "https://www.cloudflare.com/img/logo-web-badges/cf-logo-on-white-bg.svg",
                  "name": "Admin Site",
                  "options_preflight_bypass": true,
                  "path_cookie_attribute": true,
                  "policies": [
                    {
                      "id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                      "precedence": 0
                    }
                  ],
                  "read_service_tokens_from_header": "Authorization",
                  "same_site_cookie_attribute": "strict",
                  "scim_config": {
                    "authentication": {
                      "password": "password",
                      "scheme": "httpbasic",
                      "user": "user"
                    },
                    "deactivate_on_delete": true,
                    "enabled": true,
                    "idp_uid": "idp_uid",
                    "mappings": [
                      {
                        "enabled": true,
                        "filter": "title pr or userType eq \"Intern\"",
                        "operations": {
                          "create": true,
                          "delete": true,
                          "update": true
                        },
                        "schema": "urn:ietf:params:scim:schemas:core:2.0:User",
                        "strictness": "strict",
                        "transform_jsonata": "$merge([$, {'userName': $substringBefore($.userName, '@') \u0026 '+test@' \u0026 $substringAfter($.userName, '@')}])"
                      }
                    ],
                    "remote_uri": "remote_uri"
                  },
                  "self_hosted_domains": [
                    "test.example.com/admin",
                    "test.anotherexample.com/staff"
                  ],
                  "service_auth_401_redirect": true,
                  "session_duration": "24h",
                  "skip_interstitial": true,
                  "tags": [
                    "engineers"
                  ],
                  "type": "self_hosted",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            ac_id: (String) The ACID of an Authentication context.
            access_token_lifetime: (String) The lifetime of the OIDC Access Token after creation. Valid units are m,h. Must be greater than or equal to 1m and less than or equal to 24h.
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            allow_all_headers: (Boolean) Allows all HTTP request headers.
            allow_all_methods: (Boolean) Allows all HTTP request methods.
            allow_all_origins: (Boolean) Allows all origins.
            allow_authenticate_via_warp: (Boolean) When set to true, users can authenticate to this application using their WARP session.  When set to false this application will always require direct IdP authentication. This setting always overrides the organization setting for WARP authentication.
            allow_credentials: (Boolean) When set to true, includes credentials (cookies, authorization headers, or TLS client certificates) with requests.
            allow_email_alias: (Boolean) Enables using Identity Provider email alias as SSH username.
            allow_iframe: (Boolean) Enables loading application content in an iFrame.
            allow_pkce_without_client_secret: (Boolean) If client secret should be required on the token endpoint when authorization_code_with_pkce grant is used.
            allowed_headers: (Set of String) Allowed HTTP request headers.
            allowed_idps: (Set of String) The identity providers your users can select when connecting to this application. Defaults to all IdPs configured in your account.
            allowed_methods: (Set of String) Allowed HTTP request methods.
            allowed_origins: (Set of String) Allowed origins.
            any_valid_service_token: (Attributes) An empty object which matches on all service tokens. (see below for nested schema)
            app_launcher_logo_url: (String) The image URL of the logo shown in the App Launcher header.
            app_launcher_url: (String) The URL where this applications tile redirects users
            app_launcher_visible: (Boolean) Displays the application in the App Launcher.
            app_uid: (String) The ID of an Access OIDC SaaS application
            attribute_name: (String) The name of the SAML attribute.
            attribute_value: (String) The SAML attribute value to look for.
            aud: (String) Audience tag.
            auth_context: (Attributes) (see below for nested schema)
            auth_method: (Attributes) (see below for nested schema)
            auth_type: |-
                (String) Optional identifier indicating the authentication protocol used for the saas app. Required for OIDC. Default if unset is "saml"
                Available values: "saml", "oidc".
            authentication: (Attributes) Attributes for configuring HTTP Basic authentication scheme for SCIM provisioning to an application. (see below for nested schema)
            authorization_url: (String) URL used to generate the auth code used during token generation.
            auto_redirect_to_identity: (Boolean) When set to true, users skip the identity provider selection step during login. You must specify only one identity provider in allowed_idps.
            azure_ad: (Attributes) (see below for nested schema)
            bg_color: (String) The background color of the App Launcher page.
            button_color: (String) The background color of the log in button on the landing page.
            button_text_color: (String) The color of the text in the log in button on the landing page.
            certificate: (Attributes) (see below for nested schema)
            cidr: (String) The CIDR range of the destination. Single IPs will be computed as /32.
            claim_name: (String) The name of the OIDC claim.
            claim_value: (String) The OIDC claim value to look for.
            client_id: (String) The application client id
            client_secret: (String, Sensitive) The application client secret, only returned on POST request.
            common_name: (Attributes) (see below for nested schema)
            connection_rules: (Attributes) The rules that define how users may connect to the targets secured by your application. (see below for nested schema)
            consumer_service_url: (String) The service provider's endpoint that is responsible for receiving and parsing a SAML assertion.
            cors_headers: (Attributes) (see below for nested schema)
            country_code: (String) The country code that should be matched.
            create: (Boolean) Whether or not this mapping applies to create (POST) operations.
            custom_attributes: (Attributes List) (see below for nested schema)
            custom_claims: (Attributes List) (see below for nested schema)
            custom_deny_message: (String) The custom error message shown to a user when they are denied access to the application.
            custom_deny_url: (String) The custom URL a user is redirected to when they are denied access to the application when failing identity-based rules.
            custom_non_identity_deny_url: (String) The custom URL a user is redirected to when they are denied access to the application when failing non-identity rules.
            custom_pages: (List of String) The custom pages that will be displayed when applicable for this application
            deactivate_on_delete: '(Boolean) If false, propagates DELETE requests to the target application for SCIM resources. If true, sets ''active'' to false on the SCIM resource. Note: Some targets do not support DELETE operations.'
            decision: |-
                (String) The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
                Available values: "allow", "deny", "non_identity", "bypass".
            default_relay_state: (String) The URL that the user will be redirected to after a successful login for IDP initiated logins.
            delete: (Boolean) Whether or not this mapping applies to DELETE operations.
            destinations: (Attributes List) List of destinations secured by Access. This supersedes self_hosted_domains to allow for more flexibility in defining different types of domains. If destinations are provided, then self_hosted_domains will be ignored. (see below for nested schema)
            device_posture: (Attributes) (see below for nested schema)
            domain: (String) The primary hostname and path secured by Access. This domain will be displayed if the app is visible in the App Launcher.
            email: (Attributes) (see below for nested schema)
            email_domain: (Attributes) (see below for nested schema)
            email_list: (Attributes) (see below for nested schema)
            enable_binding_cookie: (Boolean) Enables the binding cookie, which increases security against compromised authorization tokens and CSRF attacks.
            enabled: (Boolean) Whether SCIM provisioning is turned on for this application.
            evaluate_url: (String) The API endpoint containing your business logic.
            everyone: (Attributes) An empty object which matches on all users. (see below for nested schema)
            exclude: (Attributes Set) Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. (see below for nested schema)
            external_evaluation: (Attributes) (see below for nested schema)
            filter: (String) A SCIM filter expression that matches resources that should be provisioned to this application.
            footer_links: (Attributes List) The links in the App Launcher footer. (see below for nested schema)
            friendly_name: (String) The SAML FriendlyName of the attribute.
            geo: (Attributes) (see below for nested schema)
            github_organization: (Attributes) (see below for nested schema)
            grant_types: (List of String) The OIDC flows supported by this application
            group: (Attributes) (see below for nested schema)
            group_filter_regex: (String) A regex to filter Cloudflare groups returned in ID token and userinfo endpoint
            gsuite: (Attributes) (see below for nested schema)
            header_bg_color: (String) The background color of the App Launcher header.
            hostname: (String) The hostname of the destination. Matches a valid SNI served by an HTTPS origin.
            http_only_cookie_attribute: (Boolean) Enables the HttpOnly cookie attribute, which increases security against XSS attacks.
            hybrid_and_implicit_options: (Attributes) (see below for nested schema)
            id: (String) UUID.
            identity_provider_id: (String) The ID of your Azure identity provider.
            idp_entity_id: (String) The unique identifier for your SaaS application.
            idp_id: (String) The UID of the IdP.
            idp_uid: (String) The UID of the IdP to use as the source for SCIM resources to provision to this application.
            image_url: (String) The URL of the image shown on the landing page.
            include: (Attributes Set) Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. (see below for nested schema)
            integration_uid: (String) The ID of a device posture integration.
            ip: (Attributes) (see below for nested schema)
            ip_list: (Attributes) (see below for nested schema)
            keys_url: (String) The API endpoint containing the key that Access uses to verify that the response came from your API.
            l4_protocol: |-
                (String) The L4 protocol of the destination. When omitted, both UDP and TCP traffic will match.
                Available values: "tcp", "udp".
            landing_page_design: (Attributes) The design of the App Launcher landing page shown to users when they log in. (see below for nested schema)
            lifetime: (String) How long a refresh token will be valid for after creation. Valid units are m,h,d. Must be longer than 1m.
            linked_app_token: (Attributes) (see below for nested schema)
            login_method: (Attributes) (see below for nested schema)
            logo_url: (String) The image URL for the logo shown in the App Launcher dashboard.
            mappings: (Attributes List) A list of mappings to apply to SCIM resources before provisioning them in this application. These can transform or filter the resources to be provisioned. (see below for nested schema)
            max_age: (Number) The maximum number of seconds the results of a preflight request can be cached.
            mcp_server_id: (String) A MCP server id configured in ai-controls. Access will secure the MCP server if accessed through a MCP portal.
            message: (String) The message shown on the landing page.
            name: (String) The name of the application.
            name_by_idp: (Attributes List) A mapping from IdP ID to attribute name. (see below for nested schema)
            name_format: |-
                (String) A globally unique name for an identity or service provider.
                Available values: "urn:oasis:names:tc:SAML:2.0:attrname-format:unspecified", "urn:oasis:names:tc:SAML:2.0:attrname-format:basic", "urn:oasis:names:tc:SAML:2.0:attrname-format:uri".
            name_id_format: |-
                (String) The format of the name identifier sent to the SaaS application.
                Available values: "id", "email".
            name_id_transform_jsonata: (String) A JSONata expression that transforms an application's user identities into a NameID value for its SAML assertion. This expression should evaluate to a singular string. The output of this expression can override the name_id_format setting.
            oidc: (Attributes) (see below for nested schema)
            okta: (Attributes) (see below for nested schema)
            operations: (Attributes) Whether or not this mapping applies to creates, updates, or deletes. (see below for nested schema)
            options_preflight_bypass: (Boolean) Allows options preflight requests to bypass Access authentication and go directly to the origin. Cannot turn on if cors_headers is set.
            password: (String, Sensitive) Password used to authenticate with the remote SCIM service.
            path_cookie_attribute: (Boolean) Enables cookie paths to scope an application's JWT to the application path. If disabled, the JWT will scope to the hostname by default
            policies: (Attributes List) The policies that Access applies to the application, in ascending order of precedence. Items can reference existing policies or create new policies exclusive to the application. (see below for nested schema)
            port: (Number) The port that the targets use for the chosen communication protocol. A port cannot be assigned to multiple protocols.
            port_range: (String) The port range of the destination. Can be a single port or a range of ports. When omitted, all ports will match.
            precedence: (Number) The order of execution for this policy. Must be unique for each policy within an app.
            protocol: |-
                (String) The communication protocol your application secures.
                Available values: "SSH", "RDP".
            public_key: (String) The Access public certificate that will be used to verify your identity.
            read_service_tokens_from_header: |-
                (String) Allows matching Access Service Tokens passed HTTP in a single header with this name.
                This works as an alternative to the (CF-Access-Client-Id, CF-Access-Client-Secret) pair of headers.
                The header value will be interpreted as a json object similar to:
                {
                "cf-access-client-id": "88bf3b6d86161464f6509f7219099e57.access.example.com",
                "cf-access-client-secret": "bdd31cbc4dec990953e39163fbbb194c93313ca9f0a6e420346af9d326b1d2a5"
                }
            redirect_uris: (List of String) The permitted URL's for Cloudflare to return Authorization codes and Access/ID tokens
            refresh_token_options: (Attributes) (see below for nested schema)
            remote_uri: (String) The base URI for the application's SCIM-compatible API.
            require: (Attributes Set) Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. (see below for nested schema)
            required: (Boolean) If the attribute is required when building a SAML assertion.
            return_access_token_from_authorization_endpoint: (Boolean) If an Access Token should be returned from the OIDC Authorization endpoint
            return_id_token_from_authorization_endpoint: (Boolean) If an ID Token should be returned from the OIDC Authorization endpoint
            saas_app: (Attributes) (see below for nested schema)
            same_site_cookie_attribute: (String) Sets the SameSite cookie setting, which provides increased security against CSRF attacks.
            saml: (Attributes) (see below for nested schema)
            saml_attribute_transform_jsonata: (String) A [JSONata] (https://jsonata.org/) expression that transforms an application's user identities into attribute assertions in the SAML response. The expression can transform id, email, name, and groups values. It can also transform fields listed in the saml_attributes or oidc_fields of the identity provider used to authenticate. The output of this expression must be a JSON object.
            schema: (String) Which SCIM resource type this mapping applies to.
            scheme: |-
                (String) The authentication scheme to use when making SCIM requests to this application.
                Available values: "httpbasic", "oauthbearertoken", "oauth2", "access_service_token".
            scim_config: (Attributes) Configuration for provisioning to this application via SCIM. This is currently in closed beta. (see below for nested schema)
            scope: |-
                (String) The scope of the claim.
                Available values: "groups", "profile", "email", "openid".
            scopes: (List of String) Define the user information shared with access, "offline_access" scope will be automatically enabled if refresh tokens are enabled
            self_hosted_domains: (List of String, Deprecated) List of public domains that Access will secure. This field is deprecated in favor of destinations and will be supported until November 21, 2025. If destinations are provided, then self_hosted_domains will be ignored.
            service_auth_401_redirect: (Boolean) Returns a 401 status code when the request is blocked by a Service Auth policy.
            service_token: (Attributes) (see below for nested schema)
            session_duration: '(String) The amount of time that tokens issued for this application will be valid. Must be in the format 300ms or 2h45m. Valid time units are: ns, us (or s), ms, s, m, h. Note: unsupported for infrastructure type applications.'
            skip_app_launcher_login_page: (Boolean) Determines when to skip the App Launcher landing page.
            skip_interstitial: (Boolean) Enables automatic authentication through cloudflared.
            source: (Attributes) (see below for nested schema)
            source_name: (String) The name of the IdP provided attribute.
            sp_entity_id: (String) A globally unique name for an identity or service provider.
            ssh: (Attributes) The SSH-specific rules that define how users may connect to the targets secured by your application. (see below for nested schema)
            sso_endpoint: (String) The endpoint where your SaaS application will send login requests.
            strictness: |-
                (String) The level of adherence to outbound resource schemas when provisioning to this mapping. Strict removes unknown values, while passthrough passes unknown values to the target.
                Available values: "strict", "passthrough".
            tags: (Set of String) The tags you want assigned to an application. Tags are used to filter applications in the App Launcher dashboard.
            target_attributes: (Map of List of String) Contains a map of target attribute keys to target attribute values.
            target_criteria: (Attributes List) (see below for nested schema)
            team: (String) The name of the team
            title: (String) The title shown on the landing page.
            token: (String, Sensitive) Token used to authenticate with the remote SCIM service.
            token_id: (String) The ID of a Service Token.
            token_url: (String) URL used to generate the token used to authenticate with the remote SCIM service.
            transform_jsonata: (String) A JSONata expression that transforms the resource before provisioning it in the application.
            type: |-
                (String) The application type.
                Available values: "self_hosted", "saas", "ssh", "vnc", "app_launcher", "warp", "biso", "bookmark", "dash_sso", "infrastructure", "rdp", "mcp", "mcp_portal", "proxy_endpoint".
            update: (Boolean) Whether or not this mapping applies to update (PATCH/PUT) operations.
            uri: (String) The URI of the destination. Public destinations' URIs can include a domain and path with wildcards.
            url: (String) the hyperlink in the footer link.
            user: (String) User name used to authenticate with the remote SCIM service.
            usernames: (List of String) Contains the Unix usernames that may be used when connecting over SSH.
            vnet_id: (String) The VNET ID to match the destination. When omitted, all VNETs will match.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_application.example '<{accounts|zones}/{account_id|zone_id}>/<app_id>'
    cloudflare_zero_trust_access_custom_page:
        subCategory: ""
        name: cloudflare_zero_trust_access_custom_page
        title: cloudflare_zero_trust_access_custom_page Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_custom_page
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "custom_html": "\u003chtml\u003e\u003cbody\u003e\u003ch1\u003eAccess Denied\u003c/h1\u003e\u003c/body\u003e\u003c/html\u003e",
                  "name": "name",
                  "type": "identity_denied"
                }
        argumentDocs:
            account_id: (String) Identifier.
            custom_html: (String) Custom page HTML.
            id: (String) UUID.
            name: (String) Custom page name.
            type: |-
                (String) Custom page type.
                Available values: "identity_denied", "forbidden".
            uid: (String) UUID.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_custom_page.example '<account_id>/<custom_page_id>'
    cloudflare_zero_trust_access_group:
        subCategory: ""
        name: cloudflare_zero_trust_access_group
        title: cloudflare_zero_trust_access_group Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_group
              manifest: |-
                {
                  "exclude": [
                    {
                      "group": {
                        "id": "aa0a4aab-672b-4bdb-bc33-a59f1130a11f"
                      }
                    }
                  ],
                  "include": [
                    {
                      "group": {
                        "id": "aa0a4aab-672b-4bdb-bc33-a59f1130a11f"
                      }
                    }
                  ],
                  "is_default": true,
                  "name": "Allow devs",
                  "require": [
                    {
                      "group": {
                        "id": "aa0a4aab-672b-4bdb-bc33-a59f1130a11f"
                      }
                    }
                  ],
                  "zone_id": "zone_id"
                }
        argumentDocs:
            ac_id: (String) The ACID of an Authentication context.
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            any_valid_service_token: (Attributes) An empty object which matches on all service tokens. (see below for nested schema)
            app_uid: (String) The ID of an Access OIDC SaaS application
            attribute_name: (String) The name of the SAML attribute.
            attribute_value: (String) The SAML attribute value to look for.
            auth_context: (Attributes) (see below for nested schema)
            auth_method: (Attributes) (see below for nested schema)
            azure_ad: (Attributes) (see below for nested schema)
            certificate: (Attributes) (see below for nested schema)
            claim_name: (String) The name of the OIDC claim.
            claim_value: (String) The OIDC claim value to look for.
            common_name: (Attributes) (see below for nested schema)
            country_code: (String) The country code that should be matched.
            device_posture: (Attributes) (see below for nested schema)
            domain: (String) The email domain to match.
            email: (Attributes) (see below for nested schema)
            email_domain: (Attributes) (see below for nested schema)
            email_list: (Attributes) (see below for nested schema)
            evaluate_url: (String) The API endpoint containing your business logic.
            everyone: (Attributes) An empty object which matches on all users. (see below for nested schema)
            exclude: (Attributes List) Rules evaluated with a NOT logical operator. To match a policy, a user cannot meet any of the Exclude rules. (see below for nested schema)
            external_evaluation: (Attributes) (see below for nested schema)
            geo: (Attributes) (see below for nested schema)
            github_organization: (Attributes) (see below for nested schema)
            group: (Attributes) (see below for nested schema)
            gsuite: (Attributes) (see below for nested schema)
            id: (String) UUID.
            identity_provider_id: (String) The ID of your Azure identity provider.
            include: (Attributes List) Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. (see below for nested schema)
            integration_uid: (String) The ID of a device posture integration.
            ip: (Attributes) (see below for nested schema)
            ip_list: (Attributes) (see below for nested schema)
            is_default: (Boolean) Whether this is the default group
            keys_url: (String) The API endpoint containing the key that Access uses to verify that the response came from your API.
            linked_app_token: (Attributes) (see below for nested schema)
            login_method: (Attributes) (see below for nested schema)
            name: (String) The name of the Access group.
            oidc: (Attributes) (see below for nested schema)
            okta: (Attributes) (see below for nested schema)
            require: (Attributes List) Rules evaluated with an AND logical operator. To match a policy, a user must meet all of the Require rules. (see below for nested schema)
            saml: (Attributes) (see below for nested schema)
            service_token: (Attributes) (see below for nested schema)
            team: (String) The name of the team
            token_id: (String) The ID of a Service Token.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_group.example '<{accounts|zones}/{account_id|zone_id}>/<group_id>'
    cloudflare_zero_trust_access_identity_provider:
        subCategory: ""
        name: cloudflare_zero_trust_access_identity_provider
        title: cloudflare_zero_trust_access_identity_provider Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_identity_provider
              manifest: |-
                {
                  "config": {
                    "claims": [
                      "email_verified",
                      "preferred_username",
                      "custom_claim_name"
                    ],
                    "client_id": "\u003cyour client id\u003e",
                    "client_secret": "\u003cyour client secret\u003e",
                    "conditional_access_enabled": true,
                    "directory_id": "\u003cyour azure directory uuid\u003e",
                    "email_claim_name": "custom_claim_name",
                    "prompt": "login",
                    "support_groups": true
                  },
                  "name": "Widget Corps IDP",
                  "scim_config": {
                    "enabled": true,
                    "identity_update_behavior": "automatic",
                    "seat_deprovision": true,
                    "user_deprovision": true
                  },
                  "type": "onetimepin",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            apps_domain: (String) Your companies TLD
            attribute_name: (String) attribute name from the IDP
            attributes: (List of String) A list of SAML attribute names that will be added to your signed JWT token and can be used in SAML policy rules.
            auth_url: (String) The authorization_endpoint URL of your IdP
            authorization_server_id: (String) Your okta authorization server id
            centrify_account: (String) Your centrify account url
            centrify_app_id: (String) Your centrify app id
            certs_url: (String) The jwks_uri endpoint of your IdP to allow the IdP keys to sign the tokens
            claims: (List of String) Custom claims
            client_id: (String) Your OAuth Client ID
            client_secret: (String, Sensitive) Your OAuth Client Secret
            conditional_access_enabled: (Boolean) Should Cloudflare try to load authentication contexts from your account
            config: (Attributes) The configuration parameters for the identity provider. To view the required parameters for a specific provider, refer to our developer documentation. (see below for nested schema)
            directory_id: (String) Your Azure directory uuid
            email_attribute_name: (String) The attribute name for email in the SAML response.
            email_claim_name: (String) The claim name for email in the id_token response.
            enabled: (Boolean) A flag to enable or disable SCIM for the identity provider.
            header_attributes: (Attributes List) Add a list of attribute names that will be returned in the response header from the Access callback. (see below for nested schema)
            header_name: (String) header that will be added on the request to the origin
            id: (String) UUID.
            identity_update_behavior: |-
                (String) Indicates how a SCIM event updates a user identity used for policy evaluation. Use "automatic" to automatically update a user's identity and augment it with fields from the SCIM user resource. Use "reauth" to force re-authentication on group membership updates, user identity update will only occur after successful re-authentication. With "reauth" identities will not contain fields from the SCIM user resource. With "no_action" identities will not be changed by SCIM updates in any way and users will not be prompted to reauthenticate.
                Available values: "automatic", "reauth", "no_action".
            idp_public_certs: (List of String) X509 certificate to verify the signature in the SAML authentication response
            issuer_url: (String) IdP Entity ID or Issuer URL
            name: (String) The name of the identity provider, shown to users on the login page.
            okta_account: (String) Your okta account url
            onelogin_account: (String) Your OneLogin account url
            ping_env_id: (String) Your PingOne environment identifier
            pkce_enabled: (Boolean) Enable Proof Key for Code Exchange (PKCE)
            prompt: |-
                (String) Indicates the type of user interaction that is required. prompt=login forces the user to enter their credentials on that request, negating single-sign on. prompt=none is the opposite. It ensures that the user isn't presented with any interactive prompt. If the request can't be completed silently by using single-sign on, the Microsoft identity platform returns an interaction_required error. prompt=select_account interrupts single sign-on providing account selection experience listing all the accounts either in session or any remembered account or an option to choose to use a different account altogether.
                Available values: "login", "select_account", "none".
            redirect_url: (String)
            scim_base_url: (String) The base URL of Cloudflare's SCIM V2.0 API endpoint.
            scim_config: (Attributes) The configuration settings for enabling a System for Cross-Domain Identity Management (SCIM) with the identity provider. (see below for nested schema)
            scopes: (List of String) OAuth scopes
            seat_deprovision: (Boolean) A flag to remove a user's seat in Zero Trust when they have been deprovisioned in the Identity Provider.  This cannot be enabled unless user_deprovision is also enabled.
            secret: (String, Sensitive) A read-only token generated when the SCIM integration is enabled for the first time.  It is redacted on subsequent requests.  If you lose this you will need to refresh it at /access/identity_providers/:idpID/refresh_scim_secret.
            sign_request: (Boolean) Sign the SAML authentication request with Access credentials. To verify the signature, use the public key from the Access certs endpoints.
            sso_target_url: (String) URL to send the SAML authentication requests to
            support_groups: (Boolean) Should Cloudflare try to load groups from your account
            token_url: (String) The token_endpoint URL of your IdP
            type: |-
                (String) The type of identity provider. To determine the value for a specific provider, refer to our developer documentation.
                Available values: "onetimepin", "azureAD", "saml", "centrify", "facebook", "github", "google-apps", "google", "linkedin", "oidc", "okta", "onelogin", "pingone", "yandex".
            user_deprovision: (Boolean) A flag to enable revoking a user's session in Access and Gateway when they have been deprovisioned in the Identity Provider.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_identity_provider.example '<{accounts|zones}/{account_id|zone_id}>/<identity_provider_id>'
    cloudflare_zero_trust_access_infrastructure_target:
        subCategory: ""
        name: cloudflare_zero_trust_access_infrastructure_target
        title: cloudflare_zero_trust_access_infrastructure_target Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_infrastructure_target
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "hostname": "infra-access-target",
                  "ip": {
                    "ipv4": {
                      "ip_addr": "187.26.29.249",
                      "virtual_network_id": "c77b744e-acc8-428f-9257-6878c046ed55"
                    },
                    "ipv6": {
                      "ip_addr": "64c0:64e8:f0b4:8dbf:7104:72b0:ec8f:f5e0",
                      "virtual_network_id": "c77b744e-acc8-428f-9257-6878c046ed55"
                    }
                  }
                }
        argumentDocs:
            account_id: (String) Account identifier
            created_at: (String) Date and time at which the target was created
            hostname: |-
                (String) A non-unique field that refers to a target. Case insensitive, maximum
                length of 255 characters, supports the use of special characters dash
                and period, does not support spaces, and must start and end with an
                alphanumeric character.
            id: (String) Target identifier
            ip: (Attributes) The IPv4/IPv6 address that identifies where to reach a target (see below for nested schema)
            ip_addr: (String) IP address of the target
            ipv4: (Attributes) The target's IPv4 address (see below for nested schema)
            ipv6: (Attributes) The target's IPv6 address (see below for nested schema)
            modified_at: (String) Date and time at which the target was modified
            virtual_network_id: (String) (optional) Private virtual network identifier for the target. If omitted, the default virtual network ID will be used.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_infrastructure_target.example '<account_id>/<target_id>'
    cloudflare_zero_trust_access_key_configuration:
        subCategory: ""
        name: cloudflare_zero_trust_access_key_configuration
        title: cloudflare_zero_trust_access_key_configuration Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_key_configuration
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "key_rotation_interval_days": 30
                }
        argumentDocs:
            account_id: (String) Identifier.
            days_until_next_rotation: (Number) The number of days until the next key rotation.
            id: (String) Identifier.
            key_rotation_interval_days: (Number) The number of days between key rotations.
            last_key_rotation_at: (String) The timestamp of the previous key rotation.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_key_configuration.example '<account_id>'
    cloudflare_zero_trust_access_mtls_certificate:
        subCategory: ""
        name: cloudflare_zero_trust_access_mtls_certificate
        title: cloudflare_zero_trust_access_mtls_certificate Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_mtls_certificate
              manifest: |-
                {
                  "associated_hostnames": [
                    "admin.example.com"
                  ],
                  "certificate": "  -----BEGIN CERTIFICATE-----\n  MIIGAjCCA+qgAwIBAgIJAI7kymlF7CWT...N4RI7KKB7nikiuUf8vhULKy5IX10\n  DrUtmu/B\n  -----END CERTIFICATE-----\n",
                  "name": "Allow devs",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            associated_hostnames: (Set of String) The hostnames of the applications that will use this certificate.
            certificate: (String) The certificate content.
            expires_on: (String)
            fingerprint: (String) The MD5 fingerprint of the certificate.
            id: (String) The ID of the application that will use this certificate.
            name: (String) The name of the certificate.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_mtls_certificate.example '<{accounts|zones}/{account_id|zone_id}>/<certificate_id>'
    cloudflare_zero_trust_access_mtls_hostname_settings:
        subCategory: ""
        name: cloudflare_zero_trust_access_mtls_hostname_settings
        title: cloudflare_zero_trust_access_mtls_hostname_settings Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_mtls_hostname_settings
              manifest: |-
                {
                  "settings": [
                    {
                      "china_network": false,
                      "client_certificate_forwarding": true,
                      "hostname": "admin.example.com"
                    }
                  ],
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            china_network: (Boolean) Request client certificates for this hostname in China. Can only be set to true if this zone is china network enabled.
            client_certificate_forwarding: (Boolean) Client Certificate Forwarding is a feature that takes the client cert provided by the eyeball to the edge, and forwards it to the origin as a HTTP header to allow logging on the origin.
            hostname: (String) The hostname that these settings apply to.
            settings: (Attributes List) (see below for nested schema)
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements: []
    cloudflare_zero_trust_access_policy:
        subCategory: ""
        name: cloudflare_zero_trust_access_policy
        title: cloudflare_zero_trust_access_policy Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_policy
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "approval_groups": [
                    {
                      "approvals_needed": 1,
                      "email_addresses": [
                        "test1@cloudflare.com",
                        "test2@cloudflare.com"
                      ],
                      "email_list_uuid": "email_list_uuid"
                    },
                    {
                      "approvals_needed": 3,
                      "email_addresses": [
                        "test@cloudflare.com",
                        "test2@cloudflare.com"
                      ],
                      "email_list_uuid": "597147a1-976b-4ef2-9af0-81d5d007fc34"
                    }
                  ],
                  "approval_required": true,
                  "decision": "allow",
                  "exclude": [
                    {
                      "group": {
                        "id": "aa0a4aab-672b-4bdb-bc33-a59f1130a11f"
                      }
                    }
                  ],
                  "include": [
                    {
                      "group": {
                        "id": "aa0a4aab-672b-4bdb-bc33-a59f1130a11f"
                      }
                    }
                  ],
                  "isolation_required": false,
                  "name": "Allow devs",
                  "purpose_justification_prompt": "Please enter a justification for entering this protected domain.",
                  "purpose_justification_required": true,
                  "require": [
                    {
                      "group": {
                        "id": "aa0a4aab-672b-4bdb-bc33-a59f1130a11f"
                      }
                    }
                  ],
                  "session_duration": "24h"
                }
        argumentDocs:
            ac_id: (String) The ACID of an Authentication context.
            account_id: (String) Identifier.
            any_valid_service_token: (Attributes) An empty object which matches on all service tokens. (see below for nested schema)
            app_uid: (String) The ID of an Access OIDC SaaS application
            approval_groups: (Attributes Set) Administrators who can approve a temporary authentication request. (see below for nested schema)
            approval_required: (Boolean) Requires the user to request access from an administrator at the start of each session.
            approvals_needed: (Number) The number of approvals needed to obtain access.
            attribute_name: (String) The name of the SAML attribute.
            attribute_value: (String) The SAML attribute value to look for.
            auth_context: (Attributes) (see below for nested schema)
            auth_method: (Attributes) (see below for nested schema)
            azure_ad: (Attributes) (see below for nested schema)
            certificate: (Attributes) (see below for nested schema)
            claim_name: (String) The name of the OIDC claim.
            claim_value: (String) The OIDC claim value to look for.
            common_name: (Attributes) (see below for nested schema)
            country_code: (String) The country code that should be matched.
            decision: |-
                (String) The action Access will take if a user matches this policy. Infrastructure application policies can only use the Allow action.
                Available values: "allow", "deny", "non_identity", "bypass".
            device_posture: (Attributes) (see below for nested schema)
            domain: (String) The email domain to match.
            email: (Attributes) (see below for nested schema)
            email_addresses: (List of String) A list of emails that can approve the access request.
            email_domain: (Attributes) (see below for nested schema)
            email_list: (Attributes) (see below for nested schema)
            email_list_uuid: (String) The UUID of an re-usable email list.
            evaluate_url: (String) The API endpoint containing your business logic.
            everyone: (Attributes) An empty object which matches on all users. (see below for nested schema)
            exclude: (Attributes Set) Rules evaluated with a NOT logical operator. To match the policy, a user cannot meet any of the Exclude rules. (see below for nested schema)
            external_evaluation: (Attributes) (see below for nested schema)
            geo: (Attributes) (see below for nested schema)
            github_organization: (Attributes) (see below for nested schema)
            group: (Attributes) (see below for nested schema)
            gsuite: (Attributes) (see below for nested schema)
            id: (String) The UUID of the policy
            identity_provider_id: (String) The ID of your Azure identity provider.
            include: (Attributes Set) Rules evaluated with an OR logical operator. A user needs to meet only one of the Include rules. (see below for nested schema)
            integration_uid: (String) The ID of a device posture integration.
            ip: (Attributes) (see below for nested schema)
            ip_list: (Attributes) (see below for nested schema)
            isolation_required: (Boolean) Require this application to be served in an isolated browser for users matching this policy. 'Client Web Isolation' must be on for the account in order to use this feature.
            keys_url: (String) The API endpoint containing the key that Access uses to verify that the response came from your API.
            linked_app_token: (Attributes) (see below for nested schema)
            login_method: (Attributes) (see below for nested schema)
            name: (String) The name of the Access policy.
            oidc: (Attributes) (see below for nested schema)
            okta: (Attributes) (see below for nested schema)
            purpose_justification_prompt: (String) A custom message that will appear on the purpose justification screen.
            purpose_justification_required: (Boolean) Require users to enter a justification when they log in to the application.
            require: (Attributes Set) Rules evaluated with an AND logical operator. To match the policy, a user must meet all of the Require rules. (see below for nested schema)
            saml: (Attributes) (see below for nested schema)
            service_token: (Attributes) (see below for nested schema)
            session_duration: '(String) The amount of time that tokens issued for the application will be valid. Must be in the format 300ms or 2h45m. Valid time units are: ns, us (or s), ms, s, m, h.'
            team: (String) The name of the team
            token_id: (String) The ID of a Service Token.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_policy.example '<account_id>/<policy_id>'
    cloudflare_zero_trust_access_service_token:
        subCategory: ""
        name: cloudflare_zero_trust_access_service_token
        title: cloudflare_zero_trust_access_service_token Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_service_token
              manifest: |-
                {
                  "client_secret_version": 0,
                  "duration": "60m",
                  "name": "CI/CD token",
                  "previous_client_secret_expires_at": "2014-01-01T05:20:00.12345Z",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            client_id: (String) The Client ID for the service token. Access will check for this value in the CF-Access-Client-ID request header.
            client_secret: (String, Sensitive) The Client Secret for the service token. Access will check for this value in the CF-Access-Client-Secret request header.
            client_secret_version: (Number) A version number identifying the current client_secret associated with the service token. Incrementing it triggers a rotation; the previous secret will still be accepted until the time indicated by previous_client_secret_expires_at.
            duration: '(String) The duration for how long the service token will be valid. Must be in the format 300ms or 2h45m. Valid time units are: ns, us (or s), ms, s, m, h. The default is 1 year in hours (8760h).'
            expires_at: (String)
            id: (String) The ID of the service token.
            name: (String) The name of the service token.
            previous_client_secret_expires_at: (String) The expiration of the previous client_secret. This can be modified at any point after a rotation. For example, you may extend it further into the future if you need more time to update services with the new secret; or move it into the past to immediately invalidate the previous token in case of compromise.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_service_token.example '<{accounts|zones}/{account_id|zone_id}>/<service_token_id>'
    cloudflare_zero_trust_access_short_lived_certificate:
        subCategory: ""
        name: cloudflare_zero_trust_access_short_lived_certificate
        title: cloudflare_zero_trust_access_short_lived_certificate Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_short_lived_certificate
              manifest: |-
                {
                  "app_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            app_id: (String) UUID.
            aud: (String) The Application Audience (AUD) tag. Identifies the application associated with the CA.
            id: (String) UUID.
            public_key: (String) The public key to add to your SSH server configuration.
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_short_lived_certificate.example '<{accounts|zones}/{account_id|zone_id}>/<app_id>'
    cloudflare_zero_trust_access_tag:
        subCategory: ""
        name: cloudflare_zero_trust_access_tag
        title: cloudflare_zero_trust_access_tag Resource - Cloudflare
        examples:
            - name: example_zero_trust_access_tag
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "name": "engineers"
                }
        argumentDocs:
            account_id: (String) Identifier.
            id: (String) The name of the tag
            name: (String) The name of the tag
        importStatements:
            - $ terraform import cloudflare_zero_trust_access_tag.example '<account_id>/<tag_name>'
    cloudflare_zero_trust_device_custom_profile:
        subCategory: ""
        name: cloudflare_zero_trust_device_custom_profile
        title: cloudflare_zero_trust_device_custom_profile Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_custom_profile
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "allow_mode_switch": true,
                  "allow_updates": true,
                  "allowed_to_leave": true,
                  "auto_connect": 0,
                  "captive_portal": 180,
                  "description": "Policy for test teams.",
                  "disable_auto_fallback": true,
                  "enabled": true,
                  "exclude": [
                    {
                      "address": "192.0.2.0/24",
                      "description": "Exclude testing domains from the tunnel"
                    }
                  ],
                  "exclude_office_ips": true,
                  "include": [
                    {
                      "address": "192.0.2.0/24",
                      "description": "Include testing domains in the tunnel"
                    }
                  ],
                  "lan_allow_minutes": 30,
                  "lan_allow_subnet_size": 24,
                  "match": "identity.email == \"test@cloudflare.com\"",
                  "name": "Allow Developers",
                  "precedence": 100,
                  "register_interface_ip_with_dns": true,
                  "sccm_vpn_boundary_support": false,
                  "service_mode_v2": {
                    "mode": "proxy",
                    "port": 3000
                  },
                  "support_url": "https://1.1.1.1/help",
                  "switch_locked": true,
                  "tunnel_protocol": "wireguard"
                }
        argumentDocs:
            account_id: (String)
            address: (String) The address in CIDR format to exclude from the tunnel. If address is present, host must not be present.
            allow_mode_switch: (Boolean) Whether to allow the user to switch WARP between modes.
            allow_updates: (Boolean) Whether to receive update notifications when a new version of the client is available.
            allowed_to_leave: (Boolean) Whether to allow devices to leave the organization.
            auto_connect: (Number) The amount of time in seconds to reconnect after having been disabled.
            captive_portal: (Number) Turn on the captive portal after the specified amount of time.
            default: (Boolean) Whether the policy is the default policy for an account.
            description: (String) A description of the policy.
            disable_auto_fallback: (Boolean) If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to true.
            dns_server: (List of String) A list of IP addresses to handle domain resolution.
            enabled: (Boolean) Whether the policy will be applied to matching devices.
            exclude: (Attributes List) List of routes excluded in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. (see below for nested schema)
            exclude_office_ips: (Boolean) Whether to add Microsoft IPs to Split Tunnel exclusions.
            fallback_domains: (Attributes List) (see below for nested schema)
            gateway_unique_id: (String)
            host: (String) The domain name to exclude from the tunnel. If host is present, address must not be present.
            id: (String) The ID of this resource.
            include: (Attributes List) List of routes included in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. (see below for nested schema)
            lan_allow_minutes: (Number) The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
            lan_allow_subnet_size: (Number) The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
            match: '(String) The wirefilter expression to match devices. Available values: "identity.email", "identity.groups.id", "identity.groups.name", "identity.groups.email", "identity.service_token_uuid", "identity.saml_attributes", "network", "os.name", "os.version".'
            mode: (String) The mode to run the WARP client under.
            name: (String) The name of the device settings profile.
            policy_id: (String)
            port: (Number) The port number when used with proxy mode.
            precedence: (Number) The precedence of the policy. Lower values indicate higher precedence. Policies will be evaluated in ascending order of this field.
            register_interface_ip_with_dns: (Boolean) Determines if the operating system will register WARP's local interface IP with your on-premises DNS server.
            sccm_vpn_boundary_support: (Boolean) Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only).
            service_mode_v2: (Attributes) (see below for nested schema)
            suffix: (String) The domain suffix to match when resolving locally.
            support_url: (String) The URL to launch when the Send Feedback button is clicked.
            switch_locked: (Boolean) Whether to allow the user to turn off the WARP switch and disconnect the client.
            target_tests: (Attributes List) (see below for nested schema)
            tunnel_protocol: (String) Determines which tunnel protocol to use.
        importStatements:
            - $ terraform import cloudflare_zero_trust_device_custom_profile.example '<account_id>/<policy_id>'
    cloudflare_zero_trust_device_custom_profile_local_domain_fallback:
        subCategory: ""
        name: cloudflare_zero_trust_device_custom_profile_local_domain_fallback
        title: cloudflare_zero_trust_device_custom_profile_local_domain_fallback Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_custom_profile_local_domain_fallback
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "domains": [
                    {
                      "description": "Domain bypass for local development",
                      "dns_server": [
                        "1.1.1.1"
                      ],
                      "suffix": "example.com"
                    }
                  ],
                  "policy_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415"
                }
        argumentDocs:
            account_id: (String)
            description: (String) A description of the fallback domain, displayed in the client UI.
            dns_server: (List of String) A list of IP addresses to handle domain resolution.
            domains: (Attributes Set) (see below for nested schema)
            id: (String) The ID of this resource.
            policy_id: (String)
            suffix: (String) The domain suffix to match when resolving locally.
        importStatements:
            - $ terraform import cloudflare_zero_trust_device_custom_profile_local_domain_fallback.example '<account_id>/<policy_id>'
    cloudflare_zero_trust_device_default_profile:
        subCategory: ""
        name: cloudflare_zero_trust_device_default_profile
        title: cloudflare_zero_trust_device_default_profile Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_default_profile
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "allow_mode_switch": true,
                  "allow_updates": true,
                  "allowed_to_leave": true,
                  "auto_connect": 0,
                  "captive_portal": 180,
                  "disable_auto_fallback": true,
                  "exclude": [
                    {
                      "address": "192.0.2.0/24",
                      "description": "Exclude testing domains from the tunnel"
                    }
                  ],
                  "exclude_office_ips": true,
                  "include": [
                    {
                      "address": "192.0.2.0/24",
                      "description": "Include testing domains in the tunnel"
                    }
                  ],
                  "lan_allow_minutes": 30,
                  "lan_allow_subnet_size": 24,
                  "register_interface_ip_with_dns": true,
                  "sccm_vpn_boundary_support": false,
                  "service_mode_v2": {
                    "mode": "proxy",
                    "port": 3000
                  },
                  "support_url": "https://1.1.1.1/help",
                  "switch_locked": true,
                  "tunnel_protocol": "wireguard"
                }
        argumentDocs:
            account_id: (String)
            address: (String) The address in CIDR format to exclude from the tunnel. If address is present, host must not be present.
            allow_mode_switch: (Boolean) Whether to allow the user to switch WARP between modes.
            allow_updates: (Boolean) Whether to receive update notifications when a new version of the client is available.
            allowed_to_leave: (Boolean) Whether to allow devices to leave the organization.
            auto_connect: (Number) The amount of time in seconds to reconnect after having been disabled.
            captive_portal: (Number) Turn on the captive portal after the specified amount of time.
            default: (Boolean) Whether the policy will be applied to matching devices.
            description: (String) A description of the Split Tunnel item, displayed in the client UI.
            disable_auto_fallback: (Boolean) If the dns_server field of a fallback domain is not present, the client will fall back to a best guess of the default/system DNS resolvers unless this policy option is set to true.
            dns_server: (List of String) A list of IP addresses to handle domain resolution.
            enabled: (Boolean) Whether the policy will be applied to matching devices.
            exclude: (Attributes List) List of routes excluded in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. (see below for nested schema)
            exclude_office_ips: (Boolean) Whether to add Microsoft IPs to Split Tunnel exclusions.
            fallback_domains: (Attributes List) (see below for nested schema)
            gateway_unique_id: (String)
            host: (String) The domain name to exclude from the tunnel. If host is present, address must not be present.
            id: (String) The ID of this resource.
            include: (Attributes List) List of routes included in the WARP client's tunnel. Both 'exclude' and 'include' cannot be set in the same request. (see below for nested schema)
            lan_allow_minutes: (Number) The amount of time in minutes a user is allowed access to their LAN. A value of 0 will allow LAN access until the next WARP reconnection, such as a reboot or a laptop waking from sleep. Note that this field is omitted from the response if null or unset.
            lan_allow_subnet_size: (Number) The size of the subnet for the local access network. Note that this field is omitted from the response if null or unset.
            mode: (String) The mode to run the WARP client under.
            port: (Number) The port number when used with proxy mode.
            register_interface_ip_with_dns: (Boolean) Determines if the operating system will register WARP's local interface IP with your on-premises DNS server.
            sccm_vpn_boundary_support: (Boolean) Determines whether the WARP client indicates to SCCM that it is inside a VPN boundary. (Windows only).
            service_mode_v2: (Attributes) (see below for nested schema)
            suffix: (String) The domain suffix to match when resolving locally.
            support_url: (String) The URL to launch when the Send Feedback button is clicked.
            switch_locked: (Boolean) Whether to allow the user to turn off the WARP switch and disconnect the client.
            tunnel_protocol: (String) Determines which tunnel protocol to use.
        importStatements:
            - $ terraform import cloudflare_zero_trust_device_default_profile.example '<account_id>'
    cloudflare_zero_trust_device_default_profile_certificates:
        subCategory: ""
        name: cloudflare_zero_trust_device_default_profile_certificates
        title: cloudflare_zero_trust_device_default_profile_certificates Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_default_profile_certificates
              manifest: |-
                {
                  "enabled": true,
                  "zone_id": "699d98642c564d2e855e9661899b7252"
                }
        argumentDocs:
            enabled: (Boolean) The current status of the device policy certificate provisioning feature for WARP clients.
            zone_id: (String)
        importStatements: []
    cloudflare_zero_trust_device_default_profile_local_domain_fallback:
        subCategory: ""
        name: cloudflare_zero_trust_device_default_profile_local_domain_fallback
        title: cloudflare_zero_trust_device_default_profile_local_domain_fallback Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_default_profile_local_domain_fallback
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "domains": [
                    {
                      "description": "Domain bypass for local development",
                      "dns_server": [
                        "1.1.1.1"
                      ],
                      "suffix": "example.com"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String)
            description: (String) A description of the fallback domain, displayed in the client UI.
            dns_server: (List of String) A list of IP addresses to handle domain resolution.
            domains: (Attributes List) (see below for nested schema)
            id: (String) The ID of this resource.
            suffix: (String) The domain suffix to match when resolving locally.
        importStatements:
            - $ terraform import cloudflare_zero_trust_device_default_profile_local_domain_fallback.example '<account_id>'
    cloudflare_zero_trust_device_managed_networks:
        subCategory: ""
        name: cloudflare_zero_trust_device_managed_networks
        title: cloudflare_zero_trust_device_managed_networks Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_managed_networks
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "config": {
                    "sha256": "b5bb9d8014a0f9b1d61e21e796d78dccdf1352f23cd32812f4850b878ae4944c",
                    "tls_sockaddr": "foo.bar:1234"
                  },
                  "name": "managed-network-1",
                  "type": "tls"
                }
        argumentDocs:
            account_id: (String)
            config: (Attributes) The configuration object containing information for the WARP client to detect the managed network. (see below for nested schema)
            id: (String) API UUID.
            name: (String) The name of the device managed network. This name must be unique.
            network_id: (String) API UUID.
            sha256: (String) The SHA-256 hash of the TLS certificate presented by the host found at tls_sockaddr. If absent, regular certificate verification (trusted roots, valid timestamp, etc) will be used to validate the certificate.
            tls_sockaddr: (String) A network address of the form "host:port" that the WARP client will use to detect the presence of a TLS host.
            type: |-
                (String) The type of device managed network.
                Available values: "tls".
        importStatements:
            - $ terraform import cloudflare_zero_trust_device_managed_networks.example '<account_id>/<network_id>'
    cloudflare_zero_trust_device_posture_integration:
        subCategory: ""
        name: cloudflare_zero_trust_device_posture_integration
        title: cloudflare_zero_trust_device_posture_integration Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_posture_integration
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "config": {
                    "api_url": "https://as123.awmdm.com/API",
                    "auth_url": "https://na.uemauth.workspaceone.com/connect/token",
                    "client_id": "example client id",
                    "client_secret": "example client secret"
                  },
                  "interval": "10m",
                  "name": "My Workspace One Integration",
                  "type": "workspace_one"
                }
        argumentDocs:
            access_client_id: (String) If present, this id will be passed in the CF-Access-Client-ID header when hitting the api_url.
            access_client_secret: (String, Sensitive) If present, this secret will be passed in the CF-Access-Client-Secret header when hitting the api_url.
            account_id: (String)
            api_url: (String) The Workspace One API URL provided in the Workspace One Admin Dashboard.
            auth_url: (String) The Workspace One Authorization URL depending on your region.
            client_id: (String) The Workspace One client ID provided in the Workspace One Admin Dashboard.
            client_key: (String) The Uptycs client secret.
            client_secret: (String, Sensitive) The Workspace One client secret provided in the Workspace One Admin Dashboard.
            config: (Attributes) The configuration object containing third-party integration information. (see below for nested schema)
            customer_id: (String) The Crowdstrike customer ID.
            id: (String) API UUID.
            interval: (String) The interval between each posture check with the third-party API. Use m for minutes (e.g. 5m) and h for hours (e.g. 12h).
            name: (String) The name of the device posture integration.
            type: |-
                (String) The type of device posture integration.
                Available values: "workspace_one", "crowdstrike_s2s", "uptycs", "intune", "kolide", "tanium_s2s", "sentinelone_s2s", "custom_s2s".
        importStatements:
            - $ terraform import cloudflare_zero_trust_device_posture_integration.example '<account_id>/<integration_id>'
    cloudflare_zero_trust_device_posture_rule:
        subCategory: ""
        name: cloudflare_zero_trust_device_posture_rule
        title: cloudflare_zero_trust_device_posture_rule Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_posture_rule
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "description": "The rule for admin serial numbers",
                  "expiration": "1h",
                  "input": {
                    "exists": true,
                    "operating_system": "linux",
                    "path": "/bin/cat",
                    "sha256": "https://api.us-2.crowdstrike.com",
                    "thumbprint": "0aabab210bdb998e9cf45da2c9ce352977ab531c681b74cf1e487be1bbe9fe6e"
                  },
                  "match": [
                    {
                      "platform": "windows"
                    }
                  ],
                  "name": "Admin Serial Numbers",
                  "schedule": "1h",
                  "type": "file"
                }
        argumentDocs:
            account_id: (String)
            active_threats: (Number) The Number of active threats.
            certificate_id: (String) UUID of Cloudflare managed certificate.
            check_disks: (List of String) List of volume names to be checked for encryption.
            check_private_key: (Boolean) Confirm the certificate was not imported from another device. We recommend keeping this enabled unless the certificate was deployed without a private key.
            cn: (String) Common Name that is protected by the certificate.
            compliance_status: |-
                (String) Compliance Status.
                Available values: "compliant", "noncompliant", "unknown", "notapplicable", "ingraceperiod", "error".
            connection_id: (String) Posture Integration ID.
            count_operator: |-
                (String) Count Operator.
                Available values: "<", "<=", ">", ">=", "==".
            description: (String) The description of the device posture rule.
            domain: (String) Domain.
            eid_last_seen: (String) For more details on eid last seen, refer to the Tanium documentation.
            enabled: (Boolean) Enabled.
            exists: (Boolean) Whether or not file exists.
            expiration: (String) Sets the expiration time for a posture check result. If empty, the result remains valid until it is overwritten by new data from the WARP client.
            extended_key_usage: (List of String) List of values indicating purposes for which the certificate public key can be used.
            id: (String) API UUID.
            infected: (Boolean) Whether device is infected.
            input: (Attributes) The value to be checked against. (see below for nested schema)
            is_active: (Boolean) Whether device is active.
            issue_count: (String) The Number of Issues.
            last_seen: (String) For more details on last seen, please refer to the Crowdstrike documentation.
            locations: (Attributes) (see below for nested schema)
            match: (Attributes List) The conditions that the client must match to run the rule. (see below for nested schema)
            name: (String) The name of the device posture rule.
            network_status: |-
                (String) Network status of device.
                Available values: "connected", "disconnected", "disconnecting", "connecting".
            operating_system: |-
                (String) Operating system.
                Available values: "windows", "linux", "mac", "android", "ios", "chromeos".
            operational_state: |-
                (String) Agent operational state.
                Available values: "na", "partially_disabled", "auto_fully_disabled", "fully_disabled", "auto_partially_disabled", "disabled_error", "db_corruption".
            operator: |-
                (String) Operator.
                Available values: "<", "<=", ">", ">=", "==".
            os: (String) Os Version.
            os_distro_name: (String) Operating System Distribution Name (linux only).
            os_distro_revision: (String) Version of OS Distribution (linux only).
            os_version_extra: (String) Additional operating system version details. For Windows, the UBR (Update Build Revision). For Mac or iOS, the Product Version Extra. For Linux, the distribution name and version.
            overall: (String) Overall.
            path: (String) File path.
            paths: (List of String) List of paths to check for client certificate on linux.
            platform: '(String) Available values: "windows", "mac", "linux", "android", "ios", "chromeos".'
            require_all: (Boolean) Whether to check all disks for encryption.
            risk_level: |-
                (String) For more details on risk level, refer to the Tanium documentation.
                Available values: "low", "medium", "high", "critical".
            schedule: '(String) Polling frequency for the WARP client posture check. Default: 5m (poll every five minutes). Minimum: 1m.'
            score: (Number) A value between 0-100 assigned to devices set by the 3rd party posture provider.
            score_operator: |-
                (String) Score Operator.
                Available values: "<", "<=", ">", ">=", "==".
            sensor_config: (String) SensorConfig.
            sha256: (String) SHA-256.
            state: |-
                (String) For more details on state, please refer to the Crowdstrike documentation.
                Available values: "online", "offline", "unknown".
            subject_alternative_names: (List of String) List of certificate Subject Alternative Names.
            thumbprint: (String) Signing certificate thumbprint.
            total_score: (Number) For more details on total score, refer to the Tanium documentation.
            trust_stores: (List of String) List of trust stores to check for client certificate.
            type: |-
                (String) The type of device posture rule.
                Available values: "file", "application", "tanium", "gateway", "warp", "disk_encryption", "serial_number", "sentinelone", "carbonblack", "firewall", "os_version", "domain_joined", "client_certificate", "client_certificate_v2", "antivirus", "unique_client_id", "kolide", "tanium_s2s", "crowdstrike_s2s", "intune", "workspace_one", "sentinelone_s2s", "custom_s2s".
            update_window_days: (Number) Number of days that the antivirus should be updated within.
            version: (String) Version of OS.
            version_operator: |-
                (String) Version Operator.
                Available values: "<", "<=", ">", ">=", "==".
        importStatements:
            - $ terraform import cloudflare_zero_trust_device_posture_rule.example '<account_id>/<rule_id>'
    cloudflare_zero_trust_device_settings:
        subCategory: ""
        name: cloudflare_zero_trust_device_settings
        title: cloudflare_zero_trust_device_settings Resource - Cloudflare
        examples:
            - name: example_zero_trust_device_settings
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "disable_for_time": 0,
                  "external_emergency_signal_enabled": true,
                  "external_emergency_signal_fingerprint": "abcd1234567890abcd1234567890abcd1234567890abcd1234567890abcd1234",
                  "external_emergency_signal_interval": "5m",
                  "external_emergency_signal_url": "https://192.0.2.1/signal",
                  "gateway_proxy_enabled": true,
                  "gateway_udp_proxy_enabled": true,
                  "root_certificate_installation_enabled": true,
                  "use_zt_virtual_ip": true
                }
        argumentDocs:
            account_id: (String)
            disable_for_time: (Number) Sets the time limit, in seconds, that a user can use an override code to bypass WARP.
            external_emergency_signal_enabled: (Boolean) Controls whether the external emergency disconnect feature is enabled.
            external_emergency_signal_fingerprint: (String) The SHA256 fingerprint (64 hexadecimal characters) of the HTTPS server certificate for the external_emergency_signal_url. If provided, the WARP client will use this value to verify the server's identity. The device will ignore any response if the server's certificate fingerprint does not exactly match this value.
            external_emergency_signal_interval: (String) The interval at which the WARP client fetches the emergency disconnect signal, formatted as a duration string (e.g., "5m", "2m30s", "1h"). Minimum 30 seconds.
            external_emergency_signal_url: (String) The HTTPS URL from which to fetch the emergency disconnect signal. Must use HTTPS and have an IPv4 or IPv6 address as the host.
            gateway_proxy_enabled: (Boolean) Enable gateway proxy filtering on TCP.
            gateway_udp_proxy_enabled: (Boolean) Enable gateway proxy filtering on UDP.
            root_certificate_installation_enabled: (Boolean) Enable installation of cloudflare managed root certificate.
            use_zt_virtual_ip: (Boolean) Enable using CGNAT virtual IPv4.
        importStatements: []
    cloudflare_zero_trust_dex_test:
        subCategory: ""
        name: cloudflare_zero_trust_dex_test
        title: cloudflare_zero_trust_dex_test Resource - Cloudflare
        examples:
            - name: example_zero_trust_dex_test
              manifest: |-
                {
                  "account_id": "01a7362d577a6c3019a474fd6f485823",
                  "data": {
                    "host": "https://dash.cloudflare.com",
                    "kind": "http",
                    "method": "GET"
                  },
                  "description": "Checks the dash endpoint every 30 minutes",
                  "enabled": true,
                  "interval": "30m",
                  "name": "HTTP dash health check",
                  "target_policies": [
                    {
                      "default": true,
                      "id": "id",
                      "name": "name"
                    }
                  ],
                  "targeted": true
                }
        argumentDocs:
            account_id: (String)
            data: (Attributes) The configuration object which contains the details for the WARP client to conduct the test. (see below for nested schema)
            default: (Boolean) Whether the DEX rule is the account default
            description: (String) Additional details about the test.
            enabled: (Boolean) Determines whether or not the test is active.
            host: (String) The desired endpoint to test.
            id: (String) The unique identifier for the test.
            interval: (String) How often the test will run.
            kind: (String) The type of test.
            method: (String) The HTTP request method type.
            name: (String) The name of the DEX test. Must be unique.
            target_policies: (Attributes List) DEX rules targeted by this test (see below for nested schema)
            targeted: (Boolean)
            test_id: (String) The unique identifier for the test.
        importStatements:
            - $ terraform import cloudflare_zero_trust_dex_test.example '<account_id>/<dex_test_id>'
    cloudflare_zero_trust_dlp_custom_entry:
        subCategory: ""
        name: cloudflare_zero_trust_dlp_custom_entry
        title: cloudflare_zero_trust_dlp_custom_entry Resource - Cloudflare
        examples:
            - name: example_zero_trust_dlp_custom_entry
              manifest: |-
                {
                  "account_id": "account_id",
                  "enabled": true,
                  "name": "name",
                  "pattern": {
                    "regex": "regex",
                    "validation": "luhn"
                  },
                  "profile_id": "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"
                }
        argumentDocs:
            account_id: (String)
            ai_context_available: (Boolean) Indicates whether this entry has AI remote service validation.
            available: (Boolean) Indicates whether this entry has any form of validation that is not an AI remote service.
            case_sensitive: |-
                (Boolean) Only applies to custom word lists.
                Determines if the words should be matched in a case-sensitive manner
                Cannot be set to false if secret is true
            confidence: (Attributes) (see below for nested schema)
            created_at: (String)
            description: (String)
            enabled: (Boolean)
            id: (String) The ID of this resource.
            name: (String)
            pattern: (Attributes) (see below for nested schema)
            profile_id: (String)
            profiles: (Attributes List) (see below for nested schema)
            regex: (String)
            secret: (Boolean)
            topic_type: '(String) Available values: "Intent", "Content".'
            type: '(String) Available values: "custom", "predefined", "integration", "exact_data", "document_fingerprint", "word_list".'
            updated_at: (String)
            upload_status: '(String) Available values: "empty", "uploading", "pending", "processing", "failed", "complete".'
            validation: '(String, Deprecated) Available values: "luhn".'
            variant: (Attributes) (see below for nested schema)
            word_list: (String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_dlp_custom_entry.example '<account_id>/<entry_id>'
    cloudflare_zero_trust_dlp_custom_profile:
        subCategory: ""
        name: cloudflare_zero_trust_dlp_custom_profile
        title: cloudflare_zero_trust_dlp_custom_profile Resource - Cloudflare
        examples:
            - name: example_zero_trust_dlp_custom_profile
              manifest: |-
                {
                  "account_id": "account_id",
                  "description": "Custom profile with entries",
                  "name": "name",
                  "shared_entries": [
                    {
                      "enabled": true,
                      "entry_id": "56a8c060-01bb-4f89-ba1e-3ad42770a342",
                      "entry_type": "predefined"
                    }
                  ]
                }
              dependencies:
                cloudflare_zero_trust_dlp_custom_entry.example_custom_entry: |-
                    {
                      "account_id": "account_id",
                      "enabled": true,
                      "name": "custom",
                      "pattern": {
                        "regex": "customentryregex"
                      },
                      "profile_id": "${cloudflare_zero_trust_dlp_custom_profile.example_zero_trust_dlp_custom_profile.id}"
                    }
        argumentDocs:
            account_id: (String)
            ai_context_enabled: (Boolean)
            allowed_match_count: (Number) Related DLP policies will trigger when the match count exceeds the number set.
            confidence_threshold: (String)
            context_awareness: (Attributes, Deprecated) Scan the context of predefined entries to only return matches surrounded by keywords. (see below for nested schema)
            created_at: (String) When the profile was created.
            description: (String) The description of the profile.
            enabled: (Boolean) If true, scan the context of predefined entries to only return matches surrounded by keywords.
            entries: |-
                (Attributes Set, Deprecated) Custom entries from this profile.
                If this field is omitted, entries owned by this profile will not be changed. (see below for nested schema)
            entry_id: (String)
            entry_type: '(String) Available values: "custom", "predefined", "integration", "exact_data", "document_fingerprint".'
            files: (Boolean) If the content type is a file, skip context analysis and return all matches.
            id: (String) The id of the profile (uuid).
            name: (String)
            ocr_enabled: (Boolean)
            open_access: (Boolean) Whether this profile can be accessed by anyone.
            pattern: (Attributes) (see below for nested schema)
            regex: (String)
            shared_entries: (Attributes Set) Entries from other profiles (e.g. pre-defined Cloudflare profiles, or your Microsoft Information Protection profiles). (see below for nested schema)
            skip: (Attributes) Content types to exclude from context analysis and return all matches. (see below for nested schema)
            type: '(String) Available values: "custom", "predefined", "integration".'
            updated_at: (String) When the profile was lasted updated.
            validation: '(String, Deprecated) Available values: "luhn".'
        importStatements:
            - $ terraform import cloudflare_zero_trust_dlp_custom_profile.example '<account_id>/<profile_id>'
    cloudflare_zero_trust_dlp_dataset:
        subCategory: ""
        name: cloudflare_zero_trust_dlp_dataset
        title: cloudflare_zero_trust_dlp_dataset Resource - Cloudflare
        examples:
            - name: example_zero_trust_dlp_dataset
              manifest: |-
                {
                  "account_id": "account_id",
                  "case_sensitive": true,
                  "description": "description",
                  "encoding_version": 0,
                  "name": "name",
                  "secret": true
                }
        argumentDocs:
            account_id: (String)
            case_sensitive: |-
                (Boolean) Only applies to custom word lists.
                Determines if the words should be matched in a case-sensitive manner
                Cannot be set to false if secret is true or undefined
            columns: (Attributes List) (see below for nested schema)
            created_at: (String)
            dataset: (Attributes) (see below for nested schema)
            dataset_id: (String)
            description: (String) The description of the dataset.
            encoding_version: (Number) Dataset encoding version
            entry_id: (String)
            header_name: (String)
            id: (String) The ID of this resource.
            max_cells: (Number)
            name: (String)
            num_cells: (Number)
            secret: (Boolean) Generate a secret dataset.
            status: '(String) Available values: "empty", "uploading", "pending", "processing", "failed", "complete".'
            updated_at: (String) Stores when the dataset was last updated.
            upload_status: '(String) Available values: "empty", "uploading", "pending", "processing", "failed", "complete".'
            uploads: (Attributes List) (see below for nested schema)
            version: (Number) The version to use when uploading the dataset.
        importStatements: []
    cloudflare_zero_trust_dlp_entry:
        subCategory: ""
        name: cloudflare_zero_trust_dlp_entry
        title: cloudflare_zero_trust_dlp_entry Resource - Cloudflare
        examples:
            - name: example_zero_trust_dlp_entry
              manifest: |-
                {
                  "account_id": "account_id",
                  "enabled": true,
                  "name": "name",
                  "pattern": {
                    "regex": "regex",
                    "validation": "luhn"
                  },
                  "profile_id": "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"
                }
        argumentDocs:
            account_id: (String)
            ai_context_available: (Boolean) Indicates whether this entry has AI remote service validation.
            available: (Boolean) Indicates whether this entry has any form of validation that is not an AI remote service.
            case_sensitive: |-
                (Boolean) Only applies to custom word lists.
                Determines if the words should be matched in a case-sensitive manner
                Cannot be set to false if secret is true
            confidence: (Attributes) (see below for nested schema)
            created_at: (String)
            description: (String)
            enabled: (Boolean)
            id: (String) The ID of this resource.
            name: (String)
            pattern: (Attributes) (see below for nested schema)
            profile_id: (String)
            profiles: (Attributes List) (see below for nested schema)
            regex: (String)
            secret: (Boolean)
            topic_type: '(String) Available values: "Intent", "Content".'
            type: '(String) Available values: "custom", "predefined", "integration".'
            updated_at: (String)
            upload_status: '(String) Available values: "empty", "uploading", "pending", "processing", "failed", "complete".'
            validation: '(String, Deprecated) Available values: "luhn".'
            variant: (Attributes) (see below for nested schema)
            word_list: (String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_dlp_entry.example '<account_id>/<entry_id>'
    cloudflare_zero_trust_dlp_integration_entry:
        subCategory: ""
        name: cloudflare_zero_trust_dlp_integration_entry
        title: cloudflare_zero_trust_dlp_integration_entry Resource - Cloudflare
        examples:
            - name: example_zero_trust_dlp_integration_entry
              manifest: |-
                {
                  "account_id": "account_id",
                  "enabled": true,
                  "entry_id": "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
                  "profile_id": "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"
                }
        argumentDocs:
            account_id: (String)
            ai_context_available: (Boolean) Indicates whether this entry has AI remote service validation.
            available: (Boolean) Indicates whether this entry has any form of validation that is not an AI remote service.
            case_sensitive: |-
                (Boolean) Only applies to custom word lists.
                Determines if the words should be matched in a case-sensitive manner
                Cannot be set to false if secret is true
            confidence: (Attributes) (see below for nested schema)
            created_at: (String)
            description: (String)
            enabled: (Boolean)
            entry_id: (String)
            id: (String) The ID of this resource.
            name: (String)
            pattern: (Attributes) (see below for nested schema)
            profile_id: |-
                (String) This field is not used as the owning profile.
                For predefined entries it is already set to a predefined profile.
            profiles: (Attributes List) (see below for nested schema)
            regex: (String)
            secret: (Boolean)
            topic_type: '(String) Available values: "Intent", "Content".'
            type: '(String) Available values: "custom", "predefined", "integration", "exact_data", "document_fingerprint", "word_list".'
            updated_at: (String)
            upload_status: '(String) Available values: "empty", "uploading", "pending", "processing", "failed", "complete".'
            validation: '(String, Deprecated) Available values: "luhn".'
            variant: (Attributes) (see below for nested schema)
            word_list: (String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_dlp_integration_entry.example '<account_id>/<entry_id>'
    cloudflare_zero_trust_dlp_predefined_entry:
        subCategory: ""
        name: cloudflare_zero_trust_dlp_predefined_entry
        title: cloudflare_zero_trust_dlp_predefined_entry Resource - Cloudflare
        examples:
            - name: example_zero_trust_dlp_predefined_entry
              manifest: |-
                {
                  "account_id": "account_id",
                  "enabled": true,
                  "entry_id": "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e",
                  "profile_id": "182bd5e5-6e1a-4fe4-a799-aa6d9a6ab26e"
                }
        argumentDocs:
            account_id: (String)
            ai_context_available: (Boolean) Indicates whether this entry has AI remote service validation.
            available: (Boolean) Indicates whether this entry has any form of validation that is not an AI remote service.
            case_sensitive: |-
                (Boolean) Only applies to custom word lists.
                Determines if the words should be matched in a case-sensitive manner
                Cannot be set to false if secret is true
            confidence: (Attributes) (see below for nested schema)
            created_at: (String)
            description: (String)
            enabled: (Boolean)
            entry_id: (String)
            id: (String) The ID of this resource.
            name: (String)
            pattern: (Attributes) (see below for nested schema)
            profile_id: |-
                (String) This field is not used as the owning profile.
                For predefined entries it is already set to a predefined profile.
            profiles: (Attributes List) (see below for nested schema)
            regex: (String)
            secret: (Boolean)
            topic_type: '(String) Available values: "Intent", "Content".'
            type: '(String) Available values: "custom", "predefined", "integration", "exact_data", "document_fingerprint", "word_list".'
            updated_at: (String)
            upload_status: '(String) Available values: "empty", "uploading", "pending", "processing", "failed", "complete".'
            validation: '(String, Deprecated) Available values: "luhn".'
            variant: (Attributes) (see below for nested schema)
            word_list: (String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_dlp_predefined_entry.example '<account_id>/<entry_id>'
    cloudflare_zero_trust_dlp_predefined_profile:
        subCategory: ""
        name: cloudflare_zero_trust_dlp_predefined_profile
        title: cloudflare_zero_trust_dlp_predefined_profile Resource - Cloudflare
        examples:
            - name: example_zero_trust_dlp_predefined_profile
              manifest: |-
                {
                  "account_id": "account_id",
                  "enabled_entries": [
                    "56a8c060-01bb-4f89-ba1e-3ad42770a342",
                    "7f575e6d-039a-465e-85cf-175bda88d4f2",
                    "03ebabfd-ce7e-45ed-8061-65e28f0a6e53",
                    "2d9c356d-b5a3-482a-b01e-0363e0de7458",
                    "2f3657af-c39b-4899-9a98-22f7d187dd28",
                    "753a16f9-f533-4208-a5b8-6319b201e9fb",
                    "ebcea2c4-335a-457c-853b-f7ae7cc74e07",
                    "3f5c4c83-f34c-4d17-81c7-3028385737b3",
                    "d1a84fde-c375-4d3c-8a27-8c4eaa33cf60",
                    "6dbe5604-d3a3-4c3e-905c-57985704bea7",
                    "55ba2c6c-8ef4-4b2e-9148-e75e8b6ccac1",
                    "5b1d5035-8c53-4bc9-a151-404eb32b34b4",
                    "acf28d88-2daf-4bc4-aa36-5ac1fac0540a"
                  ],
                  "ocr_enabled": true,
                  "profile_id": "e91a2360-da51-4fdf-9711-bcdecd462614"
                }
        argumentDocs:
            account_id: (String)
            ai_context_enabled: (Boolean)
            allowed_match_count: (Number)
            confidence_threshold: (String)
            enabled: (Boolean)
            enabled_entries: (List of String)
            entries: (Attributes List, Deprecated) (see below for nested schema)
            id: (String) The ID of this resource.
            name: (String) The name of the predefined profile.
            ocr_enabled: (Boolean)
            open_access: (Boolean) Whether this profile can be accessed by anyone.
            profile_id: (String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_dlp_predefined_profile.example '<account_id>/<profile_id>'
    cloudflare_zero_trust_dns_location:
        subCategory: ""
        name: cloudflare_zero_trust_dns_location
        title: cloudflare_zero_trust_dns_location Resource - Cloudflare
        examples:
            - name: example_zero_trust_dns_location
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "client_default": false,
                  "dns_destination_ips_id": "0e4a32c6-6fb8-4858-9296-98f51631e8e6",
                  "ecs_support": false,
                  "endpoints": {
                    "doh": {
                      "enabled": true,
                      "networks": [
                        {
                          "network": "2001:85a3::/64"
                        }
                      ],
                      "require_token": true
                    },
                    "dot": {
                      "enabled": true,
                      "networks": [
                        {
                          "network": "2001:85a3::/64"
                        }
                      ]
                    },
                    "ipv4": {
                      "enabled": true
                    },
                    "ipv6": {
                      "enabled": true,
                      "networks": [
                        {
                          "network": "2001:85a3::/64"
                        }
                      ]
                    }
                  },
                  "name": "Austin Office Location",
                  "networks": [
                    {
                      "network": "192.0.2.1/32"
                    }
                  ]
                }
        argumentDocs:
            account_id: (String)
            client_default: (Boolean) Indicate whether this location is the default location.
            created_at: (String)
            dns_destination_ips_id: (String) Specify the identifier of the pair of IPv4 addresses assigned to this location. When creating a location, if this field is absent or set to null, the pair of shared IPv4 addresses (0e4a32c6-6fb8-4858-9296-98f51631e8e6) is auto-assigned. When updating a location, if this field is absent or set to null, the pre-assigned pair remains unchanged.
            dns_destination_ipv6_block_id: (String) Specify the UUID of the IPv6 block brought to the gateway so that this location's IPv6 address is allocated from the Bring Your Own IPv6 (BYOIPv6) block rather than the standard Cloudflare IPv6 block.
            doh: (Attributes) (see below for nested schema)
            doh_subdomain: (String) Specify the DNS over HTTPS domain that receives DNS requests. Gateway automatically generates this value.
            dot: (Attributes) (see below for nested schema)
            ecs_support: (Boolean) Indicate whether the location must resolve EDNS queries.
            enabled: (Boolean) Indicate whether the DOH endpoint is enabled for this location.
            endpoints: (Attributes) Configure the destination endpoints for this location. (see below for nested schema)
            id: (String) The ID of this resource.
            ip: (String) Defines the automatically generated IPv6 destination IP assigned to this location. Gateway counts all DNS requests sent to this IP as requests under this location.
            ipv4: (Attributes) (see below for nested schema)
            ipv4_destination: (String) Show the primary destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only.
            ipv4_destination_backup: (String) Show the backup destination IPv4 address from the pair identified dns_destination_ips_id. This field read-only.
            ipv6: (Attributes) (see below for nested schema)
            name: (String) Specify the location name.
            network: (String) Specify the IP address or IP CIDR.
            networks: (Attributes List) Specify the list of network ranges from which requests at this location originate. The list takes effect only if it is non-empty and the IPv4 endpoint is enabled for this location. (see below for nested schema)
            require_token: (Boolean) Specify whether the DOH endpoint requires user identity authentication.
            updated_at: (String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_dns_location.example '<account_id>/<location_id>'
    cloudflare_zero_trust_gateway_certificate:
        subCategory: ""
        name: cloudflare_zero_trust_gateway_certificate
        title: cloudflare_zero_trust_gateway_certificate Resource - Cloudflare
        examples:
            - name: example_zero_trust_gateway_certificate
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "validity_period_days": 1826
                }
        argumentDocs:
            account_id: (String)
            activate: (Boolean) Whether to activate the certificate on Cloudflare's edge. When true, the certificate will be activated. When false, the certificate will be deactivated at the edge. This is a Terraform-only field and does not appear in the API response. Monitor binding_status for the activation status. Once a certificate is activated, you may use the certificate to intercept traffic
            binding_status: |-
                (String) Indicate the read-only deployment status of the certificate on Cloudflare's edge. Gateway TLS interception can use certificates in the 'available' (previously called 'active') state.
                Available values: "pending_deployment", "available", "pending_deletion", "inactive".
            certificate: (String) Provide the CA certificate (read-only).
            created_at: (String)
            expires_on: (String)
            fingerprint: (String) Provide the SHA256 fingerprint of the certificate (read-only).
            id: (String) Identify the certificate with a UUID.
            in_use: (Boolean) Indicate whether Gateway TLS interception uses this certificate (read-only). You cannot set this value directly. To configure interception, use the Gateway configuration setting named certificate (read-only).
            issuer_org: (String) Indicate the organization that issued the certificate (read-only).
            issuer_raw: (String) Provide the entire issuer field of the certificate (read-only).
            type: |-
                (String) Indicate the read-only certificate type, BYO-PKI (custom) or Gateway-managed.
                Available values: "custom", "gateway_managed".
            updated_at: (String)
            uploaded_on: (String)
            validity_period_days: '(Number) Sets the certificate validity period in days (range: 1-10,950 days / ~30 years). Defaults to 1,825 days (5 years). Important: This field is only settable during the certificate creation.  Certificates becomes immutable after creation - use the /activate and /deactivate endpoints to manage certificate lifecycle.'
        importStatements:
            - $ terraform import cloudflare_zero_trust_gateway_certificate.example '<account_id>/<certificate_id>'
    cloudflare_zero_trust_gateway_logging:
        subCategory: ""
        name: cloudflare_zero_trust_gateway_logging
        title: cloudflare_zero_trust_gateway_logging Resource - Cloudflare
        examples:
            - name: example_zero_trust_gateway_logging
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "redact_pii": true,
                  "settings_by_rule_type": {
                    "dns": {
                      "log_all": false,
                      "log_blocks": true
                    },
                    "http": {
                      "log_all": false,
                      "log_blocks": true
                    },
                    "l4": {
                      "log_all": false,
                      "log_blocks": true
                    }
                  }
                }
        argumentDocs:
            account_id: (String)
            dns: (Attributes) Configure logging settings for DNS firewall. (see below for nested schema)
            http: (Attributes) Configure logging settings for HTTP/HTTPS firewall. (see below for nested schema)
            l4: (Attributes) Configure logging settings for Network firewall. (see below for nested schema)
            log_all: (Boolean) Specify whether to log all requests to this service.
            log_blocks: (Boolean) Specify whether to log only blocking requests to this service.
            redact_pii: (Boolean) Indicate whether to redact personally identifiable information from activity logging (PII fields include source IP, user email, user ID, device ID, URL, referrer, and user agent).
            settings_by_rule_type: (Attributes) Configure logging settings for each rule type. (see below for nested schema)
        importStatements: []
    cloudflare_zero_trust_gateway_policy:
        subCategory: ""
        name: cloudflare_zero_trust_gateway_policy
        title: cloudflare_zero_trust_gateway_policy Resource - Cloudflare
        examples:
            - name: example_zero_trust_gateway_policy
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "action": "allow",
                  "description": "Block bad websites based on their host name.",
                  "device_posture": "any(device_posture.checks.passed[*] in {\"1308749e-fcfb-4ebc-b051-fe022b632644\"})",
                  "enabled": true,
                  "expiration": {
                    "duration": 10,
                    "expires_at": "2014-01-01T05:20:20Z"
                  },
                  "filters": [
                    "http"
                  ],
                  "identity": "any(identity.groups.name[*] in {\"finance\"})",
                  "name": "block bad websites",
                  "precedence": 0,
                  "rule_settings": {
                    "add_headers": {
                      "My-Next-Header": [
                        "foo",
                        "bar"
                      ],
                      "X-Custom-Header-Name": [
                        "somecustomvalue"
                      ]
                    },
                    "allow_child_bypass": false,
                    "audit_ssh": {
                      "command_logging": false
                    },
                    "biso_admin_controls": {
                      "copy": "remote_only",
                      "dcp": true,
                      "dd": true,
                      "dk": true,
                      "download": "enabled",
                      "dp": false,
                      "du": true,
                      "keyboard": "enabled",
                      "paste": "enabled",
                      "printing": "enabled",
                      "upload": "enabled",
                      "version": "v1"
                    },
                    "block_page": {
                      "include_context": true,
                      "target_uri": "https://example.com"
                    },
                    "block_page_enabled": true,
                    "block_reason": "This website is a security risk",
                    "bypass_parent_rule": false,
                    "check_session": {
                      "duration": "300s",
                      "enforce": true
                    },
                    "dns_resolvers": {
                      "ipv4": [
                        {
                          "ip": "2.2.2.2",
                          "port": 5053,
                          "route_through_private_network": true,
                          "vnet_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415"
                        }
                      ],
                      "ipv6": [
                        {
                          "ip": "2001:DB8::",
                          "port": 5053,
                          "route_through_private_network": true,
                          "vnet_id": "f174e90a-fafe-4643-bbbc-4a0ed4fc8415"
                        }
                      ]
                    },
                    "egress": {
                      "ipv4": "192.0.2.2",
                      "ipv4_fallback": "192.0.2.3",
                      "ipv6": "2001:DB8::/64"
                    },
                    "forensic_copy": {
                      "enabled": true
                    },
                    "ignore_cname_category_matches": true,
                    "insecure_disable_dnssec_validation": false,
                    "ip_categories": true,
                    "ip_indicator_feeds": true,
                    "l4override": {
                      "ip": "1.1.1.1",
                      "port": 0
                    },
                    "notification_settings": {
                      "enabled": true,
                      "include_context": true,
                      "msg": "msg",
                      "support_url": "support_url"
                    },
                    "override_host": "example.com",
                    "override_ips": [
                      "1.1.1.1",
                      "2.2.2.2"
                    ],
                    "payload_log": {
                      "enabled": true
                    },
                    "quarantine": {
                      "file_types": [
                        "exe"
                      ]
                    },
                    "redirect": {
                      "include_context": true,
                      "preserve_path_and_query": true,
                      "target_uri": "https://example.com"
                    },
                    "resolve_dns_internally": {
                      "fallback": "none",
                      "view_id": "view_id"
                    },
                    "resolve_dns_through_cloudflare": true,
                    "untrusted_cert": {
                      "action": "error"
                    }
                  },
                  "schedule": {
                    "fri": "08:00-12:30,13:30-17:00",
                    "mon": "08:00-12:30,13:30-17:00",
                    "sat": "08:00-12:30,13:30-17:00",
                    "sun": "08:00-12:30,13:30-17:00",
                    "thu": "08:00-12:30,13:30-17:00",
                    "time_zone": "America/New York",
                    "tue": "08:00-12:30,13:30-17:00",
                    "wed": "08:00-12:30,13:30-17:00"
                  },
                  "traffic": "http.request.uri matches \".*a/partial/uri.*\" and http.request.host in $01302951-49f9-47c9-a400-0297e60b6a10"
                }
        argumentDocs:
            account_id: (String)
            action: |-
                (String) Specify the action to perform when the associated traffic, identity, and device posture expressions either absent or evaluate to true.
                Available values: "on", "off", "allow", "block", "scan", "noscan", "safesearch", "ytrestricted", "isolate", "noisolate", "override", "l4_override", "egress", "resolve", "quarantine", "redirect".
            add_headers: (Map of List of String) Add custom headers to allowed requests as key-value pairs. Use header names as keys that map to arrays of header values. Settable only for http rules with the action set to allow.
            allow_child_bypass: (Boolean) Set to enable MSP children to bypass this rule. Only parent MSP accounts can set this. this rule. Settable for all types of rules.
            audit_ssh: (Attributes) Define the settings for the Audit SSH action. Settable only for l4 rules with audit_ssh action. (see below for nested schema)
            biso_admin_controls: (Attributes) Configure browser isolation behavior. Settable only for http rules with the action set to isolate. (see below for nested schema)
            block_page: (Attributes) Configure custom block page settings. If missing or null, use the account settings. Settable only for http rules with the action set to block. (see below for nested schema)
            block_page_enabled: (Boolean) Enable the custom block page. Settable only for dns rules with action block.
            block_reason: (String) Explain why the rule blocks the request. The custom block page shows this text (if enabled). Settable only for dns, l4, and http rules when the action set to block.
            bypass_parent_rule: (Boolean) Set to enable MSP accounts to bypass their parent's rules. Only MSP child accounts can set this. Settable for all types of rules.
            check_session: (Attributes) Configure session check behavior. Settable only for l4 and http rules with the action set to allow. (see below for nested schema)
            command_logging: (Boolean) Enable SSH command logging.
            copy: |-
                (String) Configure copy behavior. If set to remote_only, users cannot copy isolated content from the remote browser to the local clipboard. If this field is absent, copying remains enabled. Applies only when version == "v2".
                Available values: "enabled", "disabled", "remote_only".
            created_at: (String)
            dcp: (Boolean) Set to false to enable copy-pasting. Only applies when version == "v1".
            dd: (Boolean) Set to false to enable downloading. Only applies when version == "v1".
            deleted_at: (String) Indicate the date of deletion, if any.
            description: (String) Specify the rule description.
            device_posture: (String) Specify the wirefilter expression used for device posture check. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
            dk: (Boolean) Set to false to enable keyboard usage. Only applies when version == "v1".
            dns_resolvers: (Attributes) Configure custom resolvers to route queries that match the resolver policy. Unused with 'resolve_dns_through_cloudflare' or 'resolve_dns_internally' settings. DNS queries get routed to the address closest to their origin. Only valid when a rule's action set to 'resolve'. Settable only for dns_resolver rules. (see below for nested schema)
            download: |-
                (String) Configure download behavior. When set to remote_only, users can view downloads but cannot save them. Applies only when version == "v2".
                Available values: "enabled", "disabled", "remote_only".
            dp: (Boolean) Set to false to enable printing. Only applies when version == "v1".
            du: (Boolean) Set to false to enable uploading. Only applies when version == "v1".
            duration: (Number) Defines the default duration a policy active in minutes. Must set in order to use the reset_expiration endpoint on this rule.
            egress: (Attributes) Configure how Gateway Proxy traffic egresses. You can enable this setting for rules with Egress actions and filters, or omit it to indicate local egress via WARP IPs. Settable only for egress rules. (see below for nested schema)
            enabled: (Boolean) Specify whether the rule is enabled.
            enforce: (Boolean) Enable session enforcement.
            expiration: (Attributes) Defines the expiration time stamp and default duration of a DNS policy. Takes precedence over the policy's schedule configuration, if any. This  does not apply to HTTP or network policies. Settable only for dns rules. (see below for nested schema)
            expired: (Boolean) Indicates whether the policy is expired.
            expires_at: (String) Show the timestamp when the policy expires and stops applying.  The value must follow RFC 3339 and include a UTC offset.  The system accepts non-zero offsets but converts them to the equivalent UTC+00:00  value and returns timestamps with a trailing Z. Expiration policies ignore client  timezones and expire globally at the specified expires_at time.
            fallback: |-
                (String) Specify the fallback behavior to apply when the internal DNS response code differs from 'NOERROR' or when the response data contains only CNAME records for 'A' or 'AAAA' queries.
                Available values: "none", "public_dns".
            file_types: (List of String) Specify the types of files to sandbox.
            filters: (List of String) Specify the protocol or layer to evaluate the traffic, identity, and device posture expressions. Can only contain a single value.
            forensic_copy: (Attributes) Configure whether a copy of the HTTP request will be sent to storage when the rule matches. (see below for nested schema)
            fri: (String) Specify the time intervals when the rule is active on Fridays, in the increasing order from 00:00-24:00.  If this parameter omitted, the rule is deactivated on Fridays. API returns a formatted version of this string, which may cause Terraform drift if a unformatted value is used.
            id: (String) Identify the API resource with a UUID.
            identity: (String) Specify the wirefilter expression used for identity matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
            ignore_cname_category_matches: (Boolean) Ignore category matches at CNAME domains in a response. When off, evaluate categories in this rule against all CNAME domain categories in the response. Settable only for dns and dns_resolver rules.
            include_context: (Boolean) Specify whether to pass the context information as query parameters.
            insecure_disable_dnssec_validation: (Boolean) Specify whether to disable DNSSEC validation (for Allow actions) [INSECURE]. Settable only for dns rules.
            ip: (String) Specify the IPv4 address of the upstream resolver.
            ip_categories: (Boolean) Enable IPs in DNS resolver category blocks. The system blocks only domain name categories unless you enable this setting. Settable only for dns and dns_resolver rules.
            ip_indicator_feeds: (Boolean) Indicates whether to include IPs in DNS resolver indicator feed blocks. Default, indicator feeds block only domain names. Settable only for dns and dns_resolver rules.
            ipv4: (Attributes List) (see below for nested schema)
            ipv4_fallback: (String) Specify the fallback IPv4 address to use for egress when the primary IPv4 fails. Set '0.0.0.0' to indicate local egress via WARP IPs.
            ipv6: (Attributes List) (see below for nested schema)
            keyboard: |-
                (String) Configure keyboard usage behavior. If this field is absent, keyboard usage remains enabled. Applies only when version == "v2".
                Available values: "enabled", "disabled".
            l4override: (Attributes) Send matching traffic to the supplied destination IP address and port. Settable only for l4 rules with the action set to l4_override. (see below for nested schema)
            mon: (String) Specify the time intervals when the rule is active on Mondays, in the increasing order from 00:00-24:00(capped at maximum of 6 time splits). If this parameter omitted, the rule is deactivated on Mondays. API returns a formatted version of this string, which may cause Terraform drift if a unformatted value is used.
            msg: (String) Customize the message shown in the notification.
            name: (String) Specify the rule name.
            notification_settings: (Attributes) Configure a notification to display on the user's device when this rule matched. Settable for all types of rules with the action set to block. (see below for nested schema)
            override_host: (String) Defines a hostname for override, for the matching DNS queries. Settable only for dns rules with the action set to override.
            override_ips: (List of String) Defines a an IP or set of IPs for overriding matched DNS queries. Settable only for dns rules with the action set to override.
            paste: |-
                (String) Configure paste behavior. If set to remote_only, users cannot paste content from the local clipboard into isolated pages. If this field is absent, pasting remains enabled. Applies only when version == "v2".
                Available values: "enabled", "disabled", "remote_only".
            payload_log: (Attributes) Configure DLP payload logging. Settable only for http rules. (see below for nested schema)
            port: (Number) Specify a port number to use for the upstream resolver. Defaults to 53 if unspecified.
            precedence: (Number) Set the order of your rules. Lower values indicate higher precedence. At each processing phase, evaluate applicable rules in ascending order of this value. Refer to Order of enforcement to manage precedence via Terraform.
            preserve_path_and_query: (Boolean) Specify whether to append the path and query parameters from the original request to target_uri.
            printing: |-
                (String) Configure print behavior. Default, Printing is enabled. Applies only when version == "v2".
                Available values: "enabled", "disabled".
            quarantine: (Attributes) Configure settings that apply to quarantine rules. Settable only for http rules. (see below for nested schema)
            read_only: (Boolean) Indicate that this rule is shared via the Orgs API and read only.
            redirect: (Attributes) Apply settings to redirect rules. Settable only for http rules with the action set to redirect. (see below for nested schema)
            resolve_dns_internally: (Attributes) Configure to forward the query to the internal DNS service, passing the specified 'view_id' as input. Not used when 'dns_resolvers' is specified or 'resolve_dns_through_cloudflare' is set. Only valid when a rule's action set to 'resolve'. Settable only for dns_resolver rules. (see below for nested schema)
            resolve_dns_through_cloudflare: (Boolean) Enable to send queries that match the policy to Cloudflare's default 1.1.1.1 DNS resolver. Cannot set when 'dns_resolvers' specified or 'resolve_dns_internally' is set. Only valid when a rule's action set to 'resolve'. Settable only for dns_resolver rules.
            route_through_private_network: (Boolean) Indicate whether to connect to this resolver over a private network. Must set when vnet_id set.
            rule_settings: (Attributes) Defines settings for this rule. Settings apply only to specific rule types and must use compatible selectors. If Terraform detects drift, confirm the setting supports your rule type and check whether the API modifies the value. Use API-returned values in your configuration to prevent drift. (see below for nested schema)
            sat: (String) Specify the time intervals when the rule is active on Saturdays, in the increasing order from 00:00-24:00.  If this parameter omitted, the rule is deactivated on Saturdays. API returns a formatted version of this string, which may cause Terraform drift if a unformatted value is used.
            schedule: (Attributes) Defines the schedule for activating DNS policies. Settable only for dns and dns_resolver rules. (see below for nested schema)
            sharable: (Boolean) Indicate that this rule is sharable via the Orgs API.
            source_account: (String) Provide the account tag of the account that created the rule.
            sun: (String) Specify the time intervals when the rule is active on Sundays, in the increasing order from 00:00-24:00. If this parameter omitted, the rule is deactivated on Sundays. API returns a formatted version of this string, which may cause Terraform drift if a unformatted value is used.
            support_url: (String) Defines an optional URL to direct users to additional information. If unset, the notification opens a block page.
            target_uri: (String) Specify the URI to which the user is redirected.
            thu: (String) Specify the time intervals when the rule is active on Thursdays, in the increasing order from 00:00-24:00. If this parameter omitted, the rule is deactivated on Thursdays. API returns a formatted version of this string, which may cause Terraform drift if a unformatted value is used.
            time_zone: (String) Specify the time zone for rule evaluation. When a valid time zone city name is provided, Gateway always uses the current time for that time zone. When this parameter is omitted, Gateway uses the time zone determined from the user's IP address. Colo time zone is used when the user's IP address does not resolve to a location.
            traffic: (String) Specify the wirefilter expression used for traffic matching. The API automatically formats and sanitizes expressions before storing them. To prevent Terraform state drift, use the formatted expression returned in the API response.
            tue: (String) Specify the time intervals when the rule is active on Tuesdays, in the increasing order from 00:00-24:00. If this parameter omitted, the rule is deactivated on Tuesdays. API returns a formatted version of this string, which may cause Terraform drift if a unformatted value is used.
            untrusted_cert: (Attributes) Configure behavior when an upstream certificate is invalid or an SSL error occurs. Settable only for http rules with the action set to allow. (see below for nested schema)
            updated_at: (String)
            upload: |-
                (String) Configure upload behavior. If this field is absent, uploading remains enabled. Applies only when version == "v2".
                Available values: "enabled", "disabled".
            version: (Number) Indicate the version number of the rule(read-only).
            view_id: (String) Specify the internal DNS view identifier to pass to the internal DNS service.
            vnet_id: (String) Specify an optional virtual network for this resolver. Uses default virtual network id if omitted.
            warning_status: (String) Indicate a warning for a misconfigured rule, if any.
            wed: (String) Specify the time intervals when the rule is active on Wednesdays, in the increasing order from 00:00-24:00. If this parameter omitted, the rule is deactivated on Wednesdays. API returns a formatted version of this string, which may cause Terraform drift if a unformatted value is used.
        importStatements:
            - $ terraform import cloudflare_zero_trust_gateway_policy.example '<account_id>/<rule_id>'
    cloudflare_zero_trust_gateway_proxy_endpoint:
        subCategory: ""
        name: cloudflare_zero_trust_gateway_proxy_endpoint
        title: cloudflare_zero_trust_gateway_proxy_endpoint Resource - Cloudflare
        examples:
            - name: example_zero_trust_gateway_proxy_endpoint
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "kind": "ip",
                  "name": "Devops team"
                }
        argumentDocs:
            account_id: (String)
            created_at: (String)
            id: (String) The ID of this resource.
            ips: (List of String) Specify the list of CIDRs to restrict ingress connections.
            kind: |-
                (String) The proxy endpoint kind
                Available values: "ip", "identity".
            name: (String) Specify the name of the proxy endpoint.
            subdomain: (String) Specify the subdomain to use as the destination in the proxy client.
            updated_at: (String)
        importStatements:
            - $ terraform import cloudflare_zero_trust_gateway_proxy_endpoint.example '<account_id>/<proxy_endpoint_id>'
    cloudflare_zero_trust_gateway_settings:
        subCategory: ""
        name: cloudflare_zero_trust_gateway_settings
        title: cloudflare_zero_trust_gateway_settings Resource - Cloudflare
        examples:
            - name: example_zero_trust_gateway_settings
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "settings": {
                    "activity_log": {
                      "enabled": true
                    },
                    "antivirus": {
                      "enabled_download_phase": false,
                      "enabled_upload_phase": false,
                      "fail_closed": false,
                      "notification_settings": {
                        "enabled": true,
                        "include_context": true,
                        "msg": "msg",
                        "support_url": "support_url"
                      }
                    },
                    "block_page": {
                      "background_color": "background_color",
                      "enabled": true,
                      "footer_text": "--footer--",
                      "header_text": "--header--",
                      "include_context": true,
                      "logo_path": "https://logos.com/a.png",
                      "mailto_address": "admin@example.com",
                      "mailto_subject": "Blocked User Inquiry",
                      "mode": "",
                      "name": "Cloudflare",
                      "suppress_footer": false,
                      "target_uri": "https://example.com"
                    },
                    "body_scanning": {
                      "inspection_mode": "deep"
                    },
                    "browser_isolation": {
                      "non_identity_enabled": true,
                      "url_browser_isolation_enabled": true
                    },
                    "certificate": {
                      "id": "d1b364c5-1311-466e-a194-f0e943e0799f"
                    },
                    "custom_certificate": {
                      "enabled": true,
                      "id": "d1b364c5-1311-466e-a194-f0e943e0799f"
                    },
                    "extended_email_matching": {
                      "enabled": true
                    },
                    "fips": {
                      "tls": true
                    },
                    "host_selector": {
                      "enabled": false
                    },
                    "inspection": {
                      "mode": "static"
                    },
                    "protocol_detection": {
                      "enabled": true
                    },
                    "sandbox": {
                      "enabled": true,
                      "fallback_action": "allow"
                    },
                    "tls_decrypt": {
                      "enabled": true
                    }
                  }
                }
        argumentDocs:
            account_id: (String)
            activity_log: (Attributes) Specify activity log settings. (see below for nested schema)
            antivirus: (Attributes) Specify anti-virus settings. (see below for nested schema)
            background_color: '(String) Specify the block page background color in #rrggbb format when the mode is customized_block_page.'
            binding_status: (String) Indicate the internal certificate status.
            block_page: (Attributes) Specify block page layout settings. (see below for nested schema)
            body_scanning: (Attributes) Specify the DLP inspection mode. (see below for nested schema)
            browser_isolation: (Attributes) Specify Clientless Browser Isolation settings. (see below for nested schema)
            certificate: (Attributes) Specify certificate settings for Gateway TLS interception. If unset, the Cloudflare Root CA handles interception. (see below for nested schema)
            created_at: (String)
            custom_certificate: (Attributes, Deprecated) Specify custom certificate settings for BYO-PKI. This field is deprecated; use certificate instead. (see below for nested schema)
            enabled: (Boolean) Specify whether to log activity.
            enabled_download_phase: (Boolean) Specify whether to enable anti-virus scanning on downloads.
            enabled_upload_phase: (Boolean) Specify whether to enable anti-virus scanning on uploads.
            extended_email_matching: (Attributes) Configures user email settings for firewall policies. When you enable this, the system standardizes email addresses in the identity portion of the rule to match extended email variants in firewall policies. When you disable this setting, the system matches email addresses exactly as you provide them. Enable this setting if your email uses . or + modifiers. (see below for nested schema)
            fail_closed: (Boolean) Specify whether to block requests for unscannable files.
            fallback_action: |-
                (String) Specify the action to take when the system cannot scan the file.
                Available values: "allow", "block".
            fips: (Attributes) Specify FIPS settings. (see below for nested schema)
            footer_text: (String) Specify the block page footer text when the mode is customized_block_page.
            header_text: (String) Specify the block page header text when the mode is customized_block_page.
            host_selector: (Attributes) Enable host selection in egress policies. (see below for nested schema)
            id: (String) The ID of this resource.
            include_context: (Boolean) Specify whether to include context information as query parameters.
            inspection: (Attributes) Define the proxy inspection mode. (see below for nested schema)
            inspection_mode: |-
                (String) Specify the inspection mode as either deep or shallow.
                Available values: "deep", "shallow".
            logo_path: (String) Specify the full URL to the logo file when the mode is customized_block_page.
            mailto_address: (String) Specify the admin email for users to contact when the mode is customized_block_page.
            mailto_subject: (String) Specify the subject line for emails created from the block page when the mode is customized_block_page.
            mode: |-
                (String) Specify whether to redirect users to a Cloudflare-hosted block page or a customer-provided URI.
                Available values: "", "customized_block_page", "redirect_uri".
            msg: (String) Specify the message to show in the notification.
            name: (String) Specify the block page title when the mode is customized_block_page.
            non_identity_enabled: (Boolean) Specify whether to enable non-identity onramp support for Browser Isolation.
            notification_settings: (Attributes) Configure the message the user's device shows during an antivirus scan. (see below for nested schema)
            protocol_detection: (Attributes) Specify whether to detect protocols from the initial bytes of client traffic. (see below for nested schema)
            read_only: (Boolean) Indicate that this setting was shared via the Orgs API and read only for the current account.
            sandbox: (Attributes) Specify whether to enable the sandbox. (see below for nested schema)
            settings: (Attributes) Specify account settings. (see below for nested schema)
            source_account: (String) Indicate the account tag of the account that shared this setting.
            support_url: (String) Specify a URL that directs users to more information. If unset, the notification opens a block page.
            suppress_footer: (Boolean) Specify whether to suppress detailed information at the bottom of the block page when the mode is customized_block_page.
            target_uri: (String) Specify the URI to redirect users to when the mode is redirect_uri.
            tls: (Boolean) Enforce cipher suites and TLS versions compliant with FIPS 140-2.
            tls_decrypt: (Attributes) Specify whether to inspect encrypted HTTP traffic. (see below for nested schema)
            updated_at: (String)
            url_browser_isolation_enabled: (Boolean) Specify whether to enable Clientless Browser Isolation.
            version: (Number) Indicate the version number of the setting.
        importStatements:
            - $ terraform import cloudflare_zero_trust_gateway_settings.example '<account_id>'
    cloudflare_zero_trust_list:
        subCategory: ""
        name: cloudflare_zero_trust_list
        title: cloudflare_zero_trust_list Resource - Cloudflare
        examples:
            - name: example_zero_trust_list
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "description": "The serial numbers for administrators",
                  "items": [
                    {
                      "description": "Austin office IP",
                      "value": "8GE8721REF"
                    }
                  ],
                  "name": "Admin Serial Numbers",
                  "type": "SERIAL"
                }
        argumentDocs:
            account_id: (String)
            created_at: (String)
            description: (String) Provide the list description.
            id: (String) Identify the API resource with a UUID.
            items: (Attributes Set) Add items to the list. (see below for nested schema)
            list_count: (Number) Indicate the number of items in the list.
            name: (String) Specify the list name.
            type: |-
                (String) Specify the list type.
                Available values: "SERIAL", "URL", "DOMAIN", "EMAIL", "IP", "CATEGORY", "LOCATION", "DEVICE".
            updated_at: (String)
            value: (String) Specify the item value.
        importStatements:
            - $ terraform import cloudflare_zero_trust_list.example '<account_id>/<list_id>'
    cloudflare_zero_trust_network_hostname_route:
        subCategory: ""
        name: cloudflare_zero_trust_network_hostname_route
        title: cloudflare_zero_trust_network_hostname_route Resource - Cloudflare
        examples:
            - name: example_zero_trust_network_hostname_route
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "comment": "example comment",
                  "hostname": "office-1.local",
                  "tunnel_id": "f70ff985-a4ef-4643-bbbc-4a0ed4fc8415"
                }
        argumentDocs:
            account_id: (String) Cloudflare account ID
            comment: (String) An optional description of the hostname route.
            created_at: (String) Timestamp of when the resource was created.
            deleted_at: (String) Timestamp of when the resource was deleted. If null, the resource has not been deleted.
            hostname: (String) The hostname of the route.
            id: (String) The hostname route ID.
            tunnel_id: (String) UUID of the tunnel.
            tunnel_name: (String) A user-friendly name for a tunnel.
        importStatements:
            - $ terraform import cloudflare_zero_trust_network_hostname_route.example '<account_id>/<hostname_route_id>'
    cloudflare_zero_trust_organization:
        subCategory: ""
        name: cloudflare_zero_trust_organization
        title: cloudflare_zero_trust_organization Resource - Cloudflare
        examples:
            - name: example_zero_trust_organization
              manifest: |-
                {
                  "allow_authenticate_via_warp": true,
                  "auth_domain": "test.cloudflareaccess.com",
                  "auto_redirect_to_identity": true,
                  "custom_pages": {
                    "forbidden": "699d98642c564d2e855e9661899b7252",
                    "identity_denied": "699d98642c564d2e855e9661899b7252"
                  },
                  "is_ui_read_only": true,
                  "login_design": {
                    "background_color": "#c5ed1b",
                    "footer_text": "This is an example description.",
                    "header_text": "This is an example description.",
                    "logo_path": "https://example.com/logo.png",
                    "text_color": "#c5ed1b"
                  },
                  "name": "Widget Corps Internal Applications",
                  "session_duration": "24h",
                  "ui_read_only_toggle_reason": "Temporarily turn off the UI read only lock to make a change via the UI",
                  "user_seat_expiration_inactive_time": "730h",
                  "warp_auth_session_duration": "24h",
                  "zone_id": "zone_id"
                }
        argumentDocs:
            account_id: (String) The Account ID to use for this endpoint. Mutually exclusive with the Zone ID.
            allow_authenticate_via_warp: (Boolean) When set to true, users can authenticate via WARP for any application in your organization. Application settings will take precedence over this value.
            auth_domain: (String) The unique subdomain assigned to your Zero Trust organization.
            auto_redirect_to_identity: (Boolean) When set to true, users skip the identity provider selection step during login.
            background_color: (String) The background color on your login page.
            custom_pages: (Attributes) (see below for nested schema)
            footer_text: (String) The text at the bottom of your login page.
            forbidden: (String) The uid of the custom page to use when a user is denied access after failing a non-identity rule.
            header_text: (String) The text at the top of your login page.
            identity_denied: (String) The uid of the custom page to use when a user is denied access.
            is_ui_read_only: (Boolean) Lock all settings as Read-Only in the Dashboard, regardless of user permission. Updates may only be made via the API or Terraform for this account when enabled.
            login_design: (Attributes) (see below for nested schema)
            logo_path: (String) The URL of the logo on your login page.
            name: (String) The name of your Zero Trust organization.
            session_duration: '(String) The amount of time that tokens issued for applications will be valid. Must be in the format 300ms or 2h45m. Valid time units are: ns, us (or s), ms, s, m, h.'
            text_color: (String) The text color on your login page.
            ui_read_only_toggle_reason: (String) A description of the reason why the UI read only field is being toggled.
            user_seat_expiration_inactive_time: '(String) The amount of time a user seat is inactive before it expires. When the user seat exceeds the set time of inactivity, the user is removed as an active seat and no longer counts against your Teams seat count.  Minimum value for this setting is 1 month (730h). Must be in the format 300ms or 2h45m. Valid time units are: ns, us (or s), ms, s, m, h.'
            warp_auth_session_duration: '(String) The amount of time that tokens issued for applications will be valid. Must be in the format 30m or 2h45m. Valid time units are: m, h.'
            zone_id: (String) The Zone ID to use for this endpoint. Mutually exclusive with the Account ID.
        importStatements: []
    cloudflare_zero_trust_risk_behavior:
        subCategory: ""
        name: cloudflare_zero_trust_risk_behavior
        title: cloudflare_zero_trust_risk_behavior Resource - Cloudflare
        examples:
            - name: example_zero_trust_risk_behavior
              manifest: |-
                {
                  "account_id": "account_id",
                  "behaviors": {
                    "foo": {
                      "enabled": true,
                      "risk_level": "low"
                    }
                  }
                }
        argumentDocs:
            account_id: (String)
            behaviors: (Attributes Map) (see below for nested schema)
            enabled: (Boolean)
            risk_level: '(String) Available values: "low", "medium", "high".'
        importStatements: []
    cloudflare_zero_trust_risk_scoring_integration:
        subCategory: ""
        name: cloudflare_zero_trust_risk_scoring_integration
        title: cloudflare_zero_trust_risk_scoring_integration Resource - Cloudflare
        examples:
            - name: example_zero_trust_risk_scoring_integration
              manifest: |-
                {
                  "account_id": "account_id",
                  "integration_type": "Okta",
                  "reference_id": "reference_id",
                  "tenant_url": "https://example.com"
                }
        argumentDocs:
            account_id: (String)
            account_tag: (String) The Cloudflare account tag.
            active: (Boolean) Whether this integration is enabled. If disabled, no risk changes will be exported to the third-party.
            created_at: (String) When the integration was created in RFC3339 format.
            id: (String) The id of the integration, a UUIDv4.
            integration_type: '(String) Available values: "Okta".'
            reference_id: |-
                (String) A reference id that can be supplied by the client. Currently this should be set to the Access-Okta IDP ID (a UUIDv4).
                https://developers.cloudflare.com/api/operations/access-identity-providers-get-an-access-identity-provider
            tenant_url: (String) The base url of the tenant, e.g. "https://tenant.okta.com".
            well_known_url: (String) The URL for the Shared Signals Framework configuration, e.g. "/.well-known/sse-configuration/{integration_uuid}/". https://openid.net/specs/openid-sse-framework-1_0.html#rfc.section.6.2.1.
        importStatements:
            - $ terraform import cloudflare_zero_trust_risk_scoring_integration.example '<account_id>/<integration_id>'
    cloudflare_zero_trust_tunnel_cloudflared:
        subCategory: ""
        name: cloudflare_zero_trust_tunnel_cloudflared
        title: cloudflare_zero_trust_tunnel_cloudflared Resource - Cloudflare
        examples:
            - name: example_zero_trust_tunnel_cloudflared
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "config_src": "cloudflare",
                  "name": "blog",
                  "tunnel_secret": "AQIDBAUGBwgBAgMEBQYHCAECAwQFBgcIAQIDBAUGBwg="
                }
        argumentDocs:
            account_id: (String) Cloudflare account ID
            account_tag: (String) Cloudflare account ID
            client_id: (String) UUID of the Cloudflare Tunnel connector.
            client_version: (String) The cloudflared version used to establish this connection.
            colo_name: (String) The Cloudflare data center used for this connection.
            config_src: |-
                (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel on the Zero Trust dashboard.
                Available values: "local", "cloudflare".
            connections: (Attributes List, Deprecated) The Cloudflare Tunnel connections between your origin and Cloudflare's edge. (see below for nested schema)
            conns_active_at: (String) Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If null, the tunnel is inactive.
            conns_inactive_at: (String) Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If null, the tunnel is active.
            created_at: (String) Timestamp of when the resource was created.
            deleted_at: (String) Timestamp of when the resource was deleted. If null, the resource has not been deleted.
            id: (String) UUID of the tunnel.
            is_pending_reconnect: (Boolean) Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If true, the connection has disconnected but is still being tracked. If false, the connection is actively serving traffic.
            metadata: (String) Metadata associated with the tunnel.
            name: (String) A user-friendly name for a tunnel.
            opened_at: (String) Timestamp of when the connection was established.
            origin_ip: (String) The public IP address of the host running cloudflared.
            remote_config: (Boolean, Deprecated) If true, the tunnel can be configured remotely from the Zero Trust dashboard. If false, the tunnel must be configured locally on the origin machine.
            status: |-
                (String) The status of the tunnel. Valid values are inactive (tunnel has never been run), degraded (tunnel is active and able to serve traffic but in an unhealthy state), healthy (tunnel is active and able to serve traffic), or down (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
                Available values: "inactive", "degraded", "healthy", "down".
            tun_type: |-
                (String) The type of tunnel.
                Available values: "cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni".
            tunnel_secret: (String, Sensitive) Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
            uuid: (String) UUID of the Cloudflare Tunnel connection.
        importStatements:
            - $ terraform import cloudflare_zero_trust_tunnel_cloudflared.example '<account_id>/<tunnel_id>'
    cloudflare_zero_trust_tunnel_cloudflared_config:
        subCategory: ""
        name: cloudflare_zero_trust_tunnel_cloudflared_config
        title: cloudflare_zero_trust_tunnel_cloudflared_config Resource - Cloudflare
        examples:
            - name: example_zero_trust_tunnel_cloudflared_config
              manifest: |-
                {
                  "account_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "config": {
                    "ingress": [
                      {
                        "hostname": "tunnel.example.com",
                        "origin_request": {
                          "access": {
                            "aud_tag": [
                              "string"
                            ],
                            "required": false,
                            "team_name": "zero-trust-organization-name"
                          },
                          "ca_pool": "caPool",
                          "connect_timeout": 10,
                          "disable_chunked_encoding": true,
                          "http2_origin": true,
                          "http_host_header": "httpHostHeader",
                          "keep_alive_connections": 100,
                          "keep_alive_timeout": 90,
                          "match_sn_ito_host": false,
                          "no_happy_eyeballs": false,
                          "no_tls_verify": false,
                          "origin_server_name": "originServerName",
                          "proxy_type": "proxyType",
                          "tcp_keep_alive": 30,
                          "tls_timeout": 10
                        },
                        "path": "subpath",
                        "service": "https://localhost:8001"
                      }
                    ],
                    "origin_request": {
                      "access": {
                        "aud_tag": [
                          "string"
                        ],
                        "required": false,
                        "team_name": "zero-trust-organization-name"
                      },
                      "ca_pool": "caPool",
                      "connect_timeout": 10,
                      "disable_chunked_encoding": true,
                      "http2_origin": true,
                      "http_host_header": "httpHostHeader",
                      "keep_alive_connections": 100,
                      "keep_alive_timeout": 90,
                      "match_sn_ito_host": false,
                      "no_happy_eyeballs": false,
                      "no_tls_verify": false,
                      "origin_server_name": "originServerName",
                      "proxy_type": "proxyType",
                      "tcp_keep_alive": 30,
                      "tls_timeout": 10
                    }
                  },
                  "tunnel_id": "f70ff985-a4ef-4643-bbbc-4a0ed4fc8415"
                }
        argumentDocs:
            access: (Attributes) For all L7 requests to this hostname, cloudflared will validate each request's Cf-Access-Jwt-Assertion request header. (see below for nested schema)
            account_id: (String) Identifier.
            aud_tag: (List of String) Access applications that are allowed to reach this hostname for this Tunnel. Audience tags can be identified in the dashboard or via the List Access policies API.
            ca_pool: (String) Path to the certificate authority (CA) for the certificate of your origin. This option should be used only if your certificate is not signed by Cloudflare.
            config: (Attributes) The tunnel configuration and ingress rules. (see below for nested schema)
            connect_timeout: (Number) Timeout for establishing a new TCP connection to your origin server. This excludes the time taken to establish TLS, which is controlled by tlsTimeout.
            created_at: (String)
            disable_chunked_encoding: (Boolean) Disables chunked transfer encoding. Useful if you are running a WSGI server.
            hostname: (String) Public hostname for this service.
            http_host_header: (String) Sets the HTTP Host header on requests sent to the local service.
            http2_origin: (Boolean) Attempt to connect to origin using HTTP2. Origin must be configured as https.
            id: (String) UUID of the tunnel.
            ingress: (Attributes List) List of public hostname definitions. At least one ingress rule needs to be defined for the tunnel. (see below for nested schema)
            keep_alive_connections: (Number) Maximum number of idle keepalive connections between Tunnel and your origin. This does not restrict the total number of concurrent connections.
            keep_alive_timeout: (Number) Timeout after which an idle keepalive connection can be discarded.
            match_sn_ito_host: (Boolean) Auto configure the Hostname on the origin server certificate.
            no_happy_eyeballs: (Boolean) Disable the happy eyeballs algorithm for IPv4/IPv6 fallback if your local network has misconfigured one of the protocols.
            no_tls_verify: (Boolean) Disables TLS verification of the certificate presented by your origin. Will allow any certificate from the origin to be accepted.
            origin_request: (Attributes) Configuration parameters for the public hostname specific connection settings between cloudflared and origin server. (see below for nested schema)
            origin_server_name: (String) Hostname that cloudflared should expect from your origin server certificate.
            path: (String) Requests with this path route to this public hostname.
            proxy_type: '(String) cloudflared starts a proxy server to translate HTTP traffic into TCP when proxying, for example, SSH or RDP. This configures what type of proxy will be started. Valid options are: "" for the regular proxy and "socks" for a SOCKS5 proxy.'
            required: (Boolean) Deny traffic that has not fulfilled Access authorization.
            service: '(String) Protocol and address of destination server. Supported protocols: http://, https://, unix://, tcp://, ssh://, rdp://, unix+tls://, smb://. Alternatively can return a HTTP status code http_status:[code] e.g. ''http_status:404''.'
            source: |-
                (String) Indicates if this is a locally or remotely configured tunnel. If local, manage the tunnel using a YAML file on the origin machine. If cloudflare, manage the tunnel's configuration on the Zero Trust dashboard.
                Available values: "local", "cloudflare".
            tcp_keep_alive: (Number) The timeout after which a TCP keepalive packet is sent on a connection between Tunnel and the origin server.
            team_name: (String)
            tls_timeout: (Number) Timeout for completing a TLS handshake to your origin server, if you have chosen to connect Tunnel to an HTTPS server.
            tunnel_id: (String) UUID of the tunnel.
            version: (Number) The version of the Tunnel Configuration.
        importStatements:
            - $ terraform import cloudflare_zero_trust_tunnel_cloudflared_config.example '<account_id>/<tunnel_id>'
    cloudflare_zero_trust_tunnel_cloudflared_route:
        subCategory: ""
        name: cloudflare_zero_trust_tunnel_cloudflared_route
        title: cloudflare_zero_trust_tunnel_cloudflared_route Resource - Cloudflare
        examples:
            - name: example_zero_trust_tunnel_cloudflared_route
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "comment": "Example comment for this route.",
                  "network": "172.16.0.0/16",
                  "tunnel_id": "f70ff985-a4ef-4643-bbbc-4a0ed4fc8415",
                  "virtual_network_id": "f70ff985-a4ef-4643-bbbc-4a0ed4fc8415"
                }
        argumentDocs:
            account_id: (String) Cloudflare account ID
            comment: (String) Optional remark describing the route.
            created_at: (String) Timestamp of when the resource was created.
            deleted_at: (String) Timestamp of when the resource was deleted. If null, the resource has not been deleted.
            id: (String) UUID of the route.
            network: (String) The private IPv4 or IPv6 range connected by the route, in CIDR notation.
            tunnel_id: (String) UUID of the tunnel.
            virtual_network_id: (String) UUID of the virtual network.
        importStatements:
            - $ terraform import cloudflare_zero_trust_tunnel_cloudflared_route.example '<account_id>/<route_id>'
    cloudflare_zero_trust_tunnel_cloudflared_virtual_network:
        subCategory: ""
        name: cloudflare_zero_trust_tunnel_cloudflared_virtual_network
        title: cloudflare_zero_trust_tunnel_cloudflared_virtual_network Resource - Cloudflare
        examples:
            - name: example_zero_trust_tunnel_cloudflared_virtual_network
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "comment": "Staging VPC for data science",
                  "is_default": true,
                  "is_default_network": false,
                  "name": "us-east-1-vpc"
                }
        argumentDocs:
            account_id: (String) Cloudflare account ID
            comment: (String) Optional remark describing the virtual network.
            created_at: (String) Timestamp of when the resource was created.
            deleted_at: (String) Timestamp of when the resource was deleted. If null, the resource has not been deleted.
            id: (String) UUID of the virtual network.
            is_default: (Boolean, Deprecated) If true, this virtual network is the default for the account.
            is_default_network: (Boolean) If true, this virtual network is the default for the account.
            name: (String) A user-friendly name for the virtual network.
        importStatements:
            - $ terraform import cloudflare_zero_trust_tunnel_cloudflared_virtual_network.example '<account_id>/<virtual_network_id>'
    cloudflare_zero_trust_tunnel_warp_connector:
        subCategory: ""
        name: cloudflare_zero_trust_tunnel_warp_connector
        title: cloudflare_zero_trust_tunnel_warp_connector Resource - Cloudflare
        examples:
            - name: example_zero_trust_tunnel_warp_connector
              manifest: |-
                {
                  "account_id": "699d98642c564d2e855e9661899b7252",
                  "name": "blog"
                }
        argumentDocs:
            account_id: (String) Cloudflare account ID
            account_tag: (String) Cloudflare account ID
            client_id: (String) UUID of the Cloudflare Tunnel connector.
            client_version: (String) The cloudflared version used to establish this connection.
            colo_name: (String) The Cloudflare data center used for this connection.
            connections: (Attributes List, Deprecated) The Cloudflare Tunnel connections between your origin and Cloudflare's edge. (see below for nested schema)
            conns_active_at: (String) Timestamp of when the tunnel established at least one connection to Cloudflare's edge. If null, the tunnel is inactive.
            conns_inactive_at: (String) Timestamp of when the tunnel became inactive (no connections to Cloudflare's edge). If null, the tunnel is active.
            created_at: (String) Timestamp of when the resource was created.
            deleted_at: (String) Timestamp of when the resource was deleted. If null, the resource has not been deleted.
            id: (String) UUID of the tunnel.
            is_pending_reconnect: (Boolean) Cloudflare continues to track connections for several minutes after they disconnect. This is an optimization to improve latency and reliability of reconnecting.  If true, the connection has disconnected but is still being tracked. If false, the connection is actively serving traffic.
            metadata: (String) Metadata associated with the tunnel.
            name: (String) A user-friendly name for a tunnel.
            opened_at: (String) Timestamp of when the connection was established.
            origin_ip: (String) The public IP address of the host running cloudflared.
            status: |-
                (String) The status of the tunnel. Valid values are inactive (tunnel has never been run), degraded (tunnel is active and able to serve traffic but in an unhealthy state), healthy (tunnel is active and able to serve traffic), or down (tunnel can not serve traffic as it has no connections to the Cloudflare Edge).
                Available values: "inactive", "degraded", "healthy", "down".
            tun_type: |-
                (String) The type of tunnel.
                Available values: "cfd_tunnel", "warp_connector", "warp", "magic", "ip_sec", "gre", "cni".
            tunnel_secret: (String, Sensitive) Sets the password required to run a locally-managed tunnel. Must be at least 32 bytes and encoded as a base64 string.
            uuid: (String) UUID of the Cloudflare Tunnel connection.
        importStatements:
            - $ terraform import cloudflare_zero_trust_tunnel_warp_connector.example '<account_id>/<tunnel_id>'
    cloudflare_zone:
        subCategory: ""
        name: cloudflare_zone
        title: cloudflare_zone Resource - Cloudflare
        examples:
            - name: example_zone
              manifest: |-
                {
                  "account": {
                    "id": "023e105f4ecef8ad9ca31a8372d0c353"
                  },
                  "name": "example.com",
                  "type": "full"
                }
        argumentDocs:
            account: (Attributes) (see below for nested schema)
            activated_on: |-
                (String) The last time proof of ownership was detected and the zone was made
                active.
            can_subscribe: (Boolean) States if the subscription can be activated.
            cdn_only: (Boolean) The zone is only configured for CDN.
            cname_suffix: |-
                (String) Allows the customer to use a custom apex.
                Tenants Only Configuration.
            created_on: (String) When the zone was created.
            currency: (String) The denomination of the customer.
            custom_certificate_quota: (Number) Number of Custom Certificates the zone can have.
            development_mode: |-
                (Number) The interval (in seconds) from when development mode expires
                (positive integer) or last expired (negative integer) for the
                domain. If development mode has never been enabled, this value is 0.
            dns_only: (Boolean) The zone is only configured for DNS.
            externally_managed: (Boolean) If this Zone is managed by another company.
            foundation_dns: (Boolean) The zone is setup with Foundation DNS.
            frequency: (String) How often the customer is billed.
            id: (String) Identifier
            is_subscribed: (Boolean) States if the subscription active.
            legacy_discount: (Boolean) If the legacy discount applies to this Zone.
            legacy_id: (String) The legacy name of the plan.
            meta: (Attributes) Metadata about the zone. (see below for nested schema)
            modified_on: (String) When the zone was last modified.
            name: (String) The domain name.
            name_servers: (List of String) The name servers Cloudflare assigns to a zone.
            original_dnshost: (String) DNS host at the time of switching to Cloudflare.
            original_name_servers: (List of String) Original name servers before moving to Cloudflare.
            original_registrar: (String) Registrar for the domain at the time of switching to Cloudflare.
            owner: (Attributes) The owner of the zone. (see below for nested schema)
            page_rule_quota: (Number) Number of Page Rules a zone can have.
            paused: |-
                (Boolean) Indicates whether the zone is only using Cloudflare DNS services. A
                true value means the zone will not receive security or performance
                benefits.
            permissions: (List of String, Deprecated) Legacy permissions based on legacy user membership information.
            phishing_detected: (Boolean) The zone has been flagged for phishing.
            plan: (Attributes, Deprecated) A Zones subscription information. (see below for nested schema)
            price: (Number) How much the customer is paying.
            status: |-
                (String) The zone status on Cloudflare.
                Available values: "initializing", "pending", "active", "moved".
            step: (Number)
            tenant: (Attributes) The root organizational unit that this zone belongs to (such as a tenant or organization). (see below for nested schema)
            tenant_unit: (Attributes) The immediate parent organizational unit that this zone belongs to (such as under a tenant or sub-organization). (see below for nested schema)
            type: |-
                (String) A full zone implies that DNS is hosted with Cloudflare. A partial zone is
                typically a partner-hosted zone or a CNAME setup.
                Available values: "full", "partial", "secondary", "internal".
            vanity_name_servers: |-
                (List of String) An array of domains used for custom name servers. This is only
                available for Business and Enterprise plans.
            verification_key: (String) Verification key for partial zone setup.
        importStatements:
            - $ terraform import cloudflare_zone.example '<zone_id>'
    cloudflare_zone_cache_reserve:
        subCategory: ""
        name: cloudflare_zone_cache_reserve
        title: cloudflare_zone_cache_reserve Resource - Cloudflare
        examples:
            - name: example_zone_cache_reserve
              manifest: |-
                {
                  "value": "on",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            editable: (Boolean) Whether the setting is editable.
            id: (String) Identifier.
            modified_on: (String) Last time this setting was modified.
            value: |-
                (String) Value of the Cache Reserve zone setting.
                Available values: "on", "off".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_zone_cache_reserve.example '<zone_id>'
    cloudflare_zone_cache_variants:
        subCategory: ""
        name: cloudflare_zone_cache_variants
        title: cloudflare_zone_cache_variants Resource - Cloudflare
        examples:
            - name: example_zone_cache_variants
              manifest: |-
                {
                  "value": {
                    "avif": [
                      "image/webp",
                      "image/jpeg"
                    ],
                    "bmp": [
                      "image/webp",
                      "image/jpeg"
                    ],
                    "gif": [
                      "image/webp",
                      "image/jpeg"
                    ],
                    "jp2": [
                      "image/webp",
                      "image/avif"
                    ],
                    "jpeg": [
                      "image/webp",
                      "image/avif"
                    ],
                    "jpg": [
                      "image/webp",
                      "image/avif"
                    ],
                    "jpg2": [
                      "image/webp",
                      "image/avif"
                    ],
                    "png": [
                      "image/webp",
                      "image/avif"
                    ],
                    "tif": [
                      "image/webp",
                      "image/avif"
                    ],
                    "tiff": [
                      "image/webp",
                      "image/avif"
                    ],
                    "webp": [
                      "image/jpeg",
                      "image/avif"
                    ]
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            avif: (List of String) List of strings with the MIME types of all the variants that should be served for avif.
            bmp: (List of String) List of strings with the MIME types of all the variants that should be served for bmp.
            editable: (Boolean) Whether the setting is editable.
            gif: (List of String) List of strings with the MIME types of all the variants that should be served for gif.
            id: (String) Identifier.
            jp2: (List of String) List of strings with the MIME types of all the variants that should be served for jp2.
            jpeg: (List of String) List of strings with the MIME types of all the variants that should be served for jpeg.
            jpg: (List of String) List of strings with the MIME types of all the variants that should be served for jpg.
            jpg2: (List of String) List of strings with the MIME types of all the variants that should be served for jpg2.
            modified_on: (String) Last time this setting was modified.
            png: (List of String) List of strings with the MIME types of all the variants that should be served for png.
            tif: (List of String) List of strings with the MIME types of all the variants that should be served for tif.
            tiff: (List of String) List of strings with the MIME types of all the variants that should be served for tiff.
            value: (Attributes) Value of the zone setting. (see below for nested schema)
            webp: (List of String) List of strings with the MIME types of all the variants that should be served for webp.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_zone_cache_variants.example '<zone_id>'
    cloudflare_zone_dns_settings:
        subCategory: ""
        name: cloudflare_zone_dns_settings
        title: cloudflare_zone_dns_settings Resource - Cloudflare
        examples:
            - name: example_zone_dns_settings
              manifest: |-
                {
                  "flatten_all_cnames": false,
                  "foundation_dns": false,
                  "internal_dns": {
                    "reference_zone_id": "reference_zone_id"
                  },
                  "multi_provider": false,
                  "nameservers": {
                    "ns_set": 1,
                    "type": "cloudflare.standard"
                  },
                  "ns_ttl": 86400,
                  "secondary_overrides": false,
                  "soa": {
                    "expire": 604800,
                    "min_ttl": 1800,
                    "mname": "kristina.ns.cloudflare.com",
                    "refresh": 10000,
                    "retry": 2400,
                    "rname": "admin.example.com",
                    "ttl": 3600
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353",
                  "zone_mode": "dns_only"
                }
        argumentDocs:
            expire: (Number) Time in seconds of being unable to query the primary server after which secondary servers should stop serving the zone.
            flatten_all_cnames: (Boolean) Whether to flatten all CNAME records in the zone. Note that, due to DNS limitations, a CNAME record at the zone apex will always be flattened.
            foundation_dns: (Boolean) Whether to enable Foundation DNS Advanced Nameservers on the zone.
            internal_dns: (Attributes) Settings for this internal zone. (see below for nested schema)
            min_ttl: (Number) The time to live (TTL) for negative caching of records within the zone.
            mname: (String) The primary nameserver, which may be used for outbound zone transfers. If null, a Cloudflare-assigned value will be used.
            multi_provider: (Boolean) Whether to enable multi-provider DNS, which causes Cloudflare to activate the zone even when non-Cloudflare NS records exist, and to respect NS records at the zone apex during outbound zone transfers.
            nameservers: (Attributes) Settings determining the nameservers through which the zone should be available. (see below for nested schema)
            ns_set: (Number) Configured nameserver set to be used for this zone
            ns_ttl: (Number) The time to live (TTL) of the zone's nameserver (NS) records.
            reference_zone_id: (String) The ID of the zone to fallback to.
            refresh: (Number) Time in seconds after which secondary servers should re-check the SOA record to see if the zone has been updated.
            retry: (Number) Time in seconds after which secondary servers should retry queries after the primary server was unresponsive.
            rname: (String) The email address of the zone administrator, with the first label representing the local part of the email address.
            secondary_overrides: (Boolean) Allows a Secondary DNS zone to use (proxied) override records and CNAME flattening at the zone apex.
            soa: (Attributes) Components of the zone's SOA record. (see below for nested schema)
            ttl: (Number) The time to live (TTL) of the SOA record itself.
            type: |-
                (String) Nameserver type
                Available values: "cloudflare.standard", "custom.account", "custom.tenant", "custom.zone".
            zone_id: (String) Identifier.
            zone_mode: |-
                (String) Whether the zone mode is a regular or CDN/DNS only zone.
                Available values: "standard", "cdn_only", "dns_only".
        importStatements: []
    cloudflare_zone_dnssec:
        subCategory: ""
        name: cloudflare_zone_dnssec
        title: cloudflare_zone_dnssec Resource - Cloudflare
        examples:
            - name: example_zone_dnssec
              manifest: |-
                {
                  "dnssec_multi_signer": false,
                  "dnssec_presigned": true,
                  "dnssec_use_nsec3": false,
                  "status": "active",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            algorithm: (String) Algorithm key code.
            digest: (String) Digest hash.
            digest_algorithm: (String) Type of digest algorithm.
            digest_type: (String) Coded type for digest algorithm.
            dnssec_multi_signer: |-
                (Boolean) If true, multi-signer DNSSEC is enabled on the zone, allowing multiple
                providers to serve a DNSSEC-signed zone at the same time.
                This is required for DNSKEY records (except those automatically
                generated by Cloudflare) to be added to the zone.
            dnssec_presigned: |-
                (Boolean) If true, allows Cloudflare to transfer in a DNSSEC-signed zone
                including signatures from an external provider, without requiring
                Cloudflare to sign any records on the fly.
            dnssec_use_nsec3: |-
                (Boolean) If true, enables the use of NSEC3 together with DNSSEC on the zone.
                Combined with setting dnssec_presigned to true, this enables the use of
                NSEC3 records when transferring in from an external provider.
                If dnssec_presigned is instead set to false (default), NSEC3 records will be
                generated and signed at request time.
            ds: (String) Full DS record.
            flags: (Number) Flag for DNSSEC record.
            id: (String) Identifier.
            key_tag: (Number) Code for key tag.
            key_type: (String) Algorithm key type.
            modified_on: (String) When DNSSEC was last modified.
            public_key: (String) Public key for DS record.
            status: |-
                (String) Status of DNSSEC, based on user-desired state and presence of necessary records.
                Available values: "active", "disabled".
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_zone_dnssec.example '<zone_id>'
    cloudflare_zone_hold:
        subCategory: ""
        name: cloudflare_zone_hold
        title: cloudflare_zone_hold Resource - Cloudflare
        examples:
            - name: example_zone_hold
              manifest: |-
                {
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            hold: (Boolean)
            hold_after: |-
                (String) If hold_after is provided and future-dated, the hold will be temporarily disabled,
                then automatically re-enabled by the system at the time specified
                in this RFC3339-formatted timestamp. A past-dated hold_after value will have
                no effect on an existing, enabled hold. Providing an empty string will set its value
                to the current time.
            id: (String) Identifier.
            include_subdomains: |-
                (Boolean) If true, the zone hold will extend to block any subdomain of the given zone, as well
                as SSL4SaaS Custom Hostnames. For example, a zone hold on a zone with the hostname
                'example.com' and include_subdomains=true will block 'example.com',
                'staging.example.com', 'api.staging.example.com', etc.
            zone_id: (String) Identifier.
        importStatements:
            - $ terraform import cloudflare_zone_hold.example '<zone_id>'
    cloudflare_zone_lockdown:
        subCategory: ""
        name: cloudflare_zone_lockdown
        title: cloudflare_zone_lockdown Resource - Cloudflare
        examples:
            - name: example_zone_lockdown
              manifest: |-
                {
                  "configurations": [
                    {
                      "target": "ip",
                      "value": "198.51.100.4"
                    }
                  ],
                  "description": "Prevent multiple login failures to mitigate brute force attacks",
                  "paused": false,
                  "priority": 5,
                  "urls": [
                    "shop.example.com/*"
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            configurations: (Attributes List) A list of IP addresses or CIDR ranges that will be allowed to access the URLs specified in the Zone Lockdown rule. You can include any number of ip or ip_range configurations. (see below for nested schema)
            created_on: (String) The timestamp of when the rule was created.
            description: (String) An informative summary of the rule. This value is sanitized and any tags will be removed.
            id: (String) The unique identifier of the Zone Lockdown rule.
            modified_on: (String) The timestamp of when the rule was last modified.
            paused: (Boolean) When true, indicates that the rule is currently paused.
            priority: (Number) The priority of the rule to control the processing order. A lower number indicates higher priority. If not provided, any rules with a configured priority will be processed before rules without a priority.
            target: |-
                (String) The configuration target. You must set the target to ip when specifying an IP address in the Zone Lockdown rule.
                Available values: "ip", "ip_range".
            urls: (List of String) The URLs to include in the current WAF override. You can use wildcards. Each entered URL will be escaped before use, which means you can only use simple wildcard patterns.
            value: (String) The IP address to match. This address will be compared to the IP address of incoming requests.
            zone_id: (String) Defines an identifier.
        importStatements:
            - $ terraform import cloudflare_zone_lockdown.example '<zone_id>/<lock_downs_id>'
    cloudflare_zone_setting:
        subCategory: ""
        name: cloudflare_zone_setting
        title: cloudflare_zone_setting Resource - Cloudflare
        examples:
            - name: always_online
              manifest: |-
                {
                  "setting_id": "always_online",
                  "value": "on",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: min_tls_version
              manifest: |-
                {
                  "setting_id": "min_tls_version",
                  "value": "1.2",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: browser_cache_ttl
              manifest: |-
                {
                  "setting_id": "browser_cache_ttl",
                  "value": 14400,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: ciphers
              manifest: |-
                {
                  "setting_id": "ciphers",
                  "value": [
                    "ECDHE-ECDSA-AES128-GCM-SHA256",
                    "ECDHE-ECDSA-CHACHA20-POLY1305"
                  ],
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: security_header
              manifest: |-
                {
                  "setting_id": "security_header",
                  "value": {
                    "strict_transport_security": {
                      "enabled": true,
                      "include_subdomains": true,
                      "max_age": 86400,
                      "nosniff": true,
                      "preload": false
                    }
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: ssl_recommender
              manifest: |-
                {
                  "enabled": true,
                  "setting_id": "ssl_recommender",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: min_tls
              manifest: |-
                {
                  "setting_id": "min_tls_version",
                  "value": "1.2",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: ssl
              manifest: |-
                {
                  "setting_id": "ssl",
                  "value": "strict",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: security_level
              manifest: |-
                {
                  "setting_id": "security_level",
                  "value": "medium",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: cache_level
              manifest: |-
                {
                  "setting_id": "cache_level",
                  "value": "aggressive",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: browser_cache_ttl
              manifest: |-
                {
                  "setting_id": "browser_cache_ttl",
                  "value": 14400,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: challenge_ttl
              manifest: |-
                {
                  "setting_id": "challenge_ttl",
                  "value": 1800,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: max_upload
              manifest: |-
                {
                  "setting_id": "max_upload",
                  "value": 100,
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: zero_rtt
              manifest: |-
                {
                  "setting_id": "0rtt",
                  "value": "on",
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: nel
              manifest: |-
                {
                  "setting_id": "nel",
                  "value": {
                    "enabled": true
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
            - name: always_use_https
              manifest: |-
                {
                  "setting_id": "always_use_https",
                  "value": "on",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: automatic_https_rewrites
              manifest: |-
                {
                  "setting_id": "automatic_https_rewrites",
                  "value": "on",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: min_tls_version
              manifest: |-
                {
                  "setting_id": "min_tls_version",
                  "value": "1.2",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: tls_1_3
              manifest: |-
                {
                  "setting_id": "tls_1_3",
                  "value": "on",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: ssl
              manifest: |-
                {
                  "setting_id": "ssl",
                  "value": "strict",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: http3
              manifest: |-
                {
                  "setting_id": "http3",
                  "value": "on",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: brotli
              manifest: |-
                {
                  "setting_id": "brotli",
                  "value": "on",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: early_hints
              manifest: |-
                {
                  "setting_id": "early_hints",
                  "value": "on",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: cache_level
              manifest: |-
                {
                  "setting_id": "cache_level",
                  "value": "aggressive",
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
            - name: browser_cache
              manifest: |-
                {
                  "setting_id": "browser_cache_ttl",
                  "value": 14400,
                  "zone_id": "${var.zone_id}"
                }
              references:
                zone_id: var.zone_id
        argumentDocs:
            editable: (Boolean) Whether or not this setting can be modified for this zone (based on your Cloudflare plan level).
            enabled: (Boolean) ssl-recommender enrollment setting.
            id: (String) Setting name
            modified_on: (String) last time this setting was modified.
            setting_id: (String) Setting name
            time_remaining: |-
                (Number) Value of the zone setting.
                Notes: The interval (in seconds) from when development mode expires (positive integer) or last expired (negative integer) for the domain. If development mode has never been enabled, this value is false.
            value: (Dynamic) Current value of the zone setting.
            zone_id: (String) Identifier
        importStatements:
            - $ terraform import cloudflare_zone_setting.example '<zone_id>/<setting_id>'
    cloudflare_zone_subscription:
        subCategory: ""
        name: cloudflare_zone_subscription
        title: cloudflare_zone_subscription Resource - Cloudflare
        examples:
            - name: example_zone_subscription
              manifest: |-
                {
                  "frequency": "monthly",
                  "rate_plan": {
                    "currency": "USD",
                    "externally_managed": false,
                    "id": "free",
                    "is_contract": false,
                    "public_name": "Business Plan",
                    "scope": "zone",
                    "sets": [
                      "string"
                    ]
                  },
                  "zone_id": "023e105f4ecef8ad9ca31a8372d0c353"
                }
        argumentDocs:
            currency: (String) The monetary unit in which pricing information is displayed.
            current_period_end: (String) The end of the current period and also when the next billing is due.
            current_period_start: (String) When the current billing period started. May match initial_period_start if this is the first period.
            externally_managed: (Boolean) Whether this rate plan is managed externally from Cloudflare.
            frequency: |-
                (String) How often the subscription is renewed automatically.
                Available values: "weekly", "monthly", "quarterly", "yearly".
                Note: Some plans may not support frequency configuration and will return "not-applicable".
            id: (String) Identifier
            is_contract: (Boolean) Whether a rate plan is enterprise-based (or newly adopted term contract).
            price: (Number) The price of the subscription that will be billed, in US dollars.
            public_name: (String) The full name of the rate plan.
            rate_plan: (Attributes) The rate plan applied to the subscription. (see below for nested schema)
            scope: (String) The scope that this rate plan applies to.
            sets: (List of String) The list of sets this rate plan applies to. Returns array of strings.
            state: |-
                (String) The state that the subscription is in.
                Available values: "Trial", "Provisioned", "Paid", "AwaitingPayment", "Cancelled", "Failed", "Expired".
            zone_id: (String) Identifier
        importStatements:
            - $ terraform import cloudflare_zone_subscription.example '<zone_id>'
